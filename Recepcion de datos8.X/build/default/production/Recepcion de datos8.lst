CCS PCH C Compiler, Version 4.130, 59972               19-sep-18 11:37

               Filename: Z:\Mecatronica\Alumnos\Segundo\Proyecto\GUI\Recepcion de datos8.X\build\default\production\Recepcion de datos8.lst

               ROM used: 7538 bytes (23%)
                         Largest free fragment is 25226
               RAM used: 118 (6%) at main() level
                         154 (8%) worst case
               Stack:    9 worst case (7 in main + 2 for interrupts)

*
0000:  GOTO   196C
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   0246
0060:  BTFSS  FF2.4
0062:  GOTO   006C
0066:  BTFSC  FF2.1
0068:  GOTO   01C8
006C:  BTFSS  FF0.4
006E:  GOTO   0078
0072:  BTFSC  FF0.1
0074:  GOTO   016E
0078:  BTFSS  F9D.5
007A:  GOTO   0084
007E:  BTFSC  F9E.5
0080:  GOTO   0316
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVFF  15,FF5
00BE:  MOVFF  16,FF6
00C2:  MOVFF  17,FF7
00C6:  MOVF   04,W
00C8:  MOVFF  06,FE0
00CC:  MOVFF  05,FD8
00D0:  RETFIE 0
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
*
11D2:  CLRF   x7C
11D4:  CLRF   x7B
11D6:  CLRF   x7A
11D8:  MOVLW  7F
11DA:  MOVWF  x79
11DC:  CLRF   x80
11DE:  CLRF   x7F
11E0:  CLRF   x7E
11E2:  CLRF   x7D
11E4:  BSF    x81.0
11E6:  BCF    x81.1
11E8:  BCF    x81.2
11EA:  CLRF   x83
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
11EC:  MOVF   x75,W
11EE:  IORWF  x76,W
11F0:  BNZ   11FC
....................       return 0; 
11F2:  CLRF   00
11F4:  CLRF   01
11F6:  CLRF   02
11F8:  CLRF   03
11FA:  BRA    1408
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
11FC:  MOVF   x83,W
11FE:  INCF   x83,F
1200:  CLRF   03
1202:  ADDWF  x75,W
1204:  MOVWF  FE9
1206:  MOVF   x76,W
1208:  ADDWFC 03,W
120A:  MOVWF  FEA
120C:  MOVFF  FEF,82
1210:  MOVF   x82,F
1212:  BTFSC  FD8.2
1214:  BRA    1392
....................    { 
....................       if (skip && !isspace(c)) 
1216:  BTFSS  x81.0
1218:  BRA    1238
121A:  MOVF   x82,W
121C:  SUBLW  20
121E:  BZ    1238
....................       { 
....................          skip = 0; 
1220:  BCF    x81.0
....................          if (c == '+') 
1222:  MOVF   x82,W
1224:  SUBLW  2B
1226:  BNZ   122E
....................          { 
....................             sign = 0; 
1228:  BCF    x81.1
....................             continue; 
122A:  BRA    137C
....................          }             
....................          else if (c == '-') 
122C:  BRA    1238
122E:  MOVF   x82,W
1230:  SUBLW  2D
1232:  BNZ   1238
....................          { 
....................             sign = 1; 
1234:  BSF    x81.1
....................             continue; 
1236:  BRA    137C
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
1238:  BTFSC  x81.0
123A:  BRA    124A
123C:  MOVF   x82,W
123E:  SUBLW  2E
1240:  BNZ   124A
1242:  BTFSC  x81.2
1244:  BRA    124A
....................          point = 1; 
1246:  BSF    x81.2
....................       else if (!skip && isdigit(c)) 
1248:  BRA    137C
124A:  BTFSC  x81.0
124C:  BRA    1376
124E:  MOVF   x82,W
1250:  SUBLW  2F
1252:  BTFSC  FD8.0
1254:  BRA    1376
1256:  MOVF   x82,W
1258:  SUBLW  39
125A:  BTFSS  FD8.0
125C:  BRA    1376
....................       { 
....................          c -= '0'; 
125E:  MOVLW  30
1260:  SUBWF  x82,F
....................          if (point) 
1262:  BTFSS  x81.2
1264:  BRA    1308
....................          { 
....................             pow10 = pow10 * 10.0; 
1266:  MOVFF  7C,87
126A:  MOVFF  7B,86
126E:  MOVFF  7A,85
1272:  MOVFF  79,84
1276:  CLRF   x8B
1278:  CLRF   x8A
127A:  MOVLW  20
127C:  MOVWF  x89
127E:  MOVLW  82
1280:  MOVWF  x88
1282:  RCALL  10AA
1284:  MOVFF  03,7C
1288:  MOVFF  02,7B
128C:  MOVFF  01,7A
1290:  MOVFF  00,79
....................             result += (float)c / pow10;    
1294:  CLRF   x89
1296:  MOVFF  82,88
129A:  RCALL  119C
129C:  MOVFF  00,84
12A0:  MOVFF  01,85
12A4:  MOVFF  02,86
12A8:  MOVFF  03,87
12AC:  MOVFF  03,8B
12B0:  MOVFF  02,8A
12B4:  MOVFF  01,89
12B8:  MOVFF  00,88
12BC:  MOVFF  7C,8F
12C0:  MOVFF  7B,8E
12C4:  MOVFF  7A,8D
12C8:  MOVFF  79,8C
12CC:  CALL   08E6
12D0:  BCF    FD8.1
12D2:  MOVFF  80,8B
12D6:  MOVFF  7F,8A
12DA:  MOVFF  7E,89
12DE:  MOVFF  7D,88
12E2:  MOVFF  03,8F
12E6:  MOVFF  02,8E
12EA:  MOVFF  01,8D
12EE:  MOVFF  00,8C
12F2:  CALL   0AB6
12F6:  MOVFF  03,80
12FA:  MOVFF  02,7F
12FE:  MOVFF  01,7E
1302:  MOVFF  00,7D
....................          } 
....................          else 
1306:  BRA    1374
....................          { 
....................             result = 10.0 * result + (float)c; 
1308:  CLRF   x87
130A:  CLRF   x86
130C:  MOVLW  20
130E:  MOVWF  x85
1310:  MOVLW  82
1312:  MOVWF  x84
1314:  MOVFF  80,8B
1318:  MOVFF  7F,8A
131C:  MOVFF  7E,89
1320:  MOVFF  7D,88
1324:  RCALL  10AA
1326:  MOVFF  00,84
132A:  MOVFF  01,85
132E:  MOVFF  02,86
1332:  MOVFF  03,87
1336:  CLRF   x89
1338:  MOVFF  82,88
133C:  RCALL  119C
133E:  BCF    FD8.1
1340:  MOVFF  87,8B
1344:  MOVFF  86,8A
1348:  MOVFF  85,89
134C:  MOVFF  84,88
1350:  MOVFF  03,8F
1354:  MOVFF  02,8E
1358:  MOVFF  01,8D
135C:  MOVFF  00,8C
1360:  CALL   0AB6
1364:  MOVFF  03,80
1368:  MOVFF  02,7F
136C:  MOVFF  01,7E
1370:  MOVFF  00,7D
....................          } 
....................       } 
....................       else if (!skip) 
1374:  BRA    137C
1376:  BTFSC  x81.0
1378:  BRA    137C
....................          break; 
137A:  BRA    1392
....................    } 
137C:  MOVF   x83,W
137E:  INCF   x83,F
1380:  CLRF   03
1382:  ADDWF  x75,W
1384:  MOVWF  FE9
1386:  MOVF   x76,W
1388:  ADDWFC 03,W
138A:  MOVWF  FEA
138C:  MOVFF  FEF,82
1390:  BRA    1210
....................  
....................    if (sign) 
1392:  BTFSS  x81.1
1394:  BRA    13C4
....................       result = -1*result; 
1396:  CLRF   x87
1398:  CLRF   x86
139A:  MOVLW  80
139C:  MOVWF  x85
139E:  MOVLW  7F
13A0:  MOVWF  x84
13A2:  MOVFF  80,8B
13A6:  MOVFF  7F,8A
13AA:  MOVFF  7E,89
13AE:  MOVFF  7D,88
13B2:  RCALL  10AA
13B4:  MOVFF  03,80
13B8:  MOVFF  02,7F
13BC:  MOVFF  01,7E
13C0:  MOVFF  00,7D
....................        
....................    if(endptr) 
13C4:  MOVF   x77,W
13C6:  IORWF  x78,W
13C8:  BZ    13F8
....................    { 
....................       if (ptr) { 
13CA:  MOVF   x83,F
13CC:  BZ    13E6
....................          ptr--; 
13CE:  DECF   x83,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
13D0:  MOVFF  77,FE9
13D4:  MOVFF  78,FEA
13D8:  MOVF   x83,W
13DA:  ADDWF  x75,W
13DC:  MOVWF  FEF
13DE:  MOVLW  00
13E0:  ADDWFC x76,W
13E2:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
13E4:  BRA    13F8
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
13E6:  MOVFF  77,FE9
13EA:  MOVFF  78,FEA
13EE:  MOVFF  76,FEC
13F2:  MOVF   FED,F
13F4:  MOVFF  75,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
13F8:  MOVFF  7D,00
13FC:  MOVFF  7E,01
1400:  MOVFF  7F,02
1404:  MOVFF  80,03
.................... } 
1408:  RETURN 0
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,PLL5,CPUDIV1,VREGEN,MCLR,USBDIV,  // 48 MHz  para  el  USB y 48 MHz para  el resto del sistema 
.................... //#fuses HS,NOWDT,NOLVP,CPUDIV1,MCLR 
.................... #use delay(clock=48000000) 
*
0180:  CLRF   FEA
0182:  MOVLW  98
0184:  MOVWF  FE9
0186:  MOVF   FEF,W
0188:  BZ    01A6
018A:  MOVLW  0F
018C:  MOVWF  01
018E:  CLRF   00
0190:  DECFSZ 00,F
0192:  BRA    0190
0194:  DECFSZ 01,F
0196:  BRA    018E
0198:  MOVLW  8F
019A:  MOVWF  00
019C:  DECFSZ 00,F
019E:  BRA    019C
01A0:  NOP   
01A2:  DECFSZ FEF,F
01A4:  BRA    018A
01A6:  RETURN 0
01A8:  MOVLW  01
01AA:  SUBWF  x98,F
01AC:  BNC   01C6
01AE:  CLRF   FEA
01B0:  MOVLW  98
01B2:  MOVWF  FE9
01B4:  MOVF   FEF,W
01B6:  BZ    01C6
01B8:  MOVLW  02
01BA:  MOVWF  00
01BC:  DECFSZ 00,F
01BE:  BRA    01BC
01C0:  BRA    01C2
01C2:  DECFSZ FEF,F
01C4:  BRA    01B8
01C6:  RETURN 0
.................... #use rs232(baud=9600, xmit=pin_c6, rcv=pin_c7, bits=8, parity=N,stream=standard)  
*
0166:  BTFSS  F9E.4
0168:  BRA    0166
016A:  MOVWF  FAD
016C:  RETURN 0
.................... //#define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... //#include <lcd420.c> 
.................... #include <LCD420-FLEX.c> 
.................... // Flex_LCD420.c 
....................  
.................... // These pins are for my Microchip PicDem2-Plus board, 
.................... // which I used to test this driver. 
.................... // An external 20x4 LCD is connected to these pins. 
.................... // Change these pins to match your own board's connections. 
.................... /* 
.................... #define LCD_DB4   PIN_B4 
.................... #define LCD_DB5   PIN_B5 
.................... #define LCD_DB6   PIN_B6 
.................... #define LCD_DB7   PIN_B7 
....................  
.................... #define LCD_RS    PIN_B3 
.................... //#define LCD_RW    PIN_B0 it is earthed at the display 
.................... #define LCD_E     PIN_B2 
.................... */ 
....................  
.................... // To prove that the driver can be used with random 
.................... // pins, I also tested it with these pins: 
.................... #define LCD_DB4   PIN_B4 
.................... #define LCD_DB5   PIN_B5 
.................... #define LCD_DB6   PIN_B6 
.................... #define LCD_DB7   PIN_B7 
....................  
.................... #define LCD_RS    PIN_C2 
.................... //#define LCD_RW    PIN_B1 
.................... #define LCD_E     PIN_B3 
....................  
....................  
.................... // If you want only a 6-pin interface to your LCD, then 
.................... // connect the R/W pin on the LCD to ground, and comment 
.................... // out the following line.  Doing so will save one PIC 
.................... // pin, but at the cost of losing the ability to read from 
.................... // the LCD.  It also makes the write time a little longer 
.................... // because a static delay must be used, instead of polling 
.................... // the LCD's busy bit.  Normally a 6-pin interface is only 
.................... // used if you are running out of PIC pins, and you need 
.................... // to use as few as possible for the LCD. 
....................  
.................... //#define USE_RW_PIN   1      
....................  
....................  
.................... // These are the line addresses for most 4x20 LCDs. 
.................... #define LCD_LINE_1_ADDRESS 0x00 
.................... #define LCD_LINE_2_ADDRESS 0x40 
.................... #define LCD_LINE_3_ADDRESS 0x14 
.................... #define LCD_LINE_4_ADDRESS 0x54 
....................  
.................... // These are the line addresses for LCD's which use 
.................... // the Hitachi HD66712U controller chip. 
.................... /* 
.................... #define LCD_LINE_1_ADDRESS 0x00 
.................... #define LCD_LINE_2_ADDRESS 0x20 
.................... #define LCD_LINE_3_ADDRESS 0x40 
.................... #define LCD_LINE_4_ADDRESS 0x60 
.................... */ 
....................  
....................  
.................... //======================================== 
....................  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more) 
....................  
.................... int8 lcd_line; 
....................  
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots 
....................  0xc,                     // Display on 
....................  1,                       // Clear display 
....................  6                        // Increment cursor 
....................  }; 
....................                               
....................  
.................... //------------------------------------- 
.................... void lcd_send_nibble(int8 nibble) 
.................... { 
.................... // Note:  !! converts an integer expression 
.................... // to a boolean (1 or 0). 
....................  output_bit(LCD_DB4, !!(nibble & 1)); 
*
0586:  BTFSC  x8A.0
0588:  BRA    058E
058A:  BCF    F8A.4
058C:  BRA    0590
058E:  BSF    F8A.4
0590:  BCF    F93.4
....................  output_bit(LCD_DB5, !!(nibble & 2));  
0592:  BTFSC  x8A.1
0594:  BRA    059A
0596:  BCF    F8A.5
0598:  BRA    059C
059A:  BSF    F8A.5
059C:  BCF    F93.5
....................  output_bit(LCD_DB6, !!(nibble & 4));    
059E:  BTFSC  x8A.2
05A0:  BRA    05A6
05A2:  BCF    F8A.6
05A4:  BRA    05A8
05A6:  BSF    F8A.6
05A8:  BCF    F93.6
....................  output_bit(LCD_DB7, !!(nibble & 8));    
05AA:  BTFSC  x8A.3
05AC:  BRA    05B2
05AE:  BCF    F8A.7
05B0:  BRA    05B4
05B2:  BSF    F8A.7
05B4:  BCF    F93.7
....................  
....................  delay_us(2); 
05B6:  MOVLW  07
05B8:  MOVWF  00
05BA:  DECFSZ 00,F
05BC:  BRA    05BA
05BE:  BRA    05C0
....................  output_high(LCD_E); 
05C0:  BCF    F93.3
05C2:  BSF    F8A.3
....................  delay_us(2); 
05C4:  MOVLW  07
05C6:  MOVWF  00
05C8:  DECFSZ 00,F
05CA:  BRA    05C8
05CC:  BRA    05CE
....................  output_low(LCD_E); 
05CE:  BCF    F93.3
05D0:  BCF    F8A.3
.................... } 
05D2:  RETURN 0
....................  
.................... //----------------------------------- 
.................... // This sub-routine is only called by lcd_read_byte(). 
.................... // It's not a stand-alone routine.  For example, the 
.................... // R/W signal is set high by lcd_read_byte() before 
.................... // this routine is called.      
....................  
.................... #ifdef USE_RW_PIN 
.................... int8 lcd_read_nibble(void) 
.................... { 
.................... int8 retval; 
.................... // Create bit variables so that we can easily set 
.................... // individual bits in the retval variable. 
.................... #bit retval_0 = retval.0 
.................... #bit retval_1 = retval.1 
.................... #bit retval_2 = retval.2 
.................... #bit retval_3 = retval.3 
....................  
.................... retval = 0; 
....................     
.................... output_high(LCD_E); 
.................... delay_us(1); 
....................  
.................... retval_0 = input(LCD_DB4); 
.................... retval_1 = input(LCD_DB5); 
.................... retval_2 = input(LCD_DB6); 
.................... retval_3 = input(LCD_DB7); 
....................   
.................... output_low(LCD_E); 
.................... delay_us(1); 
....................     
.................... return(retval);    
.................... }    
.................... #endif 
....................  
.................... //--------------------------------------- 
.................... // Read a byte from the LCD and return it. 
....................  
.................... #ifdef USE_RW_PIN 
.................... int8 lcd_read_byte(void) 
.................... { 
.................... int8 low; 
.................... int8 high; 
....................  
.................... output_high(LCD_RW); 
.................... delay_cycles(1); 
....................  
.................... high = lcd_read_nibble(); 
....................  
.................... low = lcd_read_nibble(); 
....................  
.................... return( (high<<4) | low); 
.................... } 
.................... #endif 
....................  
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
.................... output_low(LCD_RS); 
05D4:  BCF    F94.2
05D6:  BCF    F8B.2
....................  
.................... #ifdef USE_RW_PIN 
.................... while(bit_test(lcd_read_byte(),7)) ; 
.................... #else 
.................... delay_us(60);  
05D8:  MOVLW  EF
05DA:  MOVWF  00
05DC:  DECFSZ 00,F
05DE:  BRA    05DC
05E0:  BRA    05E2
.................... #endif 
....................  
.................... if(address) 
05E2:  MOVF   x87,F
05E4:  BZ    05EC
....................    output_high(LCD_RS); 
05E6:  BCF    F94.2
05E8:  BSF    F8B.2
.................... else 
05EA:  BRA    05F0
....................    output_low(LCD_RS); 
05EC:  BCF    F94.2
05EE:  BCF    F8B.2
....................       
....................  //delay_cycles(1); 
.................... delay_us(2); 
05F0:  MOVLW  07
05F2:  MOVWF  00
05F4:  DECFSZ 00,F
05F6:  BRA    05F4
05F8:  BRA    05FA
....................  
.................... #ifdef USE_RW_PIN 
.................... output_low(LCD_RW); 
.................... delay_cycles(1); 
.................... #endif 
....................  
.................... output_low(LCD_E); 
05FA:  BCF    F93.3
05FC:  BCF    F8A.3
....................  
.................... lcd_send_nibble(n >> 4); 
05FE:  SWAPF  x88,W
0600:  MOVWF  x89
0602:  MOVLW  0F
0604:  ANDWF  x89,F
0606:  MOVFF  89,8A
060A:  RCALL  0586
.................... lcd_send_nibble(n & 0xf); 
060C:  MOVF   x88,W
060E:  ANDLW  0F
0610:  MOVWF  x89
0612:  MOVWF  x8A
0614:  RCALL  0586
.................... } 
0616:  RETURN 0
.................... //---------------------------- 
....................  
.................... void lcd_init(void) 
.................... { 
.................... int8 i; 
....................  
.................... lcd_line = 1; 
0618:  MOVLW  01
061A:  MOVWF  20
....................  
.................... output_low(LCD_RS); 
061C:  BCF    F94.2
061E:  BCF    F8B.2
....................  
.................... #ifdef USE_RW_PIN 
.................... output_low(LCD_RW); 
.................... #endif 
....................  
.................... output_low(LCD_E); 
0620:  BCF    F93.3
0622:  BCF    F8A.3
0624:  CLRF   19
0626:  BTFSC  FF2.7
0628:  BSF    19.7
062A:  BCF    FF2.7
....................  
.................... // Some LCDs require 15 ms minimum delay after 
.................... // power-up.  Others require 30 ms.  I'm going 
.................... // to set it to 35 ms, so it should work with 
.................... // all of them. 
.................... delay_ms(35);          
062C:  MOVLW  23
062E:  MOVWF  x98
0630:  RCALL  0180
0632:  BTFSC  19.7
0634:  BSF    FF2.7
....................  
.................... for(i=0 ;i < 3; i++) 
0636:  CLRF   x75
0638:  MOVF   x75,W
063A:  SUBLW  02
063C:  BNC   065A
....................    { 
....................     lcd_send_nibble(0x03); 
063E:  MOVLW  03
0640:  MOVWF  x8A
0642:  RCALL  0586
0644:  CLRF   19
0646:  BTFSC  FF2.7
0648:  BSF    19.7
064A:  BCF    FF2.7
....................     delay_ms(5); 
064C:  MOVLW  05
064E:  MOVWF  x98
0650:  RCALL  0180
0652:  BTFSC  19.7
0654:  BSF    FF2.7
....................    } 
0656:  INCF   x75,F
0658:  BRA    0638
....................  
.................... lcd_send_nibble(0x02); 
065A:  MOVLW  02
065C:  MOVWF  x8A
065E:  RCALL  0586
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
0660:  CLRF   x75
0662:  MOVF   x75,W
0664:  SUBLW  03
0666:  BNC   068C
....................    { 
....................     lcd_send_byte(0, LCD_INIT_STRING[i]); 
0668:  CLRF   03
066A:  MOVF   x75,W
066C:  RCALL  00D2
066E:  MOVWF  x76
0670:  CLRF   x87
0672:  MOVWF  x88
0674:  RCALL  05D4
0676:  CLRF   19
0678:  BTFSC  FF2.7
067A:  BSF    19.7
067C:  BCF    FF2.7
....................     
....................     // If the R/W signal is not used, then 
....................     // the busy bit can't be polled.  One of 
....................     // the init commands takes longer than 
....................     // the hard-coded delay of 50 us, so in 
....................     // that case, lets just do a 5 ms delay 
....................     // after all four of them. 
....................     #ifndef USE_RW_PIN 
....................     delay_ms(5); 
067E:  MOVLW  05
0680:  MOVWF  x98
0682:  RCALL  0180
0684:  BTFSC  19.7
0686:  BSF    FF2.7
....................     #endif 
....................    } 
0688:  INCF   x75,F
068A:  BRA    0662
....................  
.................... } 
068C:  GOTO   19CA (RETURN)
....................  
.................... //---------------------------- 
....................  
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
.................... int8 address; 
....................  
....................  
.................... switch(y) 
....................   { 
0690:  MOVF   x84,W
0692:  XORLW  01
0694:  BZ    06A4
0696:  XORLW  03
0698:  BZ    06A8
069A:  XORLW  01
069C:  BZ    06AE
069E:  XORLW  07
06A0:  BZ    06B4
06A2:  BRA    06BA
....................    case 1: 
....................      address = LCD_LINE_1_ADDRESS; 
06A4:  CLRF   x85
....................      break; 
06A6:  BRA    06BE
....................  
....................    case 2: 
....................      address = LCD_LINE_2_ADDRESS; 
06A8:  MOVLW  40
06AA:  MOVWF  x85
....................      break; 
06AC:  BRA    06BE
....................  
....................    case 3: 
....................      address = LCD_LINE_3_ADDRESS; 
06AE:  MOVLW  14
06B0:  MOVWF  x85
....................      break; 
06B2:  BRA    06BE
....................  
....................    case 4: 
....................      address = LCD_LINE_4_ADDRESS; 
06B4:  MOVLW  54
06B6:  MOVWF  x85
....................      break; 
06B8:  BRA    06BE
....................  
....................    default: 
....................      address = LCD_LINE_1_ADDRESS; 
06BA:  CLRF   x85
....................      break; 
06BC:  BRA    06BE
....................       
....................   } 
....................  
.................... address += x-1; 
06BE:  MOVLW  01
06C0:  SUBWF  x83,W
06C2:  ADDWF  x85,F
.................... lcd_send_byte(0, 0x80 | address); 
06C4:  MOVF   x85,W
06C6:  IORLW  80
06C8:  MOVWF  x86
06CA:  CLRF   x87
06CC:  MOVWF  x88
06CE:  RCALL  05D4
.................... } 
06D0:  RETURN 0
....................  
.................... //----------------------------- 
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c) 
....................    { 
06D2:  MOVF   x82,W
06D4:  XORLW  0C
06D6:  BZ    06E2
06D8:  XORLW  06
06DA:  BZ    0702
06DC:  XORLW  02
06DE:  BZ    0710
06E0:  BRA    071A
....................     case '\f': 
....................       lcd_send_byte(0,1); 
06E2:  CLRF   x87
06E4:  MOVLW  01
06E6:  MOVWF  x88
06E8:  RCALL  05D4
....................       lcd_line = 1; 
06EA:  MOVLW  01
06EC:  MOVWF  20
06EE:  CLRF   19
06F0:  BTFSC  FF2.7
06F2:  BSF    19.7
06F4:  BCF    FF2.7
....................       delay_ms(2); 
06F6:  MOVLW  02
06F8:  MOVWF  x98
06FA:  RCALL  0180
06FC:  BTFSC  19.7
06FE:  BSF    FF2.7
....................       break; 
0700:  BRA    0726
....................     
....................     case '\n': 
....................        lcd_gotoxy(1, ++lcd_line); 
0702:  INCF   20,F
0704:  MOVLW  01
0706:  MOVWF  x83
0708:  MOVFF  20,84
070C:  RCALL  0690
....................        break; 
070E:  BRA    0726
....................     
....................     case '\b': 
....................        lcd_send_byte(0,0x10); 
0710:  CLRF   x87
0712:  MOVLW  10
0714:  MOVWF  x88
0716:  RCALL  05D4
....................        break; 
0718:  BRA    0726
....................     
....................     default: 
....................        lcd_send_byte(1,c); 
071A:  MOVLW  01
071C:  MOVWF  x87
071E:  MOVFF  82,88
0722:  RCALL  05D4
....................        break; 
0724:  BRA    0726
....................    } 
.................... } 
0726:  RETURN 0
....................  
.................... //------------------------------ 
.................... #ifdef USE_RW_PIN 
.................... char lcd_getc(int8 x, int8 y) 
.................... { 
.................... char value; 
....................  
.................... lcd_gotoxy(x,y); 
....................  
.................... // Wait until busy flag is low. 
.................... while(bit_test(lcd_read_byte(),7));  
....................  
.................... output_high(LCD_RS); 
.................... value = lcd_read_byte(); 
.................... output_low(LCD_RS); 
....................  
.................... return(value); 
.................... } 
.................... #endif 
....................  
.................... #include <MATH.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define sentidox PIN_D0 
.................... #define sentidoy PIN_D1 
.................... #define sentidoz PIN_D2 
.................... #define motorx PIN_D3 
.................... #define motory PIN_D4 
.................... #define motorz PIN_D5 
.................... #define cerox PIN_D6 
.................... #define ceroy PIN_D7 
.................... #define ceroz PIN_C0 
.................... #define profunz PIN_C1 
.................... #define dremel PIN_E0 
.................... #define enter PIN_E1 
.................... #define habilx PIN_E2 
.................... #define habily PIN_A0 
.................... #define habilz PIN_A1 
.................... #define canalb PIN_A2 
....................  
.................... char ch; 
.................... char mech[4]; 
.................... char datox[7]; 
.................... char datoy[7]; 
.................... //char mecha[4]; 
.................... int i, j, h, flagfin, salir; 
.................... int contador; 
.................... signed int32 x, y, xini, yini, pasosx, pasosy; 
.................... float broca, pasosxflot, pasosyflot; 
.................... int flagx, flagy, flagxy, flagcomienzo, flagmecha, flagboton; 
.................... short int flagpaquete, flagajuste; 
.................... signed int32 pasosz, zini, z, alturamecha; 
....................  
.................... void moverz(void) { 
....................     output_low(habilz); 
*
1744:  BCF    F92.1
1746:  BCF    F89.1
....................     pasosz = z - zini; 
1748:  MOVF   x69,W
174A:  SUBWF  x6D,W
174C:  MOVWF  x65
174E:  MOVF   x6A,W
1750:  SUBWFB x6E,W
1752:  MOVWF  x66
1754:  MOVF   x6B,W
1756:  SUBWFB x6F,W
1758:  MOVWF  x67
175A:  MOVF   x6C,W
175C:  SUBWFB x70,W
175E:  MOVWF  x68
....................     //pasosz=pasosz-zini; 
....................  
....................     while (pasosz > 0) { 
1760:  BTFSC  x68.7
1762:  BRA    17E0
1764:  MOVF   x68,F
1766:  BNZ   1776
1768:  MOVF   x67,F
176A:  BNZ   1776
176C:  MOVF   x66,F
176E:  BNZ   1776
1770:  MOVF   x65,W
1772:  SUBLW  00
1774:  BC    17E0
....................         output_high(sentidoz); //para abajo 
1776:  BCF    F95.2
1778:  BSF    F8C.2
....................         output_high(motorz); 
177A:  BCF    F95.5
177C:  BSF    F8C.5
....................         delay_us(1200); 
177E:  CLRF   19
1780:  BTFSC  FF2.7
1782:  BSF    19.7
1784:  BCF    FF2.7
1786:  MOVLW  01
1788:  MOVWF  x98
178A:  CALL   0180
178E:  BTFSC  19.7
1790:  BSF    FF2.7
1792:  CLRF   19
1794:  BTFSC  FF2.7
1796:  BSF    19.7
1798:  BCF    FF2.7
179A:  MOVLW  C8
179C:  MOVWF  x98
179E:  CALL   01A8
17A2:  BTFSC  19.7
17A4:  BSF    FF2.7
....................         output_low(motorz); 
17A6:  BCF    F95.5
17A8:  BCF    F8C.5
....................         delay_us(1200); 
17AA:  CLRF   19
17AC:  BTFSC  FF2.7
17AE:  BSF    19.7
17B0:  BCF    FF2.7
17B2:  MOVLW  01
17B4:  MOVWF  x98
17B6:  CALL   0180
17BA:  BTFSC  19.7
17BC:  BSF    FF2.7
17BE:  CLRF   19
17C0:  BTFSC  FF2.7
17C2:  BSF    19.7
17C4:  BCF    FF2.7
17C6:  MOVLW  C8
17C8:  MOVWF  x98
17CA:  CALL   01A8
17CE:  BTFSC  19.7
17D0:  BSF    FF2.7
....................         pasosz = pasosz - 1; 
17D2:  MOVLW  01
17D4:  SUBWF  x65,F
17D6:  MOVLW  00
17D8:  SUBWFB x66,F
17DA:  SUBWFB x67,F
17DC:  SUBWFB x68,F
....................     } 
17DE:  BRA    1760
....................     while (pasosz < 0) { 
17E0:  BTFSC  x68.7
17E2:  BRA    17E6
17E4:  BRA    1850
....................         output_low(sentidoz); //para arriba 
17E6:  BCF    F95.2
17E8:  BCF    F8C.2
....................         output_high(motorz); 
17EA:  BCF    F95.5
17EC:  BSF    F8C.5
....................         delay_us(1200); 
17EE:  CLRF   19
17F0:  BTFSC  FF2.7
17F2:  BSF    19.7
17F4:  BCF    FF2.7
17F6:  MOVLW  01
17F8:  MOVWF  x98
17FA:  CALL   0180
17FE:  BTFSC  19.7
1800:  BSF    FF2.7
1802:  CLRF   19
1804:  BTFSC  FF2.7
1806:  BSF    19.7
1808:  BCF    FF2.7
180A:  MOVLW  C8
180C:  MOVWF  x98
180E:  CALL   01A8
1812:  BTFSC  19.7
1814:  BSF    FF2.7
....................         output_low(motorz); 
1816:  BCF    F95.5
1818:  BCF    F8C.5
....................         delay_us(1200); 
181A:  CLRF   19
181C:  BTFSC  FF2.7
181E:  BSF    19.7
1820:  BCF    FF2.7
1822:  MOVLW  01
1824:  MOVWF  x98
1826:  CALL   0180
182A:  BTFSC  19.7
182C:  BSF    FF2.7
182E:  CLRF   19
1830:  BTFSC  FF2.7
1832:  BSF    19.7
1834:  BCF    FF2.7
1836:  MOVLW  C8
1838:  MOVWF  x98
183A:  CALL   01A8
183E:  BTFSC  19.7
1840:  BSF    FF2.7
....................         pasosz = pasosz + 1; 
1842:  MOVLW  01
1844:  ADDWF  x65,F
1846:  MOVLW  00
1848:  ADDWFC x66,F
184A:  ADDWFC x67,F
184C:  ADDWFC x68,F
....................     } 
184E:  BRA    17E0
....................     zini = z; 
1850:  MOVFF  70,6C
1854:  MOVFF  6F,6B
1858:  MOVFF  6E,6A
185C:  MOVFF  6D,69
.................... } 
1860:  RETURN 0
....................  
.................... void bajarz(void) { 
....................     while (pasosz > 0) { //rutina que baja el cabezal 
....................         output_low(habilz); 
....................         pasosz = pasosz - 1; 
....................         output_high(sentidoz); 
....................         output_toggle(motorz); 
....................         delay_us(1200); 
....................     } 
.................... } 
....................  
.................... void subirz(void) { 
....................     while (pasosz > 0) { //rutina que sube el cabezal 
....................         output_low(sentidoz); 
....................         pasosz = pasosz - 1; 
....................         output_toggle(motorz); 
....................         delay_us(1200); 
....................     } 
.................... } 
....................  
.................... void conversionpasos(void) { 
....................     pasosxflot = (x - xini) / 200.0; 
*
0DAC:  MOVF   42,W
0DAE:  SUBWF  3A,W
0DB0:  MOVWF  x75
0DB2:  MOVF   43,W
0DB4:  SUBWFB 3B,W
0DB6:  MOVWF  x76
0DB8:  MOVF   44,W
0DBA:  SUBWFB 3C,W
0DBC:  MOVWF  x77
0DBE:  MOVF   45,W
0DC0:  SUBWFB 3D,W
0DC2:  MOVWF  x78
0DC4:  MOVWF  x7C
0DC6:  MOVFF  77,7B
0DCA:  MOVFF  76,7A
0DCE:  MOVFF  75,79
0DD2:  RCALL  0890
0DD4:  MOVFF  03,8B
0DD8:  MOVFF  02,8A
0DDC:  MOVFF  01,89
0DE0:  MOVFF  00,88
0DE4:  CLRF   x8F
0DE6:  CLRF   x8E
0DE8:  MOVLW  48
0DEA:  MOVWF  x8D
0DEC:  MOVLW  86
0DEE:  MOVWF  x8C
0DF0:  RCALL  08E6
0DF2:  MOVFF  03,59
0DF6:  MOVFF  02,58
0DFA:  MOVFF  01,57
0DFE:  MOVFF  00,56
....................     pasosyflot = (y - yini) / 200.0; 
0E02:  MOVF   46,W
0E04:  SUBWF  3E,W
0E06:  MOVWF  x75
0E08:  MOVF   47,W
0E0A:  SUBWFB 3F,W
0E0C:  MOVWF  x76
0E0E:  MOVF   48,W
0E10:  SUBWFB 40,W
0E12:  MOVWF  x77
0E14:  MOVF   49,W
0E16:  SUBWFB 41,W
0E18:  MOVWF  x78
0E1A:  MOVWF  x7C
0E1C:  MOVFF  77,7B
0E20:  MOVFF  76,7A
0E24:  MOVFF  75,79
0E28:  RCALL  0890
0E2A:  MOVFF  03,8B
0E2E:  MOVFF  02,8A
0E32:  MOVFF  01,89
0E36:  MOVFF  00,88
0E3A:  CLRF   x8F
0E3C:  CLRF   x8E
0E3E:  MOVLW  48
0E40:  MOVWF  x8D
0E42:  MOVLW  86
0E44:  MOVWF  x8C
0E46:  RCALL  08E6
0E48:  MOVFF  03,5D
0E4C:  MOVFF  02,5C
0E50:  MOVFF  01,5B
0E54:  MOVFF  00,5A
....................     if (pasosxflot >= 0) 
0E58:  CLRF   x78
0E5A:  CLRF   x77
0E5C:  CLRF   x76
0E5E:  CLRF   x75
0E60:  MOVFF  59,7C
0E64:  MOVFF  58,7B
0E68:  MOVFF  57,7A
0E6C:  MOVFF  56,79
0E70:  RCALL  0A40
0E72:  BC    0E76
0E74:  BNZ   0ECC
....................         pasosx = (signed long int) (pasosxflot + 0.5); 
0E76:  BCF    FD8.1
0E78:  MOVFF  59,8B
0E7C:  MOVFF  58,8A
0E80:  MOVFF  57,89
0E84:  MOVFF  56,88
0E88:  CLRF   x8F
0E8A:  CLRF   x8E
0E8C:  CLRF   x8D
0E8E:  MOVLW  7E
0E90:  MOVWF  x8C
0E92:  RCALL  0AB6
0E94:  MOVFF  03,78
0E98:  MOVFF  02,77
0E9C:  MOVFF  01,76
0EA0:  MOVFF  00,75
0EA4:  RCALL  0D20
0EA6:  MOVFF  01,00
0EAA:  MOVFF  02,01
0EAE:  CLRF   02
0EB0:  CLRF   03
0EB2:  BTFSS  01.7
0EB4:  BRA    0EBA
0EB6:  DECF   02,F
0EB8:  DECF   03,F
0EBA:  MOVFF  03,4D
0EBE:  MOVFF  02,4C
0EC2:  MOVFF  01,4B
0EC6:  MOVFF  00,4A
....................     else 
0ECA:  BRA    0F20
....................         pasosx = (signed long int) (pasosxflot - 0.5); 
0ECC:  BSF    FD8.1
0ECE:  MOVFF  59,8B
0ED2:  MOVFF  58,8A
0ED6:  MOVFF  57,89
0EDA:  MOVFF  56,88
0EDE:  CLRF   x8F
0EE0:  CLRF   x8E
0EE2:  CLRF   x8D
0EE4:  MOVLW  7E
0EE6:  MOVWF  x8C
0EE8:  RCALL  0AB6
0EEA:  MOVFF  03,78
0EEE:  MOVFF  02,77
0EF2:  MOVFF  01,76
0EF6:  MOVFF  00,75
0EFA:  RCALL  0D20
0EFC:  MOVFF  01,00
0F00:  MOVFF  02,01
0F04:  CLRF   02
0F06:  CLRF   03
0F08:  BTFSS  01.7
0F0A:  BRA    0F10
0F0C:  DECF   02,F
0F0E:  DECF   03,F
0F10:  MOVFF  03,4D
0F14:  MOVFF  02,4C
0F18:  MOVFF  01,4B
0F1C:  MOVFF  00,4A
....................  
....................     if (pasosyflot >= 0) 
0F20:  CLRF   x78
0F22:  CLRF   x77
0F24:  CLRF   x76
0F26:  CLRF   x75
0F28:  MOVFF  5D,7C
0F2C:  MOVFF  5C,7B
0F30:  MOVFF  5B,7A
0F34:  MOVFF  5A,79
0F38:  RCALL  0A40
0F3A:  BC    0F3E
0F3C:  BNZ   0F94
....................         pasosy = (signed long int) (pasosyflot + 0.5); 
0F3E:  BCF    FD8.1
0F40:  MOVFF  5D,8B
0F44:  MOVFF  5C,8A
0F48:  MOVFF  5B,89
0F4C:  MOVFF  5A,88
0F50:  CLRF   x8F
0F52:  CLRF   x8E
0F54:  CLRF   x8D
0F56:  MOVLW  7E
0F58:  MOVWF  x8C
0F5A:  RCALL  0AB6
0F5C:  MOVFF  03,78
0F60:  MOVFF  02,77
0F64:  MOVFF  01,76
0F68:  MOVFF  00,75
0F6C:  RCALL  0D20
0F6E:  MOVFF  01,00
0F72:  MOVFF  02,01
0F76:  CLRF   02
0F78:  CLRF   03
0F7A:  BTFSS  01.7
0F7C:  BRA    0F82
0F7E:  DECF   02,F
0F80:  DECF   03,F
0F82:  MOVFF  03,51
0F86:  MOVFF  02,50
0F8A:  MOVFF  01,4F
0F8E:  MOVFF  00,4E
....................     else 
0F92:  BRA    0FE8
....................         pasosy = (signed long int) (pasosyflot - 0.5); 
0F94:  BSF    FD8.1
0F96:  MOVFF  5D,8B
0F9A:  MOVFF  5C,8A
0F9E:  MOVFF  5B,89
0FA2:  MOVFF  5A,88
0FA6:  CLRF   x8F
0FA8:  CLRF   x8E
0FAA:  CLRF   x8D
0FAC:  MOVLW  7E
0FAE:  MOVWF  x8C
0FB0:  RCALL  0AB6
0FB2:  MOVFF  03,78
0FB6:  MOVFF  02,77
0FBA:  MOVFF  01,76
0FBE:  MOVFF  00,75
0FC2:  RCALL  0D20
0FC4:  MOVFF  01,00
0FC8:  MOVFF  02,01
0FCC:  CLRF   02
0FCE:  CLRF   03
0FD0:  BTFSS  01.7
0FD2:  BRA    0FD8
0FD4:  DECF   02,F
0FD6:  DECF   03,F
0FD8:  MOVFF  03,51
0FDC:  MOVFF  02,50
0FE0:  MOVFF  01,4F
0FE4:  MOVFF  00,4E
....................  
....................     pasosx = pasosx * 2; 
0FE8:  MOVFF  4D,78
0FEC:  MOVFF  4C,77
0FF0:  MOVFF  4B,76
0FF4:  MOVFF  4A,75
0FF8:  CLRF   x7C
0FFA:  CLRF   x7B
0FFC:  CLRF   x7A
0FFE:  MOVLW  02
1000:  MOVWF  x79
1002:  RCALL  0D58
1004:  MOVFF  03,4D
1008:  MOVFF  02,4C
100C:  MOVFF  01,4B
1010:  MOVFF  00,4A
....................     pasosy = pasosy * 2; 
1014:  MOVFF  51,78
1018:  MOVFF  50,77
101C:  MOVFF  4F,76
1020:  MOVFF  4E,75
1024:  CLRF   x7C
1026:  CLRF   x7B
1028:  CLRF   x7A
102A:  MOVLW  02
102C:  MOVWF  x79
102E:  RCALL  0D58
1030:  MOVFF  03,51
1034:  MOVFF  02,50
1038:  MOVFF  01,4F
103C:  MOVFF  00,4E
....................  
.................... } 
1040:  RETURN 0
....................  
.................... void perforacion(void) { 
....................     output_high(dremel); 
*
1884:  BCF    F96.0
1886:  BSF    F8D.0
....................     while (flagpaquete == 0); 
1888:  BTFSS  x64.0
188A:  BRA    1888
....................     while (flagpaquete == 1) { 
188C:  BTFSS  x64.0
188E:  BRA    1964
....................         while (flagxy == 0); 
1890:  MOVF   x60,F
1892:  BZ    1890
....................         while (flagxy == 1) { 
1894:  DECFSZ x60,W
1896:  BRA    1962
....................             x = (signed long long int) atof(datox); 
1898:  CLRF   x76
189A:  MOVLW  26
189C:  MOVWF  x75
189E:  CLRF   x78
18A0:  CLRF   x77
18A2:  RCALL  11D2
18A4:  MOVFF  03,85
18A8:  MOVFF  02,84
18AC:  MOVFF  01,83
18B0:  MOVFF  00,82
18B4:  RCALL  1452
18B6:  MOVFF  03,3D
18BA:  MOVFF  02,3C
18BE:  MOVFF  01,3B
18C2:  MOVFF  00,3A
....................             y = (signed long long int) atof(datoy); 
18C6:  CLRF   x76
18C8:  MOVLW  2D
18CA:  MOVWF  x75
18CC:  CLRF   x78
18CE:  CLRF   x77
18D0:  RCALL  11D2
18D2:  MOVFF  03,85
18D6:  MOVFF  02,84
18DA:  MOVFF  01,83
18DE:  MOVFF  00,82
18E2:  RCALL  1452
18E4:  MOVFF  03,41
18E8:  MOVFF  02,40
18EC:  MOVFF  01,3F
18F0:  MOVFF  00,3E
....................             conversionpasos(); 
18F4:  CALL   0DAC
....................             xini = x; 
18F8:  MOVFF  3D,45
18FC:  MOVFF  3C,44
1900:  MOVFF  3B,43
1904:  MOVFF  3A,42
....................             yini = y; 
1908:  MOVFF  41,49
190C:  MOVFF  40,48
1910:  MOVFF  3F,47
1914:  MOVFF  3E,46
....................             clear_interrupt(int_timer0); 
1918:  BCF    FF2.2
....................             set_timer0(230); 
191A:  CLRF   FD7
191C:  MOVLW  E6
191E:  MOVWF  FD6
....................             enable_interrupts(INT_TIMER0); //Habilita interrupcin timer0 
1920:  BSF    FF2.5
....................             flagx = 1; 
1922:  MOVLW  01
1924:  MOVWF  5E
....................             flagy = 1; 
1926:  MOVWF  5F
....................             while (flagxy == 1); 
1928:  DECFSZ x60,W
192A:  BRA    192E
192C:  BRA    1928
....................             //bajarz(); 
....................             z = alturamecha + 300; 
192E:  MOVLW  2C
1930:  ADDWF  x71,W
1932:  MOVWF  x6D
1934:  MOVLW  01
1936:  ADDWFC x72,W
1938:  MOVWF  x6E
193A:  MOVLW  00
193C:  ADDWFC x73,W
193E:  MOVWF  x6F
1940:  MOVLW  00
1942:  ADDWFC x74,W
1944:  MOVWF  x70
....................             moverz(); 
1946:  RCALL  1744
....................             z = alturamecha; //trabajando a por paso completo son 1cm(100*0,2)/2 
1948:  MOVFF  74,70
194C:  MOVFF  73,6F
1950:  MOVFF  72,6E
1954:  MOVFF  71,6D
....................             //subirz();   
....................             moverz(); 
1958:  RCALL  1744
....................             putc('*'); 
195A:  MOVLW  2A
195C:  CALL   0166
....................         } 
1960:  BRA    1894
....................     } 
1962:  BRA    188C
....................     output_low(dremel); 
1964:  BCF    F96.0
1966:  BCF    F8D.0
.................... } 
1968:  GOTO   1D6E (RETURN)
....................  
.................... void moverxy(void) { 
....................     clear_interrupt(int_timer0); 
*
1042:  BCF    FF2.2
....................     set_timer0(230); 
1044:  CLRF   FD7
1046:  MOVLW  E6
1048:  MOVWF  FD6
....................     enable_interrupts(INT_TIMER0); //Habilita interrupcin timer0 
104A:  BSF    FF2.5
....................     flagx = 1; 
104C:  MOVLW  01
104E:  MOVWF  5E
....................     flagy = 1; 
1050:  MOVWF  5F
....................     flagxy = 1; 
1052:  MOVWF  x60
....................     while (flagxy == 1); 
1054:  DECFSZ x60,W
1056:  BRA    105A
1058:  BRA    1054
.................... } 
105A:  GOTO   10A2 (RETURN)
....................  
.................... void posicionmecha(void) { 
....................     x = +150000; 
105E:  CLRF   3D
1060:  MOVLW  02
1062:  MOVWF  3C
1064:  MOVLW  49
1066:  MOVWF  3B
1068:  MOVLW  F0
106A:  MOVWF  3A
....................     y = +200000; 
106C:  CLRF   41
106E:  MOVLW  03
1070:  MOVWF  40
1072:  MOVLW  0D
1074:  MOVWF  3F
1076:  MOVLW  40
1078:  MOVWF  3E
....................     conversionpasos(); 
107A:  RCALL  0DAC
....................     xini = x; 
107C:  MOVFF  3D,45
1080:  MOVFF  3C,44
1084:  MOVFF  3B,43
1088:  MOVFF  3A,42
....................     yini = y; 
108C:  MOVFF  41,49
1090:  MOVFF  40,48
1094:  MOVFF  3F,47
1098:  MOVFF  3E,46
....................     // pasosx=+1500;     //pasos para ir a punto de prueba 
....................     //pasosy=+1000;     //pasos para ir a puto de prueba 
....................     contador = 2; 
109C:  MOVLW  02
109E:  MOVWF  39
....................     moverxy(); 
10A0:  BRA    1042
....................     putc('M'); 
10A2:  MOVLW  4D
10A4:  CALL   0166
.................... } 
10A8:  RETURN 0
....................  
.................... void profundidadmecha(void) { 
....................     lcd_putc("\fAjustando Z\n"); 
*
169E:  MOVLW  E6
16A0:  MOVWF  FF6
16A2:  MOVLW  00
16A4:  MOVWF  FF7
16A6:  CALL   0728
....................     lcd_putc("Profundidad de mecha"); 
16AA:  MOVLW  F4
16AC:  MOVWF  FF6
16AE:  MOVLW  00
16B0:  MOVWF  FF7
16B2:  CALL   0728
....................     output_low(habilz); 
16B6:  BCF    F92.1
16B8:  BCF    F89.1
....................     output_low(habilx); 
16BA:  BCF    F96.2
16BC:  BCF    F8D.2
....................     output_low(habily); 
16BE:  BCF    F92.0
16C0:  BCF    F89.0
....................     output_low(motorz); 
16C2:  BCF    F95.5
16C4:  BCF    F8C.5
....................     while (input(profunz) == 1) { 
16C6:  BSF    F94.1
16C8:  BTFSS  F82.1
16CA:  BRA    1736
....................         output_high(sentidoz); 
16CC:  BCF    F95.2
16CE:  BSF    F8C.2
....................         output_high(motorz); 
16D0:  BCF    F95.5
16D2:  BSF    F8C.5
....................         delay_us(1200); 
16D4:  CLRF   19
16D6:  BTFSC  FF2.7
16D8:  BSF    19.7
16DA:  BCF    FF2.7
16DC:  MOVLW  01
16DE:  MOVWF  x98
16E0:  CALL   0180
16E4:  BTFSC  19.7
16E6:  BSF    FF2.7
16E8:  CLRF   19
16EA:  BTFSC  FF2.7
16EC:  BSF    19.7
16EE:  BCF    FF2.7
16F0:  MOVLW  C8
16F2:  MOVWF  x98
16F4:  CALL   01A8
16F8:  BTFSC  19.7
16FA:  BSF    FF2.7
....................         output_low(motorz); 
16FC:  BCF    F95.5
16FE:  BCF    F8C.5
....................         delay_us(1200); 
1700:  CLRF   19
1702:  BTFSC  FF2.7
1704:  BSF    19.7
1706:  BCF    FF2.7
1708:  MOVLW  01
170A:  MOVWF  x98
170C:  CALL   0180
1710:  BTFSC  19.7
1712:  BSF    FF2.7
1714:  CLRF   19
1716:  BTFSC  FF2.7
1718:  BSF    19.7
171A:  BCF    FF2.7
171C:  MOVLW  C8
171E:  MOVWF  x98
1720:  CALL   01A8
1724:  BTFSC  19.7
1726:  BSF    FF2.7
....................         alturamecha = alturamecha + 1; 
1728:  MOVLW  01
172A:  ADDWF  x71,F
172C:  MOVLW  00
172E:  ADDWFC x72,F
1730:  ADDWFC x73,F
1732:  ADDWFC x74,F
....................     } 
1734:  BRA    16C6
....................     alturamecha = alturamecha - 200; //le resta el espesor de la base y le da un mm ms 
1736:  MOVLW  C8
1738:  SUBWF  x71,F
173A:  MOVLW  00
173C:  SUBWFB x72,F
173E:  SUBWFB x73,F
1740:  SUBWFB x74,F
....................     //40*0.2/2 
.................... } 
1742:  RETURN 0
....................  
.................... void ajusteceroz(void) { 
....................     output_low(habilz); 
*
0748:  BCF    F92.1
074A:  BCF    F89.1
....................     lcd_putc("Buscando cero Z"); 
074C:  MOVLW  0A
074E:  MOVWF  FF6
0750:  MOVLW  01
0752:  MOVWF  FF7
0754:  RCALL  0728
....................     while ((input(ceroz)) == 0) { 
0756:  BSF    F94.0
0758:  BTFSC  F82.0
075A:  BRA    078A
....................         output_low(sentidoz); 
075C:  BCF    F95.2
075E:  BCF    F8C.2
....................         output_toggle(motorz); 
0760:  BCF    F95.5
0762:  BTG    F8C.5
....................         delay_us(1200); 
0764:  CLRF   19
0766:  BTFSC  FF2.7
0768:  BSF    19.7
076A:  BCF    FF2.7
076C:  MOVLW  01
076E:  MOVWF  x98
0770:  RCALL  0180
0772:  BTFSC  19.7
0774:  BSF    FF2.7
0776:  CLRF   19
0778:  BTFSC  FF2.7
077A:  BSF    19.7
077C:  BCF    FF2.7
077E:  MOVLW  C8
0780:  MOVWF  x98
0782:  RCALL  01A8
0784:  BTFSC  19.7
0786:  BSF    FF2.7
....................     } 
0788:  BRA    0756
....................     lcd_putc(" OK\n"); 
078A:  MOVLW  1A
078C:  MOVWF  FF6
078E:  MOVLW  01
0790:  MOVWF  FF7
0792:  RCALL  0728
....................     zini = 0; 
0794:  CLRF   x6C
0796:  CLRF   x6B
0798:  CLRF   x6A
079A:  CLRF   x69
.................... } 
079C:  GOTO   07AC (RETURN)
....................  
.................... void ajustedecero(void) { 
....................     lcd_putc("\fBuscando origen\n"); 
07A0:  MOVLW  20
07A2:  MOVWF  FF6
07A4:  MOVLW  01
07A6:  MOVWF  FF7
07A8:  RCALL  0728
....................     //lcd_putc("Espere por favor"); 
....................     ajusteceroz(); 
07AA:  BRA    0748
....................     lcd_putc("Buscando cero X\n"); 
07AC:  MOVLW  32
07AE:  MOVWF  FF6
07B0:  MOVLW  01
07B2:  MOVWF  FF7
07B4:  RCALL  0728
....................     lcd_putc("Buscando cero Y\n"); 
07B6:  MOVLW  44
07B8:  MOVWF  FF6
07BA:  MOVLW  01
07BC:  MOVWF  FF7
07BE:  RCALL  0728
....................     output_low(habilx); 
07C0:  BCF    F96.2
07C2:  BCF    F8D.2
....................     output_low(habily); 
07C4:  BCF    F92.0
07C6:  BCF    F89.0
....................     while ((input(cerox) == 0) || (input(ceroy)) == 0) { 
07C8:  BSF    F95.6
07CA:  BTFSS  F83.6
07CC:  BRA    07D4
07CE:  BSF    F95.7
07D0:  BTFSC  F83.7
07D2:  BRA    084A
....................         if (input(cerox) == 0) { 
07D4:  BSF    F95.6
07D6:  BTFSC  F83.6
07D8:  BRA    07E2
....................             output_low(sentidox); 
07DA:  BCF    F95.0
07DC:  BCF    F8C.0
....................             output_toggle(motorx); 
07DE:  BCF    F95.3
07E0:  BTG    F8C.3
....................         } 
....................         if (input(cerox) == 1){ 
07E2:  BSF    F95.6
07E4:  BTFSS  F83.6
07E6:  BRA    07FC
....................             lcd_gotoxy(17,3); 
07E8:  MOVLW  11
07EA:  MOVWF  x83
07EC:  MOVLW  03
07EE:  MOVWF  x84
07F0:  RCALL  0690
....................             lcd_putc("OK"); 
07F2:  MOVLW  56
07F4:  MOVWF  FF6
07F6:  MOVLW  01
07F8:  MOVWF  FF7
07FA:  RCALL  0728
....................         } 
....................         if (input(ceroy) == 0) { 
07FC:  BSF    F95.7
07FE:  BTFSC  F83.7
0800:  BRA    080A
....................             output_high(sentidoy); 
0802:  BCF    F95.1
0804:  BSF    F8C.1
....................             output_toggle(motory); 
0806:  BCF    F95.4
0808:  BTG    F8C.4
....................         } 
....................         if (input(ceroy) == 1) { 
080A:  BSF    F95.7
080C:  BTFSS  F83.7
080E:  BRA    0824
....................             lcd_gotoxy(17,4); 
0810:  MOVLW  11
0812:  MOVWF  x83
0814:  MOVLW  04
0816:  MOVWF  x84
0818:  RCALL  0690
....................             lcd_putc("OK"); 
081A:  MOVLW  5A
081C:  MOVWF  FF6
081E:  MOVLW  01
0820:  MOVWF  FF7
0822:  RCALL  0728
....................         } 
....................         delay_us(1200); 
0824:  CLRF   19
0826:  BTFSC  FF2.7
0828:  BSF    19.7
082A:  BCF    FF2.7
082C:  MOVLW  01
082E:  MOVWF  x98
0830:  RCALL  0180
0832:  BTFSC  19.7
0834:  BSF    FF2.7
0836:  CLRF   19
0838:  BTFSC  FF2.7
083A:  BSF    19.7
083C:  BCF    FF2.7
083E:  MOVLW  C8
0840:  MOVWF  x98
0842:  RCALL  01A8
0844:  BTFSC  19.7
0846:  BSF    FF2.7
....................     } 
0848:  BRA    07C8
....................     lcd_gotoxy(17,3); 
084A:  MOVLW  11
084C:  MOVWF  x83
084E:  MOVLW  03
0850:  MOVWF  x84
0852:  RCALL  0690
....................     lcd_putc("OK"); 
0854:  MOVLW  5E
0856:  MOVWF  FF6
0858:  MOVLW  01
085A:  MOVWF  FF7
085C:  RCALL  0728
....................     lcd_gotoxy(17,4); 
085E:  MOVLW  11
0860:  MOVWF  x83
0862:  MOVLW  04
0864:  MOVWF  x84
0866:  RCALL  0690
....................     lcd_putc("OK"); 
0868:  MOVLW  62
086A:  MOVWF  FF6
086C:  MOVLW  01
086E:  MOVWF  FF7
0870:  RCALL  0728
....................     output_low(motorx); 
0872:  BCF    F95.3
0874:  BCF    F8C.3
....................     output_low(motory); 
0876:  BCF    F95.4
0878:  BCF    F8C.4
....................     output_low(motorz); 
087A:  BCF    F95.5
087C:  BCF    F8C.5
....................     xini = 0; 
087E:  CLRF   45
0880:  CLRF   44
0882:  CLRF   43
0884:  CLRF   42
....................     yini = 0; 
0886:  CLRF   49
0888:  CLRF   48
088A:  CLRF   47
088C:  CLRF   46
.................... } 
088E:  RETURN 0
....................  
.................... void mecha(void) { 
....................     while (flagmecha == 0); 
*
140A:  MOVF   x62,F
140C:  BZ    140A
....................     while (flagmecha == 1); 
140E:  DECFSZ x62,W
1410:  BRA    1414
1412:  BRA    140E
....................     broca = atof(mech); 
1414:  CLRF   x76
1416:  MOVLW  22
1418:  MOVWF  x75
141A:  CLRF   x78
141C:  CLRF   x77
141E:  RCALL  11D2
1420:  MOVFF  03,55
1424:  MOVFF  02,54
1428:  MOVFF  01,53
142C:  MOVFF  00,52
.................... } 
1430:  RETURN 0
....................  
....................  
.................... #INT_EXT2         //Atencin a interrupcin por cambio en RB2 
....................  
.................... ext_isr1() { //Funcin de interrupcin 
....................     putc('F'); 
*
016E:  MOVLW  46
0170:  RCALL  0166
....................     flagajuste = 0; 
0172:  BCF    x64.1
....................     salir = 1; 
0174:  MOVLW  01
0176:  MOVWF  38
....................     disable_interrupts(int_ext2_L2H); 
0178:  BCF    FF0.4
.................... } 
....................  
017A:  BCF    FF0.1
017C:  GOTO   0084
.................... #INT_EXT         //Atencin a interrupcin por cambio en RB0 
....................  
.................... void INTEXT_isr(void) { //Funcin de interrupcin 
....................     output_low(motorz); 
*
01C8:  BCF    F95.5
01CA:  BCF    F8C.5
....................     if (input(canalb) == 0) { 
01CC:  BSF    F92.2
01CE:  BTFSC  F80.2
01D0:  BRA    0206
....................         output_low(habilz); 
01D2:  BCF    F92.1
01D4:  BCF    F89.1
....................         output_low(sentidoz); //mecha para abajo 
01D6:  BCF    F95.2
01D8:  BCF    F8C.2
....................         z = z - 2; 
01DA:  MOVLW  02
01DC:  SUBWF  x6D,F
01DE:  MOVLW  00
01E0:  SUBWFB x6E,F
01E2:  SUBWFB x6F,F
01E4:  SUBWFB x70,F
....................         output_high(motorz); 
01E6:  BCF    F95.5
01E8:  BSF    F8C.5
....................         delay_us(1200); 
01EA:  MOVLW  01
01EC:  MOVWF  x98
01EE:  RCALL  0180
01F0:  MOVLW  C8
01F2:  MOVWF  x98
01F4:  RCALL  01A8
....................         output_low(motorz); 
01F6:  BCF    F95.5
01F8:  BCF    F8C.5
....................         delay_us(1200); 
01FA:  MOVLW  01
01FC:  MOVWF  x98
01FE:  RCALL  0180
0200:  MOVLW  C8
0202:  MOVWF  x98
0204:  RCALL  01A8
....................     } 
....................     if (input(canalb) == 1) { 
0206:  BSF    F92.2
0208:  BTFSS  F80.2
020A:  BRA    0240
....................         output_low(habilz); 
020C:  BCF    F92.1
020E:  BCF    F89.1
....................         output_high(sentidoz); //mecha para arriba 
0210:  BCF    F95.2
0212:  BSF    F8C.2
....................         z = z + 2; 
0214:  MOVLW  02
0216:  ADDWF  x6D,F
0218:  MOVLW  00
021A:  ADDWFC x6E,F
021C:  ADDWFC x6F,F
021E:  ADDWFC x70,F
....................         output_high(motorz); 
0220:  BCF    F95.5
0222:  BSF    F8C.5
....................         delay_us(1200); 
0224:  MOVLW  01
0226:  MOVWF  x98
0228:  RCALL  0180
022A:  MOVLW  C8
022C:  MOVWF  x98
022E:  RCALL  01A8
....................         output_low(motorz); 
0230:  BCF    F95.5
0232:  BCF    F8C.5
....................         delay_us(1200); 
0234:  MOVLW  01
0236:  MOVWF  x98
0238:  RCALL  0180
023A:  MOVLW  C8
023C:  MOVWF  x98
023E:  RCALL  01A8
....................     } 
.................... } 
0240:  BCF    FF2.1
0242:  GOTO   0084
.................... #int_TIMER0 
....................  
.................... void TIMER0_isr(void) { 
....................     contador = contador - 1; 
0246:  MOVLW  01
0248:  SUBWF  39,F
....................  
....................     if (contador == 0) { 
024A:  MOVF   39,F
024C:  BTFSS  FD8.2
024E:  BRA    030A
....................         contador = 2; 
0250:  MOVLW  02
0252:  MOVWF  39
....................         if (pasosx == 0) { 
0254:  MOVF   4A,F
0256:  BNZ   0266
0258:  MOVF   4B,F
025A:  BNZ   0266
025C:  MOVF   4C,F
025E:  BNZ   0266
0260:  MOVF   4D,F
0262:  BNZ   0266
....................             flagx = 0; 
0264:  CLRF   5E
....................         } 
....................         if (pasosx > 0) { 
0266:  BTFSC  4D.7
0268:  BRA    0290
026A:  MOVF   4D,F
026C:  BNZ   027C
026E:  MOVF   4C,F
0270:  BNZ   027C
0272:  MOVF   4B,F
0274:  BNZ   027C
0276:  MOVF   4A,W
0278:  SUBLW  00
027A:  BC    0290
....................             output_high(sentidox); 
027C:  BCF    F95.0
027E:  BSF    F8C.0
....................             output_toggle(motorx); 
0280:  BCF    F95.3
0282:  BTG    F8C.3
....................             pasosx = pasosx - 1; 
0284:  MOVLW  01
0286:  SUBWF  4A,F
0288:  MOVLW  00
028A:  SUBWFB 4B,F
028C:  SUBWFB 4C,F
028E:  SUBWFB 4D,F
....................         } 
....................         if (pasosx < 0) { 
0290:  BTFSS  4D.7
0292:  BRA    02A8
....................             output_low(sentidox); 
0294:  BCF    F95.0
0296:  BCF    F8C.0
....................             output_toggle(motorx); 
0298:  BCF    F95.3
029A:  BTG    F8C.3
....................             pasosx = pasosx + 1; 
029C:  MOVLW  01
029E:  ADDWF  4A,F
02A0:  MOVLW  00
02A2:  ADDWFC 4B,F
02A4:  ADDWFC 4C,F
02A6:  ADDWFC 4D,F
....................         } 
....................  
....................         if (pasosy == 0) { 
02A8:  MOVF   4E,F
02AA:  BNZ   02BA
02AC:  MOVF   4F,F
02AE:  BNZ   02BA
02B0:  MOVF   50,F
02B2:  BNZ   02BA
02B4:  MOVF   51,F
02B6:  BNZ   02BA
....................             flagy = 0; 
02B8:  CLRF   5F
....................         } 
....................         if (pasosy > 0) { 
02BA:  BTFSC  51.7
02BC:  BRA    02E4
02BE:  MOVF   51,F
02C0:  BNZ   02D0
02C2:  MOVF   50,F
02C4:  BNZ   02D0
02C6:  MOVF   4F,F
02C8:  BNZ   02D0
02CA:  MOVF   4E,W
02CC:  SUBLW  00
02CE:  BC    02E4
....................             output_low(sentidoy); 
02D0:  BCF    F95.1
02D2:  BCF    F8C.1
....................             output_toggle(motory); 
02D4:  BCF    F95.4
02D6:  BTG    F8C.4
....................             pasosy = pasosy - 1; 
02D8:  MOVLW  01
02DA:  SUBWF  4E,F
02DC:  MOVLW  00
02DE:  SUBWFB 4F,F
02E0:  SUBWFB 50,F
02E2:  SUBWFB 51,F
....................         } 
....................         if (pasosy < 0) { 
02E4:  BTFSC  51.7
02E6:  BRA    02EA
02E8:  BRA    02FE
....................             output_high(sentidoy); 
02EA:  BCF    F95.1
02EC:  BSF    F8C.1
....................             output_toggle(motory); 
02EE:  BCF    F95.4
02F0:  BTG    F8C.4
....................             pasosy = pasosy + 1; 
02F2:  MOVLW  01
02F4:  ADDWF  4E,F
02F6:  MOVLW  00
02F8:  ADDWFC 4F,F
02FA:  ADDWFC 50,F
02FC:  ADDWFC 51,F
....................         } 
....................  
....................         if (flagx == 0 && flagy == 0) { 
02FE:  MOVF   5E,F
0300:  BNZ   030A
0302:  MOVF   5F,F
0304:  BNZ   030A
....................             flagxy = 0; 
0306:  CLRF   x60
....................             disable_interrupts(INT_TIMER0); //deshabilita interrupcin timer0 
0308:  BCF    FF2.5
....................         } 
....................     } 
....................     set_timer0(230); //Se recarga el timer0 
030A:  CLRF   FD7
030C:  MOVLW  E6
030E:  MOVWF  FD6
.................... } 
....................  
0310:  BCF    FF2.2
0312:  GOTO   0084
.................... #int_rda 
....................  
.................... void serial_isr() { 
....................     ch = getchar(); 
0316:  BTFSS  F9E.5
0318:  BRA    0316
031A:  MOVFF  FAE,21
....................     if (ch == 'F' && flagpaquete == 1) { 
031E:  MOVF   21,W
0320:  SUBLW  46
0322:  BNZ   033A
0324:  BTFSS  x64.0
0326:  BRA    033A
....................         flagpaquete = flagpaquete + 1; 
0328:  MOVLW  00
032A:  BTFSC  x64.0
032C:  MOVLW  01
032E:  ADDLW  01
0330:  BCF    x64.0
0332:  BTFSC  FE8.0
0334:  BSF    x64.0
....................         flagfin = 1; 
0336:  MOVLW  01
0338:  MOVWF  37
....................     } 
....................     if (ch == 'A') { 
033A:  MOVF   21,W
033C:  SUBLW  41
033E:  BNZ   034E
....................         flagajuste = flagajuste + 1; 
0340:  MOVLW  00
0342:  BTFSC  x64.1
0344:  MOVLW  01
0346:  ADDLW  01
0348:  BCF    x64.1
034A:  BTFSC  FE8.0
034C:  BSF    x64.1
....................     } 
....................     if (ch == 'P') { 
034E:  MOVF   21,W
0350:  SUBLW  50
0352:  BNZ   0362
....................         flagpaquete = flagpaquete + 1; 
0354:  MOVLW  00
0356:  BTFSC  x64.0
0358:  MOVLW  01
035A:  ADDLW  01
035C:  BCF    x64.0
035E:  BTFSC  FE8.0
0360:  BSF    x64.0
....................     } 
....................     if (ch == '*') { 
0362:  MOVF   21,W
0364:  SUBLW  2A
0366:  BNZ   036C
....................         flagcomienzo = 1; 
0368:  MOVLW  01
036A:  MOVWF  x61
....................     } 
....................     if (ch == 'M') { 
036C:  MOVF   21,W
036E:  SUBLW  4D
0370:  BNZ   0378
....................         flagmecha = 1; 
0372:  MOVLW  01
0374:  MOVWF  x62
....................         h = 0; 
0376:  CLRF   36
....................     } 
....................     if ((flagmecha) == 1 && (ch != 'M')) { 
0378:  DECFSZ x62,W
037A:  BRA    03A0
037C:  MOVF   21,W
037E:  SUBLW  4D
0380:  BZ    03A0
....................  
....................         mech[h] = ch; 
0382:  CLRF   03
0384:  MOVF   36,W
0386:  ADDLW  22
0388:  MOVWF  FE9
038A:  MOVLW  00
038C:  ADDWFC 03,W
038E:  MOVWF  FEA
0390:  MOVFF  21,FEF
....................         h = h + 1; 
0394:  MOVLW  01
0396:  ADDWF  36,F
....................         if (h == 6) { 
0398:  MOVF   36,W
039A:  SUBLW  06
039C:  BNZ   03A0
....................             flagmecha = 0; 
039E:  CLRF   x62
....................         } 
....................     } 
....................     if (ch == 'X') { 
03A0:  MOVF   21,W
03A2:  SUBLW  58
03A4:  BNZ   03AC
....................         flagx = 1; 
03A6:  MOVLW  01
03A8:  MOVWF  5E
....................         i = 0; 
03AA:  CLRF   34
....................     } 
....................     if (ch == 'Y') { 
03AC:  MOVF   21,W
03AE:  SUBLW  59
03B0:  BNZ   03B8
....................         flagy = 1; 
03B2:  MOVLW  01
03B4:  MOVWF  5F
....................         j = 0; 
03B6:  CLRF   35
....................     } 
....................     if ((flagx) == 1 && (ch != 'X')) { 
03B8:  DECFSZ 5E,W
03BA:  BRA    03E4
03BC:  MOVF   21,W
03BE:  SUBLW  58
03C0:  BZ    03E4
....................  
....................         datox[i] = ch; 
03C2:  CLRF   03
03C4:  MOVF   34,W
03C6:  ADDLW  26
03C8:  MOVWF  FE9
03CA:  MOVLW  00
03CC:  ADDWFC 03,W
03CE:  MOVWF  FEA
03D0:  MOVFF  21,FEF
....................         i = i + 1; 
03D4:  MOVLW  01
03D6:  ADDWF  34,F
....................         if (i == 7) { 
03D8:  MOVF   34,W
03DA:  SUBLW  07
03DC:  BNZ   03E4
....................             flagx = 0; 
03DE:  CLRF   5E
....................             putc('*'); 
03E0:  MOVLW  2A
03E2:  RCALL  0166
....................         } 
....................     } 
....................     if ((flagy) == 1 && (ch != 'Y')) { 
03E4:  DECFSZ 5F,W
03E6:  BRA    0414
03E8:  MOVF   21,W
03EA:  SUBLW  59
03EC:  BZ    0414
....................  
....................         datoy[j] = ch; 
03EE:  CLRF   03
03F0:  MOVF   35,W
03F2:  ADDLW  2D
03F4:  MOVWF  FE9
03F6:  MOVLW  00
03F8:  ADDWFC 03,W
03FA:  MOVWF  FEA
03FC:  MOVFF  21,FEF
....................         j = j + 1; 
0400:  MOVLW  01
0402:  ADDWF  35,F
....................         if (j == 7) { 
0404:  MOVF   35,W
0406:  SUBLW  07
0408:  BNZ   0414
....................             flagy = 0; 
040A:  CLRF   5F
....................             flagxy = 1; 
040C:  MOVLW  01
040E:  MOVWF  x60
....................             putc('*'); 
0410:  MOVLW  2A
0412:  RCALL  0166
....................         } 
....................     } 
.................... } 
.................... //printf(lcd_putc, "\fCaracter %c",ch); 
.................... // puts("RECIBIDO"); 
....................  
0414:  BCF    F9E.5
0416:  GOTO   0084
.................... void main() { 
*
196C:  CLRF   FF8
196E:  BCF    FD0.7
1970:  BSF    07.7
1972:  CLRF   FEA
1974:  CLRF   FE9
1976:  BSF    FB8.3
1978:  MOVLW  E1
197A:  MOVWF  FAF
197C:  MOVLW  04
197E:  MOVWF  FB0
1980:  MOVLW  A6
1982:  MOVWF  FAC
1984:  MOVLW  90
1986:  MOVWF  FAB
1988:  MOVF   FC1,W
198A:  ANDLW  C0
198C:  IORLW  0F
198E:  MOVWF  FC1
1990:  MOVLW  07
1992:  MOVWF  FB4
1994:  CLRF   1A
1996:  CLRF   1B
....................     output_high(habilx); //motor desenergizado 
1998:  BCF    F96.2
199A:  BSF    F8D.2
....................     output_high(habily); 
199C:  BCF    F92.0
199E:  BSF    F89.0
....................     output_high(habilz); 
19A0:  BCF    F92.1
19A2:  BSF    F89.1
19A4:  CLRF   19
19A6:  BTFSC  FF2.7
19A8:  BSF    19.7
19AA:  BCF    FF2.7
....................     delay_ms(100); 
19AC:  MOVLW  64
19AE:  MOVWF  x98
19B0:  CALL   0180
19B4:  BTFSC  19.7
19B6:  BSF    FF2.7
....................     enable_interrupts(int_rda); 
19B8:  BSF    F9D.5
....................     setup_timer_0(RTCC_8_BIT | RTCC_DIV_256); //Configuracin timer0 
19BA:  MOVLW  C7
19BC:  MOVWF  FD5
....................  
....................     enable_interrupts(int_ext2_L2H); //Habilita int. RB2? 
19BE:  BSF    FF0.4
19C0:  BSF    FF1.4
....................     //ext_int_edge(L_TO_H);              //por flanco de subida 
....................     enable_interrupts(global); //Habilita interrupcin general 
19C2:  MOVLW  C0
19C4:  IORWF  FF2,F
....................     lcd_init(); 
19C6:  GOTO   0618
....................  
....................     while (1) { 
....................         flagfin = 0; 
19CA:  CLRF   37
....................         flagmecha = 0; 
19CC:  CLRF   x62
....................         flagcomienzo = 0; 
19CE:  CLRF   x61
....................         xini = 0; 
19D0:  CLRF   45
19D2:  CLRF   44
19D4:  CLRF   43
19D6:  CLRF   42
....................         yini = 0; 
19D8:  CLRF   49
19DA:  CLRF   48
19DC:  CLRF   47
19DE:  CLRF   46
....................         zini = 0; 
19E0:  CLRF   x6C
19E2:  CLRF   x6B
19E4:  CLRF   x6A
19E6:  CLRF   x69
....................         flagajuste = 0; 
19E8:  BCF    x64.1
....................         flagpaquete = 0; 
19EA:  BCF    x64.0
....................         pasosx = 0; 
19EC:  CLRF   4D
19EE:  CLRF   4C
19F0:  CLRF   4B
19F2:  CLRF   4A
....................         pasosz = 0; 
19F4:  CLRF   x68
19F6:  CLRF   x67
19F8:  CLRF   x66
19FA:  CLRF   x65
....................         pasosy = 0; 
19FC:  CLRF   51
19FE:  CLRF   50
1A00:  CLRF   4F
1A02:  CLRF   4E
....................         alturamecha = 0; 
1A04:  CLRF   x74
1A06:  CLRF   x73
1A08:  CLRF   x72
1A0A:  CLRF   x71
....................         x = 0; 
1A0C:  CLRF   3D
1A0E:  CLRF   3C
1A10:  CLRF   3B
1A12:  CLRF   3A
....................         y = 0; 
1A14:  CLRF   41
1A16:  CLRF   40
1A18:  CLRF   3F
1A1A:  CLRF   3E
....................         z = 0; 
1A1C:  CLRF   x70
1A1E:  CLRF   x6F
1A20:  CLRF   x6E
1A22:  CLRF   x6D
....................         flagboton = 0; 
1A24:  CLRF   x63
....................         flagxy = 0; 
1A26:  CLRF   x60
....................         flagx = 0; 
1A28:  CLRF   5E
....................         flagy = 0; 
1A2A:  CLRF   5F
....................         broca = 0; 
1A2C:  CLRF   55
1A2E:  CLRF   54
1A30:  CLRF   53
1A32:  CLRF   52
....................         pasosxflot = 0; 
1A34:  CLRF   59
1A36:  CLRF   58
1A38:  CLRF   57
1A3A:  CLRF   56
....................         pasosyflot = 0; 
1A3C:  CLRF   5D
1A3E:  CLRF   5C
1A40:  CLRF   5B
1A42:  CLRF   5A
....................         salir = 0; 
1A44:  CLRF   38
....................         i = 0; 
1A46:  CLRF   34
....................         j = 0; 
1A48:  CLRF   35
....................         h = 0; 
1A4A:  CLRF   36
....................         lcd_putc("\fHAGA CLICK EN\n"); 
1A4C:  MOVLW  1A
1A4E:  MOVWF  FF6
1A50:  MOVLW  04
1A52:  MOVWF  FF7
1A54:  CALL   0728
....................         lcd_putc("EN CALIBRAR EN EL\n"); 
1A58:  MOVLW  2A
1A5A:  MOVWF  FF6
1A5C:  MOVLW  04
1A5E:  MOVWF  FF7
1A60:  CALL   0728
....................         lcd_putc("PROGRAMA Y ESPERE \n"); 
1A64:  MOVLW  3E
1A66:  MOVWF  FF6
1A68:  MOVLW  04
1A6A:  MOVWF  FF7
1A6C:  CALL   0728
....................         lcd_putc("UN MOMENTO."); 
1A70:  MOVLW  52
1A72:  MOVWF  FF6
1A74:  MOVLW  04
1A76:  MOVWF  FF7
1A78:  CALL   0728
....................         while (flagcomienzo == 0); 
1A7C:  MOVF   x61,F
1A7E:  BZ    1A7C
....................         flagcomienzo = 0; 
1A80:  CLRF   x61
....................         ajustedecero(); 
1A82:  CALL   07A0
....................         posicionmecha(); 
1A86:  CALL   105E
....................         mecha(); 
1A8A:  RCALL  140A
....................         printf(lcd_putc"\fColocar mecha %01.3fmm", broca); 
1A8C:  MOVLW  5E
1A8E:  MOVWF  FF6
1A90:  MOVLW  04
1A92:  MOVWF  FF7
1A94:  MOVLW  0F
1A96:  MOVWF  x75
1A98:  RCALL  1432
1A9A:  MOVLW  C9
1A9C:  MOVWF  FE9
1A9E:  MOVFF  55,78
1AA2:  MOVFF  54,77
1AA6:  MOVFF  53,76
1AAA:  MOVFF  52,75
1AAE:  MOVLW  03
1AB0:  MOVWF  x79
1AB2:  RCALL  151E
1AB4:  MOVLW  6D
1AB6:  MOVWF  x82
1AB8:  CALL   06D2
1ABC:  MOVLW  6D
1ABE:  MOVWF  x82
1AC0:  CALL   06D2
....................         lcd_putc("\nPresione enter para\n"); 
1AC4:  MOVLW  76
1AC6:  MOVWF  FF6
1AC8:  MOVLW  04
1ACA:  MOVWF  FF7
1ACC:  CALL   0728
....................         lcd_putc("comenzar el ajuste\n"); 
1AD0:  MOVLW  8C
1AD2:  MOVWF  FF6
1AD4:  MOVLW  04
1AD6:  MOVWF  FF7
1AD8:  CALL   0728
....................         lcd_putc("de la placa.");  
1ADC:  MOVLW  A0
1ADE:  MOVWF  FF6
1AE0:  MOVLW  04
1AE2:  MOVWF  FF7
1AE4:  CALL   0728
....................         while (input(enter) == 0) { 
1AE8:  BSF    F96.1
1AEA:  BTFSC  F84.1
1AEC:  BRA    1AF0
....................         } 
1AEE:  BRA    1AE8
1AF0:  CLRF   19
1AF2:  BTFSC  FF2.7
1AF4:  BSF    19.7
1AF6:  BCF    FF2.7
....................         delay_ms(10); 
1AF8:  MOVLW  0A
1AFA:  MOVWF  x98
1AFC:  CALL   0180
1B00:  BTFSC  19.7
1B02:  BSF    FF2.7
....................         while (input(enter) == 1) { 
1B04:  BSF    F96.1
1B06:  BTFSS  F84.1
1B08:  BRA    1B0C
....................         } 
1B0A:  BRA    1B04
....................         profundidadmecha(); 
1B0C:  RCALL  169E
....................         //ajustedecero(); 
....................         z = alturamecha; //******OK****** 
1B0E:  MOVFF  74,70
1B12:  MOVFF  73,6F
1B16:  MOVFF  72,6E
1B1A:  MOVFF  71,6D
....................         moverz(); 
1B1E:  RCALL  1744
....................         putc('A'); 
1B20:  MOVLW  41
1B22:  CALL   0166
....................         while (flagajuste == 0 && salir == 0); 
1B26:  BTFSC  x64.1
1B28:  BRA    1B2E
1B2A:  MOVF   38,F
1B2C:  BZ    1B26
....................  
....................         while (flagajuste == 1) { 
1B2E:  BTFSS  x64.1
1B30:  BRA    1C6A
....................             while (flagxy == 0); 
1B32:  MOVF   x60,F
1B34:  BZ    1B32
....................             while (flagxy == 1) { 
1B36:  DECFSZ x60,W
1B38:  BRA    1C68
....................                 x = (signed long long int) atof(datox); 
1B3A:  CLRF   x76
1B3C:  MOVLW  26
1B3E:  MOVWF  x75
1B40:  CLRF   x78
1B42:  CLRF   x77
1B44:  CALL   11D2
1B48:  MOVFF  03,85
1B4C:  MOVFF  02,84
1B50:  MOVFF  01,83
1B54:  MOVFF  00,82
1B58:  RCALL  1452
1B5A:  MOVFF  03,3D
1B5E:  MOVFF  02,3C
1B62:  MOVFF  01,3B
1B66:  MOVFF  00,3A
....................                 y = (signed long long int) atof(datoy); 
1B6A:  CLRF   x76
1B6C:  MOVLW  2D
1B6E:  MOVWF  x75
1B70:  CLRF   x78
1B72:  CLRF   x77
1B74:  CALL   11D2
1B78:  MOVFF  03,85
1B7C:  MOVFF  02,84
1B80:  MOVFF  01,83
1B84:  MOVFF  00,82
1B88:  RCALL  1452
1B8A:  MOVFF  03,41
1B8E:  MOVFF  02,40
1B92:  MOVFF  01,3F
1B96:  MOVFF  00,3E
....................                 conversionpasos(); 
1B9A:  CALL   0DAC
....................                 xini = x; 
1B9E:  MOVFF  3D,45
1BA2:  MOVFF  3C,44
1BA6:  MOVFF  3B,43
1BAA:  MOVFF  3A,42
....................                 yini = y; 
1BAE:  MOVFF  41,49
1BB2:  MOVFF  40,48
1BB6:  MOVFF  3F,47
1BBA:  MOVFF  3E,46
....................                 clear_interrupt(int_timer0); 
1BBE:  BCF    FF2.2
....................                 set_timer0(230); 
1BC0:  CLRF   FD7
1BC2:  MOVLW  E6
1BC4:  MOVWF  FD6
....................                 enable_interrupts(INT_TIMER0); //Habilita interrupcin timer0 
1BC6:  BSF    FF2.5
....................                 flagx = 1; 
1BC8:  MOVLW  01
1BCA:  MOVWF  5E
....................                 flagy = 1; 
1BCC:  MOVWF  5F
....................                 while (flagxy == 1); 
1BCE:  DECFSZ x60,W
1BD0:  BRA    1BD4
1BD2:  BRA    1BCE
....................                 //bajarz(); 
....................                 //moverz(); 
....................                 lcd_putc("\fGire para subir o\n"); 
1BD4:  MOVLW  AE
1BD6:  MOVWF  FF6
1BD8:  MOVLW  04
1BDA:  MOVWF  FF7
1BDC:  CALL   0728
....................                 lcd_putc("bajar mecha.Presione\n"); 
1BE0:  MOVLW  C2
1BE2:  MOVWF  FF6
1BE4:  MOVLW  04
1BE6:  MOVWF  FF7
1BE8:  CALL   0728
....................                 lcd_putc("\enter nuevo punto.\n"); 
1BEC:  MOVLW  D8
1BEE:  MOVWF  FF6
1BF0:  MOVLW  04
1BF2:  MOVWF  FF7
1BF4:  CALL   0728
....................                 lcd_putc("Boton rojo salir.\n"); 
1BF8:  MOVLW  EC
1BFA:  MOVWF  FF6
1BFC:  MOVLW  04
1BFE:  MOVWF  FF7
1C00:  CALL   0728
....................                 enable_interrupts(int_ext_L2H); 
1C04:  BSF    FF2.4
1C06:  BSF    FF1.6
....................                 while (input(enter) == 0 && salir == 0) { 
1C08:  BSF    F96.1
1C0A:  BTFSC  F84.1
1C0C:  BRA    1C14
1C0E:  MOVF   38,F
1C10:  BNZ   1C14
....................                 } 
1C12:  BRA    1C08
1C14:  CLRF   19
1C16:  BTFSC  FF2.7
1C18:  BSF    19.7
1C1A:  BCF    FF2.7
....................                 delay_ms(10); 
1C1C:  MOVLW  0A
1C1E:  MOVWF  x98
1C20:  CALL   0180
1C24:  BTFSC  19.7
1C26:  BSF    FF2.7
....................                 while (input(enter) == 1 && salir == 0) { 
1C28:  BSF    F96.1
1C2A:  BTFSS  F84.1
1C2C:  BRA    1C34
1C2E:  MOVF   38,F
1C30:  BNZ   1C34
....................                 } 
1C32:  BRA    1C28
....................                 if (input(enter) == 0 && salir == 0) { 
1C34:  BSF    F96.1
1C36:  BTFSC  F84.1
1C38:  BRA    1C66
1C3A:  MOVF   38,F
1C3C:  BNZ   1C66
....................                     zini = z; 
1C3E:  MOVFF  70,6C
1C42:  MOVFF  6F,6B
1C46:  MOVFF  6E,6A
1C4A:  MOVFF  6D,69
....................                     z = alturamecha; 
1C4E:  MOVFF  74,70
1C52:  MOVFF  73,6F
1C56:  MOVFF  72,6E
1C5A:  MOVFF  71,6D
....................                     moverz(); 
1C5E:  RCALL  1744
....................                     putc('A'); 
1C60:  MOVLW  41
1C62:  CALL   0166
....................                 } 
....................             } 
1C66:  BRA    1B36
....................         } 
1C68:  BRA    1B2E
....................         disable_interrupts(int_ext_L2H); 
1C6A:  BCF    FF2.4
....................         //salir=0; 
....................         while (flagfin == 0) { 
1C6C:  MOVF   37,F
1C6E:  BTFSS  FD8.2
1C70:  BRA    1D72
....................             ajustedecero(); 
1C72:  CALL   07A0
....................             if (salir == 0) { 
1C76:  MOVF   38,F
1C78:  BNZ   1D18
....................                 posicionmecha(); 
1C7A:  CALL   105E
....................                 mecha(); 
1C7E:  CALL   140A
....................                 lcd_putc("\fPor favor coloque\n"); 
1C82:  MOVLW  00
1C84:  MOVWF  FF6
1C86:  MOVLW  05
1C88:  MOVWF  FF7
1C8A:  CALL   0728
....................                 printf(lcd_putc"mecha de %01.2fmm y", broca); 
1C8E:  MOVLW  14
1C90:  MOVWF  FF6
1C92:  MOVLW  05
1C94:  MOVWF  FF7
1C96:  MOVLW  09
1C98:  MOVWF  x75
1C9A:  CALL   1432
1C9E:  MOVLW  C9
1CA0:  MOVWF  FE9
1CA2:  MOVFF  55,78
1CA6:  MOVFF  54,77
1CAA:  MOVFF  53,76
1CAE:  MOVFF  52,75
1CB2:  MOVLW  02
1CB4:  MOVWF  x79
1CB6:  RCALL  151E
1CB8:  MOVLW  23
1CBA:  MOVWF  FF6
1CBC:  MOVLW  05
1CBE:  MOVWF  FF7
1CC0:  MOVLW  04
1CC2:  MOVWF  x75
1CC4:  CALL   1432
....................                 lcd_putc("\npresione enter"); 
1CC8:  MOVLW  28
1CCA:  MOVWF  FF6
1CCC:  MOVLW  05
1CCE:  MOVWF  FF7
1CD0:  CALL   0728
....................  
....................  
....................                 while (input(enter) == 0) { 
1CD4:  BSF    F96.1
1CD6:  BTFSC  F84.1
1CD8:  BRA    1CDC
....................                 } 
1CDA:  BRA    1CD4
1CDC:  CLRF   19
1CDE:  BTFSC  FF2.7
1CE0:  BSF    19.7
1CE2:  BCF    FF2.7
....................                 delay_ms(10); 
1CE4:  MOVLW  0A
1CE6:  MOVWF  x98
1CE8:  CALL   0180
1CEC:  BTFSC  19.7
1CEE:  BSF    FF2.7
....................                 while (input(enter) == 1) { 
1CF0:  BSF    F96.1
1CF2:  BTFSS  F84.1
1CF4:  BRA    1CF8
....................                 } 
1CF6:  BRA    1CF0
....................                 profundidadmecha(); 
1CF8:  RCALL  169E
....................                 ajustedecero(); 
1CFA:  CALL   07A0
....................                 puts("OK"); 
1CFE:  MOVLW  38
1D00:  MOVWF  FF6
1D02:  MOVLW  05
1D04:  MOVWF  FF7
1D06:  RCALL  1862
1D08:  MOVLW  0D
1D0A:  BTFSS  F9E.4
1D0C:  BRA    1D0A
1D0E:  MOVWF  FAD
1D10:  MOVLW  0A
1D12:  BTFSS  F9E.4
1D14:  BRA    1D12
1D16:  MOVWF  FAD
....................             } 
....................             contador = 2; 
1D18:  MOVLW  02
1D1A:  MOVWF  39
....................             lcd_putc("\fPerforadora Lista\n"); 
1D1C:  MOVLW  3C
1D1E:  MOVWF  FF6
1D20:  MOVLW  05
1D22:  MOVWF  FF7
1D24:  CALL   0728
....................             lcd_putc("para operar pulse *\n"); 
1D28:  MOVLW  50
1D2A:  MOVWF  FF6
1D2C:  MOVLW  05
1D2E:  MOVWF  FF7
1D30:  CALL   0728
....................             lcd_putc("para comenzar"); 
1D34:  MOVLW  66
1D36:  MOVWF  FF6
1D38:  MOVLW  05
1D3A:  MOVWF  FF7
1D3C:  CALL   0728
....................  
....................             puts("OK"); 
1D40:  MOVLW  74
1D42:  MOVWF  FF6
1D44:  MOVLW  05
1D46:  MOVWF  FF7
1D48:  RCALL  1862
1D4A:  MOVLW  0D
1D4C:  BTFSS  F9E.4
1D4E:  BRA    1D4C
1D50:  MOVWF  FAD
1D52:  MOVLW  0A
1D54:  BTFSS  F9E.4
1D56:  BRA    1D54
1D58:  MOVWF  FAD
....................             while (flagcomienzo == 0); 
1D5A:  MOVF   x61,F
1D5C:  BZ    1D5A
....................             lcd_putc("\fPERFORANDO\n"); 
1D5E:  MOVLW  78
1D60:  MOVWF  FF6
1D62:  MOVLW  05
1D64:  MOVWF  FF7
1D66:  CALL   0728
....................             flagcomienzo = 0; 
1D6A:  CLRF   x61
....................             perforacion(); 
1D6C:  BRA    1884
....................             salir = 0; 
1D6E:  CLRF   38
....................         } 
1D70:  BRA    1C6C
....................     } 
1D72:  BRA    19CA
.................... } 
1D74:  SLEEP 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV20 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
