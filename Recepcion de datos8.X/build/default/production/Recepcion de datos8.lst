CCS PCH C Compiler, Version 5.015, 59972               07-oct.-18 17:09

               Filename:   E:\Proyecto\GUI\Recepcion de datos8.X\build\default\production\Recepcion de datos8.lst

               ROM used:   7520 bytes (23%)
                           Largest free fragment is 25244
               RAM used:   116 (6%) at main() level
                           152 (7%) worst case
               Stack used: 9 locations (7 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   195E
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   0238
0054:  BTFSS  FF2.4
0056:  GOTO   0060
005A:  BTFSC  FF2.1
005C:  GOTO   01BA
0060:  BTFSS  FF0.4
0062:  GOTO   006C
0066:  BTFSC  FF0.1
0068:  GOTO   0160
006C:  BTFSS  F9D.5
006E:  GOTO   0078
0072:  BTFSC  F9E.5
0074:  GOTO   0306
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00BA:  MOVFF  FF2,0D
00BE:  BCF    FF2.7
00C0:  CLRF   FF7
00C2:  ADDLW  D4
00C4:  MOVWF  FF6
00C6:  MOVLW  00
00C8:  ADDWFC FF7,F
00CA:  TBLRD*+
00CC:  MOVF   FF5,W
00CE:  BTFSC  0D.7
00D0:  BSF    FF2.7
00D2:  RETURN 0
00D4:  DATA 28,0C
00D6:  DATA 01,06
00D8:  DATA 0C,41
00DA:  DATA 6A,75
00DC:  DATA 73,74
00DE:  DATA 61,6E
00E0:  DATA 64,6F
00E2:  DATA 20,5A
00E4:  DATA 0A,00
00E6:  DATA 50,72
00E8:  DATA 6F,66
00EA:  DATA 75,6E
00EC:  DATA 64,69
00EE:  DATA 64,61
00F0:  DATA 64,20
00F2:  DATA 64,65
00F4:  DATA 20,6D
00F6:  DATA 65,63
00F8:  DATA 68,61
00FA:  DATA 00,00
00FC:  DATA 42,75
00FE:  DATA 73,63
0100:  DATA 61,6E
0102:  DATA 64,6F
0104:  DATA 20,63
0106:  DATA 65,72
0108:  DATA 6F,20
010A:  DATA 5A,00
010C:  DATA 20,4F
010E:  DATA 4B,0A
0110:  DATA 00,00
0112:  DATA 0C,42
0114:  DATA 75,73
0116:  DATA 63,61
0118:  DATA 6E,64
011A:  DATA 6F,20
011C:  DATA 6F,72
011E:  DATA 69,67
0120:  DATA 65,6E
0122:  DATA 0A,00
0124:  DATA 42,75
0126:  DATA 73,63
0128:  DATA 61,6E
012A:  DATA 64,6F
012C:  DATA 20,63
012E:  DATA 65,72
0130:  DATA 6F,20
0132:  DATA 58,0A
0134:  DATA 00,00
0136:  DATA 42,75
0138:  DATA 73,63
013A:  DATA 61,6E
013C:  DATA 64,6F
013E:  DATA 20,63
0140:  DATA 65,72
0142:  DATA 6F,20
0144:  DATA 59,0A
0146:  DATA 00,00
0148:  DATA 4F,4B
014A:  DATA 00,00
014C:  DATA 4F,4B
014E:  DATA 00,00
0150:  DATA 4F,4B
0152:  DATA 00,00
0154:  DATA 4F,4B
0156:  DATA 00,00
*
040A:  DATA 0C,48
040C:  DATA 41,47
040E:  DATA 41,20
0410:  DATA 43,4C
0412:  DATA 49,43
0414:  DATA 4B,20
0416:  DATA 45,4E
0418:  DATA 0A,00
041A:  DATA 45,4E
041C:  DATA 20,43
041E:  DATA 41,4C
0420:  DATA 49,42
0422:  DATA 52,41
0424:  DATA 52,20
0426:  DATA 45,4E
0428:  DATA 20,45
042A:  DATA 4C,0A
042C:  DATA 00,00
042E:  DATA 50,52
0430:  DATA 4F,47
0432:  DATA 52,41
0434:  DATA 4D,41
0436:  DATA 20,59
0438:  DATA 20,45
043A:  DATA 53,50
043C:  DATA 45,52
043E:  DATA 45,20
0440:  DATA 0A,00
0442:  DATA 55,4E
0444:  DATA 20,4D
0446:  DATA 4F,4D
0448:  DATA 45,4E
044A:  DATA 54,4F
044C:  DATA 2E,00
044E:  DATA 0C,50
0450:  DATA 6F,6E
0452:  DATA 65,72
0454:  DATA 20,6D
0456:  DATA 65,63
0458:  DATA 68,61
045A:  DATA 20,25
045C:  DATA 30,31
045E:  DATA 2E,33
0460:  DATA 66,6D
0462:  DATA 6D,00
0464:  DATA 0A,50
0466:  DATA 72,65
0468:  DATA 73,69
046A:  DATA 6F,6E
046C:  DATA 65,20
046E:  DATA 65,6E
0470:  DATA 74,65
0472:  DATA 72,20
0474:  DATA 70,61
0476:  DATA 72,61
0478:  DATA 0A,00
047A:  DATA 63,6F
047C:  DATA 6D,65
047E:  DATA 6E,7A
0480:  DATA 61,72
0482:  DATA 20,65
0484:  DATA 6C,20
0486:  DATA 61,6A
0488:  DATA 75,73
048A:  DATA 74,65
048C:  DATA 0A,00
048E:  DATA 64,65
0490:  DATA 20,6C
0492:  DATA 61,20
0494:  DATA 70,6C
0496:  DATA 61,63
0498:  DATA 61,2E
049A:  DATA 00,00
049C:  DATA 0C,47
049E:  DATA 69,72
04A0:  DATA 65,20
04A2:  DATA 70,61
04A4:  DATA 72,61
04A6:  DATA 20,73
04A8:  DATA 75,62
04AA:  DATA 69,72
04AC:  DATA 20,6F
04AE:  DATA 0A,00
04B0:  DATA 62,61
04B2:  DATA 6A,61
04B4:  DATA 72,20
04B6:  DATA 6D,65
04B8:  DATA 63,68
04BA:  DATA 61,2E
04BC:  DATA 50,72
04BE:  DATA 65,73
04C0:  DATA 69,6F
04C2:  DATA 6E,65
04C4:  DATA 0A,00
04C6:  DATA 65,6E
04C8:  DATA 74,65
04CA:  DATA 72,20
04CC:  DATA 6E,75
04CE:  DATA 65,76
04D0:  DATA 6F,20
04D2:  DATA 70,75
04D4:  DATA 6E,74
04D6:  DATA 6F,2E
04D8:  DATA 0A,00
04DA:  DATA 42,6F
04DC:  DATA 74,6F
04DE:  DATA 6E,20
04E0:  DATA 72,6F
04E2:  DATA 6A,6F
04E4:  DATA 20,73
04E6:  DATA 61,6C
04E8:  DATA 69,72
04EA:  DATA 2E,0A
04EC:  DATA 00,00
04EE:  DATA 0C,50
04F0:  DATA 6F,72
04F2:  DATA 20,66
04F4:  DATA 61,76
04F6:  DATA 6F,72
04F8:  DATA 20,63
04FA:  DATA 6F,6C
04FC:  DATA 6F,71
04FE:  DATA 75,65
0500:  DATA 0A,00
0502:  DATA 6D,65
0504:  DATA 63,68
0506:  DATA 61,20
0508:  DATA 64,65
050A:  DATA 20,25
050C:  DATA 30,31
050E:  DATA 2E,32
0510:  DATA 66,6D
0512:  DATA 6D,20
0514:  DATA 79,00
0516:  DATA 0A,70
0518:  DATA 72,65
051A:  DATA 73,69
051C:  DATA 6F,6E
051E:  DATA 65,20
0520:  DATA 65,6E
0522:  DATA 74,65
0524:  DATA 72,00
0526:  DATA 4F,4B
0528:  DATA 00,00
052A:  DATA 0C,50
052C:  DATA 65,72
052E:  DATA 66,6F
0530:  DATA 72,61
0532:  DATA 64,6F
0534:  DATA 72,61
0536:  DATA 20,4C
0538:  DATA 69,73
053A:  DATA 74,61
053C:  DATA 0A,00
053E:  DATA 70,61
0540:  DATA 72,61
0542:  DATA 20,6F
0544:  DATA 70,65
0546:  DATA 72,61
0548:  DATA 72,20
054A:  DATA 70,75
054C:  DATA 6C,73
054E:  DATA 65,20
0550:  DATA 2A,0A
0552:  DATA 00,00
0554:  DATA 70,61
0556:  DATA 72,61
0558:  DATA 20,63
055A:  DATA 6F,6D
055C:  DATA 65,6E
055E:  DATA 7A,61
0560:  DATA 72,00
0562:  DATA 4F,4B
0564:  DATA 00,00
0566:  DATA 0C,50
0568:  DATA 45,52
056A:  DATA 46,4F
056C:  DATA 52,41
056E:  DATA 4E,44
0570:  DATA 4F,0A
0572:  DATA 00,00
*
071C:  TBLRD*+
071E:  MOVF   FF5,F
0720:  BZ    073A
0722:  MOVFF  FF6,73
0726:  MOVFF  FF7,74
072A:  MOVFF  FF5,80
072E:  RCALL  06C8
0730:  MOVFF  73,FF6
0734:  MOVFF  74,FF7
0738:  BRA    071C
073A:  RETURN 0
*
0884:  MOVLW  B6
0886:  MOVWF  00
0888:  CLRF   03
088A:  CLRF   02
088C:  CLRF   01
088E:  BCF    x7B.0
0890:  BTFSS  x7A.7
0892:  BRA    08AC
0894:  BSF    x7B.0
0896:  COMF   x77,F
0898:  COMF   x78,F
089A:  COMF   x79,F
089C:  COMF   x7A,F
089E:  INCF   x77,F
08A0:  BNZ   08AC
08A2:  INCF   x78,F
08A4:  BNZ   08AC
08A6:  INCF   x79,F
08A8:  BTFSC  FD8.2
08AA:  INCF   x7A,F
08AC:  MOVF   x77,W
08AE:  IORWF  x78,W
08B0:  IORWF  x79,W
08B2:  IORWF  x7A,W
08B4:  BNZ   08BA
08B6:  CLRF   00
08B8:  BRA    08D8
08BA:  BCF    FD8.0
08BC:  BTFSC  01.7
08BE:  BRA    08D2
08C0:  RLCF   x77,F
08C2:  RLCF   x78,F
08C4:  RLCF   x79,F
08C6:  RLCF   x7A,F
08C8:  RLCF   03,F
08CA:  RLCF   02,F
08CC:  RLCF   01,F
08CE:  DECFSZ 00,F
08D0:  BRA    08BA
08D2:  BCF    01.7
08D4:  BTFSC  x7B.0
08D6:  BSF    01.7
08D8:  RETURN 0
08DA:  MOVF   x86,W
08DC:  BTFSC  FD8.2
08DE:  BRA    0A2A
08E0:  MOVWF  x92
08E2:  MOVF   x8A,W
08E4:  BTFSC  FD8.2
08E6:  BRA    0A2A
08E8:  SUBWF  x92,F
08EA:  BNC   08F6
08EC:  MOVLW  7F
08EE:  ADDWF  x92,F
08F0:  BTFSC  FD8.0
08F2:  BRA    0A2A
08F4:  BRA    0902
08F6:  MOVLW  81
08F8:  SUBWF  x92,F
08FA:  BTFSS  FD8.0
08FC:  BRA    0A2A
08FE:  BTFSC  FD8.2
0900:  BRA    0A2A
0902:  MOVFF  92,00
0906:  CLRF   01
0908:  CLRF   02
090A:  CLRF   03
090C:  CLRF   x91
090E:  MOVFF  87,90
0912:  BSF    x90.7
0914:  MOVFF  88,8F
0918:  MOVFF  89,8E
091C:  MOVLW  19
091E:  MOVWF  x92
0920:  MOVF   x8D,W
0922:  SUBWF  x8E,F
0924:  BC    0940
0926:  MOVLW  01
0928:  SUBWF  x8F,F
092A:  BC    0940
092C:  SUBWF  x90,F
092E:  BC    0940
0930:  SUBWF  x91,F
0932:  BC    0940
0934:  INCF   x91,F
0936:  INCF   x90,F
0938:  INCF   x8F,F
093A:  MOVF   x8D,W
093C:  ADDWF  x8E,F
093E:  BRA    0990
0940:  MOVF   x8C,W
0942:  SUBWF  x8F,F
0944:  BC    096A
0946:  MOVLW  01
0948:  SUBWF  x90,F
094A:  BC    096A
094C:  SUBWF  x91,F
094E:  BC    096A
0950:  INCF   x91,F
0952:  INCF   x90,F
0954:  MOVF   x8C,W
0956:  ADDWF  x8F,F
0958:  MOVF   x8D,W
095A:  ADDWF  x8E,F
095C:  BNC   0990
095E:  INCF   x8F,F
0960:  BNZ   0990
0962:  INCF   x90,F
0964:  BNZ   0990
0966:  INCF   x91,F
0968:  BRA    0990
096A:  MOVF   x8B,W
096C:  IORLW  80
096E:  SUBWF  x90,F
0970:  BC    098E
0972:  MOVLW  01
0974:  SUBWF  x91,F
0976:  BC    098E
0978:  INCF   x91,F
097A:  MOVF   x8B,W
097C:  IORLW  80
097E:  ADDWF  x90,F
0980:  MOVF   x8C,W
0982:  ADDWF  x8F,F
0984:  BNC   0958
0986:  INCF   x90,F
0988:  BNZ   0958
098A:  INCF   x91,F
098C:  BRA    0958
098E:  BSF    03.0
0990:  DECFSZ x92,F
0992:  BRA    0996
0994:  BRA    09AC
0996:  BCF    FD8.0
0998:  RLCF   x8E,F
099A:  RLCF   x8F,F
099C:  RLCF   x90,F
099E:  RLCF   x91,F
09A0:  BCF    FD8.0
09A2:  RLCF   03,F
09A4:  RLCF   02,F
09A6:  RLCF   01,F
09A8:  RLCF   x93,F
09AA:  BRA    0920
09AC:  BTFSS  x93.0
09AE:  BRA    09BC
09B0:  BCF    FD8.0
09B2:  RRCF   01,F
09B4:  RRCF   02,F
09B6:  RRCF   03,F
09B8:  RRCF   x93,F
09BA:  BRA    09C0
09BC:  DECF   00,F
09BE:  BZ    0A2A
09C0:  BTFSC  x93.7
09C2:  BRA    0A00
09C4:  BCF    FD8.0
09C6:  RLCF   x8E,F
09C8:  RLCF   x8F,F
09CA:  RLCF   x90,F
09CC:  RLCF   x91,F
09CE:  MOVF   x8D,W
09D0:  SUBWF  x8E,F
09D2:  BC    09E2
09D4:  MOVLW  01
09D6:  SUBWF  x8F,F
09D8:  BC    09E2
09DA:  SUBWF  x90,F
09DC:  BC    09E2
09DE:  SUBWF  x91,F
09E0:  BNC   0A16
09E2:  MOVF   x8C,W
09E4:  SUBWF  x8F,F
09E6:  BC    09F2
09E8:  MOVLW  01
09EA:  SUBWF  x90,F
09EC:  BC    09F2
09EE:  SUBWF  x91,F
09F0:  BNC   0A16
09F2:  MOVF   x8B,W
09F4:  IORLW  80
09F6:  SUBWF  x90,F
09F8:  BC    0A00
09FA:  MOVLW  01
09FC:  SUBWF  x91,F
09FE:  BNC   0A16
0A00:  INCF   03,F
0A02:  BNZ   0A16
0A04:  INCF   02,F
0A06:  BNZ   0A16
0A08:  INCF   01,F
0A0A:  BNZ   0A16
0A0C:  INCF   00,F
0A0E:  BZ    0A2A
0A10:  RRCF   01,F
0A12:  RRCF   02,F
0A14:  RRCF   03,F
0A16:  MOVFF  87,92
0A1A:  MOVF   x8B,W
0A1C:  XORWF  x92,F
0A1E:  BTFSS  x92.7
0A20:  BRA    0A26
0A22:  BSF    01.7
0A24:  BRA    0A32
0A26:  BCF    01.7
0A28:  BRA    0A32
0A2A:  CLRF   00
0A2C:  CLRF   01
0A2E:  CLRF   02
0A30:  CLRF   03
0A32:  RETURN 0
0A34:  MOVFF  74,7B
0A38:  MOVF   x78,W
0A3A:  XORWF  x7B,F
0A3C:  BTFSS  x7B.7
0A3E:  BRA    0A4A
0A40:  BCF    FD8.2
0A42:  BCF    FD8.0
0A44:  BTFSC  x74.7
0A46:  BSF    FD8.0
0A48:  BRA    0AA8
0A4A:  MOVFF  74,7B
0A4E:  MOVFF  77,7C
0A52:  MOVF   x73,W
0A54:  SUBWF  x7C,F
0A56:  BZ    0A64
0A58:  BTFSS  x7B.7
0A5A:  BRA    0AA8
0A5C:  MOVF   FD8,W
0A5E:  XORLW  01
0A60:  MOVWF  FD8
0A62:  BRA    0AA8
0A64:  MOVFF  78,7C
0A68:  MOVF   x74,W
0A6A:  SUBWF  x7C,F
0A6C:  BZ    0A7A
0A6E:  BTFSS  x7B.7
0A70:  BRA    0AA8
0A72:  MOVF   FD8,W
0A74:  XORLW  01
0A76:  MOVWF  FD8
0A78:  BRA    0AA8
0A7A:  MOVFF  79,7C
0A7E:  MOVF   x75,W
0A80:  SUBWF  x7C,F
0A82:  BZ    0A90
0A84:  BTFSS  x7B.7
0A86:  BRA    0AA8
0A88:  MOVF   FD8,W
0A8A:  XORLW  01
0A8C:  MOVWF  FD8
0A8E:  BRA    0AA8
0A90:  MOVFF  7A,7C
0A94:  MOVF   x76,W
0A96:  SUBWF  x7C,F
0A98:  BZ    0AA6
0A9A:  BTFSS  x7B.7
0A9C:  BRA    0AA8
0A9E:  MOVF   FD8,W
0AA0:  XORLW  01
0AA2:  MOVWF  FD8
0AA4:  BRA    0AA8
0AA6:  BCF    FD8.0
0AA8:  RETURN 0
0AAA:  MOVLW  80
0AAC:  BTFSC  FD8.1
0AAE:  XORWF  x8B,F
0AB0:  CLRF   x90
0AB2:  CLRF   x91
0AB4:  MOVFF  87,8F
0AB8:  MOVF   x8B,W
0ABA:  XORWF  x8F,F
0ABC:  MOVF   x86,W
0ABE:  BTFSC  FD8.2
0AC0:  BRA    0C7A
0AC2:  MOVWF  x8E
0AC4:  MOVWF  00
0AC6:  MOVF   x8A,W
0AC8:  BTFSC  FD8.2
0ACA:  BRA    0C8C
0ACC:  SUBWF  x8E,F
0ACE:  BTFSC  FD8.2
0AD0:  BRA    0BD4
0AD2:  BNC   0B4E
0AD4:  MOVFF  8B,94
0AD8:  BSF    x94.7
0ADA:  MOVFF  8C,93
0ADE:  MOVFF  8D,92
0AE2:  CLRF   x91
0AE4:  BCF    FD8.0
0AE6:  RRCF   x94,F
0AE8:  RRCF   x93,F
0AEA:  RRCF   x92,F
0AEC:  RRCF   x91,F
0AEE:  DECFSZ x8E,F
0AF0:  BRA    0AE2
0AF2:  BTFSS  x8F.7
0AF4:  BRA    0AFC
0AF6:  BSF    x90.0
0AF8:  BRA    0CB4
0AFA:  BCF    x90.0
0AFC:  BCF    x8E.0
0AFE:  BSF    x90.4
0B00:  CLRF   FEA
0B02:  MOVLW  89
0B04:  MOVWF  FE9
0B06:  BRA    0CDA
0B08:  BCF    x90.4
0B0A:  BTFSC  x8F.7
0B0C:  BRA    0B22
0B0E:  BTFSS  x8E.0
0B10:  BRA    0B38
0B12:  RRCF   x94,F
0B14:  RRCF   x93,F
0B16:  RRCF   x92,F
0B18:  RRCF   x91,F
0B1A:  INCF   00,F
0B1C:  BTFSC  FD8.2
0B1E:  BRA    0CAA
0B20:  BRA    0B38
0B22:  BTFSC  x94.7
0B24:  BRA    0B3E
0B26:  BCF    FD8.0
0B28:  RLCF   x91,F
0B2A:  RLCF   x92,F
0B2C:  RLCF   x93,F
0B2E:  RLCF   x94,F
0B30:  DECF   00,F
0B32:  BTFSC  FD8.2
0B34:  BRA    0CAA
0B36:  BRA    0B22
0B38:  BSF    x90.6
0B3A:  BRA    0C12
0B3C:  BCF    x90.6
0B3E:  MOVFF  87,8F
0B42:  BTFSS  x87.7
0B44:  BRA    0B4A
0B46:  BSF    x94.7
0B48:  BRA    0C9C
0B4A:  BCF    x94.7
0B4C:  BRA    0C9C
0B4E:  MOVFF  8A,8E
0B52:  MOVFF  8A,00
0B56:  MOVF   x86,W
0B58:  SUBWF  x8E,F
0B5A:  MOVFF  87,94
0B5E:  BSF    x94.7
0B60:  MOVFF  88,93
0B64:  MOVFF  89,92
0B68:  CLRF   x91
0B6A:  BCF    FD8.0
0B6C:  RRCF   x94,F
0B6E:  RRCF   x93,F
0B70:  RRCF   x92,F
0B72:  RRCF   x91,F
0B74:  DECFSZ x8E,F
0B76:  BRA    0B68
0B78:  BTFSS  x8F.7
0B7A:  BRA    0B82
0B7C:  BSF    x90.1
0B7E:  BRA    0CB4
0B80:  BCF    x90.1
0B82:  BCF    x8E.0
0B84:  BSF    x90.5
0B86:  CLRF   FEA
0B88:  MOVLW  8D
0B8A:  MOVWF  FE9
0B8C:  BRA    0CDA
0B8E:  BCF    x90.5
0B90:  BTFSC  x8F.7
0B92:  BRA    0BA8
0B94:  BTFSS  x8E.0
0B96:  BRA    0BBE
0B98:  RRCF   x94,F
0B9A:  RRCF   x93,F
0B9C:  RRCF   x92,F
0B9E:  RRCF   x91,F
0BA0:  INCF   00,F
0BA2:  BTFSC  FD8.2
0BA4:  BRA    0CAA
0BA6:  BRA    0BBE
0BA8:  BTFSC  x94.7
0BAA:  BRA    0BC4
0BAC:  BCF    FD8.0
0BAE:  RLCF   x91,F
0BB0:  RLCF   x92,F
0BB2:  RLCF   x93,F
0BB4:  RLCF   x94,F
0BB6:  DECF   00,F
0BB8:  BTFSC  FD8.2
0BBA:  BRA    0CAA
0BBC:  BRA    0BA8
0BBE:  BSF    x90.7
0BC0:  BRA    0C12
0BC2:  BCF    x90.7
0BC4:  MOVFF  8B,8F
0BC8:  BTFSS  x8B.7
0BCA:  BRA    0BD0
0BCC:  BSF    x94.7
0BCE:  BRA    0C9C
0BD0:  BCF    x94.7
0BD2:  BRA    0C9C
0BD4:  MOVFF  8B,94
0BD8:  BSF    x94.7
0BDA:  MOVFF  8C,93
0BDE:  MOVFF  8D,92
0BE2:  BTFSS  x8F.7
0BE4:  BRA    0BEE
0BE6:  BCF    x94.7
0BE8:  BSF    x90.2
0BEA:  BRA    0CB4
0BEC:  BCF    x90.2
0BEE:  CLRF   x91
0BF0:  BCF    x8E.0
0BF2:  CLRF   FEA
0BF4:  MOVLW  89
0BF6:  MOVWF  FE9
0BF8:  BRA    0CDA
0BFA:  BTFSC  x8F.7
0BFC:  BRA    0C36
0BFE:  MOVFF  87,8F
0C02:  BTFSS  x8E.0
0C04:  BRA    0C12
0C06:  RRCF   x94,F
0C08:  RRCF   x93,F
0C0A:  RRCF   x92,F
0C0C:  RRCF   x91,F
0C0E:  INCF   00,F
0C10:  BZ    0CAA
0C12:  BTFSS  x91.7
0C14:  BRA    0C2C
0C16:  INCF   x92,F
0C18:  BNZ   0C2C
0C1A:  INCF   x93,F
0C1C:  BNZ   0C2C
0C1E:  INCF   x94,F
0C20:  BNZ   0C2C
0C22:  RRCF   x94,F
0C24:  RRCF   x93,F
0C26:  RRCF   x92,F
0C28:  INCF   00,F
0C2A:  BZ    0CAA
0C2C:  BTFSC  x90.6
0C2E:  BRA    0B3C
0C30:  BTFSC  x90.7
0C32:  BRA    0BC2
0C34:  BRA    0C6E
0C36:  MOVLW  80
0C38:  XORWF  x94,F
0C3A:  BTFSS  x94.7
0C3C:  BRA    0C46
0C3E:  BRA    0CB4
0C40:  MOVFF  8B,8F
0C44:  BRA    0C5A
0C46:  MOVFF  87,8F
0C4A:  MOVF   x94,F
0C4C:  BNZ   0C5A
0C4E:  MOVF   x93,F
0C50:  BNZ   0C5A
0C52:  MOVF   x92,F
0C54:  BNZ   0C5A
0C56:  CLRF   00
0C58:  BRA    0C9C
0C5A:  BTFSC  x94.7
0C5C:  BRA    0C6E
0C5E:  BCF    FD8.0
0C60:  RLCF   x91,F
0C62:  RLCF   x92,F
0C64:  RLCF   x93,F
0C66:  RLCF   x94,F
0C68:  DECFSZ 00,F
0C6A:  BRA    0C5A
0C6C:  BRA    0CAA
0C6E:  BTFSS  x8F.7
0C70:  BRA    0C76
0C72:  BSF    x94.7
0C74:  BRA    0C9C
0C76:  BCF    x94.7
0C78:  BRA    0C9C
0C7A:  MOVFF  8A,00
0C7E:  MOVFF  8B,94
0C82:  MOVFF  8C,93
0C86:  MOVFF  8D,92
0C8A:  BRA    0C9C
0C8C:  MOVFF  86,00
0C90:  MOVFF  87,94
0C94:  MOVFF  88,93
0C98:  MOVFF  89,92
0C9C:  MOVFF  94,01
0CA0:  MOVFF  93,02
0CA4:  MOVFF  92,03
0CA8:  BRA    0D12
0CAA:  CLRF   00
0CAC:  CLRF   01
0CAE:  CLRF   02
0CB0:  CLRF   03
0CB2:  BRA    0D12
0CB4:  CLRF   x91
0CB6:  COMF   x92,F
0CB8:  COMF   x93,F
0CBA:  COMF   x94,F
0CBC:  COMF   x91,F
0CBE:  INCF   x91,F
0CC0:  BNZ   0CCC
0CC2:  INCF   x92,F
0CC4:  BNZ   0CCC
0CC6:  INCF   x93,F
0CC8:  BNZ   0CCC
0CCA:  INCF   x94,F
0CCC:  BTFSC  x90.0
0CCE:  BRA    0AFA
0CD0:  BTFSC  x90.1
0CD2:  BRA    0B80
0CD4:  BTFSC  x90.2
0CD6:  BRA    0BEC
0CD8:  BRA    0C40
0CDA:  MOVF   FEF,W
0CDC:  ADDWF  x92,F
0CDE:  BNC   0CEA
0CE0:  INCF   x93,F
0CE2:  BNZ   0CEA
0CE4:  INCF   x94,F
0CE6:  BTFSC  FD8.2
0CE8:  BSF    x8E.0
0CEA:  MOVF   FED,F
0CEC:  MOVF   FEF,W
0CEE:  ADDWF  x93,F
0CF0:  BNC   0CF8
0CF2:  INCF   x94,F
0CF4:  BTFSC  FD8.2
0CF6:  BSF    x8E.0
0CF8:  MOVF   FED,F
0CFA:  MOVF   FEF,W
0CFC:  BTFSC  FEF.7
0CFE:  BRA    0D02
0D00:  XORLW  80
0D02:  ADDWF  x94,F
0D04:  BTFSC  FD8.0
0D06:  BSF    x8E.0
0D08:  BTFSC  x90.4
0D0A:  BRA    0B08
0D0C:  BTFSC  x90.5
0D0E:  BRA    0B8E
0D10:  BRA    0BFA
0D12:  RETURN 0
0D14:  MOVLW  8E
0D16:  MOVWF  00
0D18:  MOVF   x73,W
0D1A:  SUBWF  00,F
0D1C:  MOVFF  74,02
0D20:  MOVFF  75,01
0D24:  BSF    02.7
0D26:  MOVF   00,F
0D28:  BZ    0D3C
0D2A:  BCF    FD8.0
0D2C:  MOVF   02,F
0D2E:  BNZ   0D34
0D30:  MOVF   01,F
0D32:  BZ    0D3C
0D34:  RRCF   02,F
0D36:  RRCF   01,F
0D38:  DECFSZ 00,F
0D3A:  BRA    0D2A
0D3C:  BTFSS  x74.7
0D3E:  BRA    0D4A
0D40:  COMF   01,F
0D42:  COMF   02,F
0D44:  INCF   01,F
0D46:  BTFSC  FD8.2
0D48:  INCF   02,F
0D4A:  RETURN 0
0D4C:  CLRF   x7B
0D4E:  CLRF   x7C
0D50:  MOVLW  01
0D52:  MOVWF  x7D
0D54:  CLRF   FDA
0D56:  CLRF   FD9
0D58:  CLRF   x80
0D5A:  MOVLW  73
0D5C:  MOVWF  x7F
0D5E:  CLRF   FEA
0D60:  MOVLW  77
0D62:  MOVWF  FE9
0D64:  MOVFF  80,FE2
0D68:  MOVFF  7F,FE1
0D6C:  MOVFF  7D,7E
0D70:  BCF    FD8.0
0D72:  MOVF   FE5,W
0D74:  MULWF  FEE
0D76:  MOVF   FF3,W
0D78:  ADDWFC x7B,F
0D7A:  MOVF   FF4,W
0D7C:  ADDWFC x7C,F
0D7E:  DECFSZ x7E,F
0D80:  BRA    0D70
0D82:  MOVFF  7B,FDE
0D86:  MOVFF  7C,7B
0D8A:  CLRF   x7C
0D8C:  BTFSC  FD8.0
0D8E:  INCF   x7C,F
0D90:  INCF   x7F,F
0D92:  BTFSC  FD8.2
0D94:  INCF   x80,F
0D96:  INCF   x7D,F
0D98:  MOVF   x7D,W
0D9A:  SUBLW  05
0D9C:  BNZ   0D5E
0D9E:  RETURN 0
*
109E:  MOVF   x82,W
10A0:  BTFSC  FD8.2
10A2:  BRA    1186
10A4:  MOVWF  00
10A6:  MOVF   x86,W
10A8:  BTFSC  FD8.2
10AA:  BRA    1186
10AC:  ADDWF  00,F
10AE:  BNC   10B8
10B0:  MOVLW  81
10B2:  ADDWF  00,F
10B4:  BC    1186
10B6:  BRA    10C0
10B8:  MOVLW  7F
10BA:  SUBWF  00,F
10BC:  BNC   1186
10BE:  BZ    1186
10C0:  MOVFF  83,8A
10C4:  MOVF   x87,W
10C6:  XORWF  x8A,F
10C8:  BSF    x83.7
10CA:  BSF    x87.7
10CC:  MOVF   x85,W
10CE:  MULWF  x89
10D0:  MOVFF  FF4,8C
10D4:  MOVF   x84,W
10D6:  MULWF  x88
10D8:  MOVFF  FF4,03
10DC:  MOVFF  FF3,8B
10E0:  MULWF  x89
10E2:  MOVF   FF3,W
10E4:  ADDWF  x8C,F
10E6:  MOVF   FF4,W
10E8:  ADDWFC x8B,F
10EA:  MOVLW  00
10EC:  ADDWFC 03,F
10EE:  MOVF   x85,W
10F0:  MULWF  x88
10F2:  MOVF   FF3,W
10F4:  ADDWF  x8C,F
10F6:  MOVF   FF4,W
10F8:  ADDWFC x8B,F
10FA:  MOVLW  00
10FC:  CLRF   02
10FE:  ADDWFC 03,F
1100:  ADDWFC 02,F
1102:  MOVF   x83,W
1104:  MULWF  x89
1106:  MOVF   FF3,W
1108:  ADDWF  x8B,F
110A:  MOVF   FF4,W
110C:  ADDWFC 03,F
110E:  MOVLW  00
1110:  ADDWFC 02,F
1112:  MOVF   x83,W
1114:  MULWF  x88
1116:  MOVF   FF3,W
1118:  ADDWF  03,F
111A:  MOVF   FF4,W
111C:  ADDWFC 02,F
111E:  MOVLW  00
1120:  CLRF   01
1122:  ADDWFC 01,F
1124:  MOVF   x85,W
1126:  MULWF  x87
1128:  MOVF   FF3,W
112A:  ADDWF  x8B,F
112C:  MOVF   FF4,W
112E:  ADDWFC 03,F
1130:  MOVLW  00
1132:  ADDWFC 02,F
1134:  ADDWFC 01,F
1136:  MOVF   x84,W
1138:  MULWF  x87
113A:  MOVF   FF3,W
113C:  ADDWF  03,F
113E:  MOVF   FF4,W
1140:  ADDWFC 02,F
1142:  MOVLW  00
1144:  ADDWFC 01,F
1146:  MOVF   x83,W
1148:  MULWF  x87
114A:  MOVF   FF3,W
114C:  ADDWF  02,F
114E:  MOVF   FF4,W
1150:  ADDWFC 01,F
1152:  INCF   00,F
1154:  BTFSC  01.7
1156:  BRA    1162
1158:  RLCF   x8B,F
115A:  RLCF   03,F
115C:  RLCF   02,F
115E:  RLCF   01,F
1160:  DECF   00,F
1162:  MOVLW  00
1164:  BTFSS  x8B.7
1166:  BRA    117C
1168:  INCF   03,F
116A:  ADDWFC 02,F
116C:  ADDWFC 01,F
116E:  MOVF   01,W
1170:  BNZ   117C
1172:  MOVF   02,W
1174:  BNZ   117C
1176:  MOVF   03,W
1178:  BNZ   117C
117A:  INCF   00,F
117C:  BTFSC  x8A.7
117E:  BSF    01.7
1180:  BTFSS  x8A.7
1182:  BCF    01.7
1184:  BRA    118E
1186:  CLRF   00
1188:  CLRF   01
118A:  CLRF   02
118C:  CLRF   03
118E:  RETURN 0
1190:  MOVLW  8E
1192:  MOVWF  00
1194:  MOVFF  87,01
1198:  MOVFF  86,02
119C:  CLRF   03
119E:  MOVF   01,F
11A0:  BNZ   11B4
11A2:  MOVFF  02,01
11A6:  CLRF   02
11A8:  MOVLW  08
11AA:  SUBWF  00,F
11AC:  MOVF   01,F
11AE:  BNZ   11B4
11B0:  CLRF   00
11B2:  BRA    11C4
11B4:  BCF    FD8.0
11B6:  BTFSC  01.7
11B8:  BRA    11C2
11BA:  RLCF   02,F
11BC:  RLCF   01,F
11BE:  DECF   00,F
11C0:  BRA    11B4
11C2:  BCF    01.7
11C4:  RETURN 0
*
1426:  TBLRD*+
1428:  MOVFF  FF6,74
142C:  MOVFF  FF7,75
1430:  MOVFF  FF5,80
1434:  CALL   06C8
1438:  MOVFF  74,FF6
143C:  MOVFF  75,FF7
1440:  DECFSZ x73,F
1442:  BRA    1426
1444:  RETURN 0
1446:  MOVF   x80,W
1448:  SUBLW  B6
144A:  MOVWF  x80
144C:  CLRF   03
144E:  MOVFF  81,84
1452:  BSF    x81.7
1454:  BCF    FD8.0
1456:  RRCF   x81,F
1458:  RRCF   x82,F
145A:  RRCF   x83,F
145C:  RRCF   03,F
145E:  RRCF   02,F
1460:  RRCF   01,F
1462:  RRCF   00,F
1464:  DECFSZ x80,F
1466:  BRA    1454
1468:  BTFSS  x84.7
146A:  BRA    1482
146C:  COMF   00,F
146E:  COMF   01,F
1470:  COMF   02,F
1472:  COMF   03,F
1474:  INCF   00,F
1476:  BTFSC  FD8.2
1478:  INCF   01,F
147A:  BTFSC  FD8.2
147C:  INCF   02,F
147E:  BTFSC  FD8.2
1480:  INCF   03,F
1482:  RETURN 0
1484:  BTFSC  FD8.1
1486:  BRA    148E
1488:  CLRF   FEA
148A:  MOVLW  88
148C:  MOVWF  FE9
148E:  CLRF   00
1490:  CLRF   01
1492:  CLRF   02
1494:  CLRF   03
1496:  CLRF   x88
1498:  CLRF   x89
149A:  CLRF   x8A
149C:  CLRF   x8B
149E:  MOVF   x87,W
14A0:  IORWF  x86,W
14A2:  IORWF  x85,W
14A4:  IORWF  x84,W
14A6:  BZ    1500
14A8:  MOVLW  20
14AA:  MOVWF  x8C
14AC:  BCF    FD8.0
14AE:  RLCF   x80,F
14B0:  RLCF   x81,F
14B2:  RLCF   x82,F
14B4:  RLCF   x83,F
14B6:  RLCF   x88,F
14B8:  RLCF   x89,F
14BA:  RLCF   x8A,F
14BC:  RLCF   x8B,F
14BE:  MOVF   x87,W
14C0:  SUBWF  x8B,W
14C2:  BNZ   14D4
14C4:  MOVF   x86,W
14C6:  SUBWF  x8A,W
14C8:  BNZ   14D4
14CA:  MOVF   x85,W
14CC:  SUBWF  x89,W
14CE:  BNZ   14D4
14D0:  MOVF   x84,W
14D2:  SUBWF  x88,W
14D4:  BNC   14F4
14D6:  MOVF   x84,W
14D8:  SUBWF  x88,F
14DA:  MOVF   x85,W
14DC:  BTFSS  FD8.0
14DE:  INCFSZ x85,W
14E0:  SUBWF  x89,F
14E2:  MOVF   x86,W
14E4:  BTFSS  FD8.0
14E6:  INCFSZ x86,W
14E8:  SUBWF  x8A,F
14EA:  MOVF   x87,W
14EC:  BTFSS  FD8.0
14EE:  INCFSZ x87,W
14F0:  SUBWF  x8B,F
14F2:  BSF    FD8.0
14F4:  RLCF   00,F
14F6:  RLCF   01,F
14F8:  RLCF   02,F
14FA:  RLCF   03,F
14FC:  DECFSZ x8C,F
14FE:  BRA    14AC
1500:  MOVFF  88,FEF
1504:  MOVFF  89,FEC
1508:  MOVFF  8A,FEC
150C:  MOVFF  8B,FEC
1510:  RETURN 0
1512:  MOVF   FE9,W
1514:  MOVWF  x78
1516:  MOVF   x77,W
1518:  MOVWF  x7A
151A:  BZ    154E
151C:  MOVFF  76,85
1520:  MOVFF  75,84
1524:  MOVFF  74,83
1528:  MOVFF  73,82
152C:  CLRF   x89
152E:  CLRF   x88
1530:  MOVLW  20
1532:  MOVWF  x87
1534:  MOVLW  82
1536:  MOVWF  x86
1538:  RCALL  109E
153A:  MOVFF  03,76
153E:  MOVFF  02,75
1542:  MOVFF  01,74
1546:  MOVFF  00,73
154A:  DECFSZ x7A,F
154C:  BRA    151C
154E:  MOVFF  76,83
1552:  MOVFF  75,82
1556:  MOVFF  74,81
155A:  MOVFF  73,80
155E:  RCALL  1446
1560:  MOVFF  03,76
1564:  MOVFF  02,75
1568:  MOVFF  01,74
156C:  MOVFF  00,73
1570:  BTFSS  x76.7
1572:  BRA    158E
1574:  DECF   x78,F
1576:  BSF    x78.5
1578:  COMF   x73,F
157A:  COMF   x74,F
157C:  COMF   x75,F
157E:  COMF   x76,F
1580:  INCF   x73,F
1582:  BTFSC  FD8.2
1584:  INCF   x74,F
1586:  BTFSC  FD8.2
1588:  INCF   x75,F
158A:  BTFSC  FD8.2
158C:  INCF   x76,F
158E:  MOVLW  3B
1590:  MOVWF  x7F
1592:  MOVLW  9A
1594:  MOVWF  x7E
1596:  MOVLW  CA
1598:  MOVWF  x7D
159A:  CLRF   x7C
159C:  MOVLW  0A
159E:  MOVWF  x7A
15A0:  MOVF   x77,W
15A2:  BTFSC  FD8.2
15A4:  INCF   x78,F
15A6:  BSF    FD8.1
15A8:  CLRF   FEA
15AA:  MOVLW  73
15AC:  MOVWF  FE9
15AE:  MOVFF  76,83
15B2:  MOVFF  75,82
15B6:  MOVFF  74,81
15BA:  MOVFF  73,80
15BE:  MOVFF  7F,87
15C2:  MOVFF  7E,86
15C6:  MOVFF  7D,85
15CA:  MOVFF  7C,84
15CE:  RCALL  1484
15D0:  MOVF   01,W
15D2:  MOVF   00,F
15D4:  BNZ   15F4
15D6:  INCF   x77,W
15D8:  SUBWF  x7A,W
15DA:  BZ    15F4
15DC:  MOVF   x78,W
15DE:  BZ    15F8
15E0:  ANDLW  0F
15E2:  SUBWF  x7A,W
15E4:  BZ    15E8
15E6:  BC    165E
15E8:  BTFSC  x78.7
15EA:  BRA    165E
15EC:  BTFSC  x78.6
15EE:  BRA    15F8
15F0:  MOVLW  20
15F2:  BRA    1654
15F4:  MOVLW  20
15F6:  ANDWF  x78,F
15F8:  BTFSS  x78.5
15FA:  BRA    1616
15FC:  BCF    x78.5
15FE:  MOVF   x77,W
1600:  BTFSS  FD8.2
1602:  DECF   x78,F
1604:  MOVF   00,W
1606:  MOVWF  x78
1608:  MOVLW  2D
160A:  MOVWF  x80
160C:  CALL   06C8
1610:  MOVF   x78,W
1612:  MOVWF  00
1614:  CLRF   x78
1616:  MOVF   x77,W
1618:  SUBWF  x7A,W
161A:  BNZ   1632
161C:  MOVF   00,W
161E:  MOVWF  x78
1620:  MOVLW  2E
1622:  MOVWF  x80
1624:  CALL   06C8
1628:  MOVF   x78,W
162A:  MOVWF  00
162C:  MOVLW  20
162E:  ANDWF  x78,F
1630:  MOVLW  00
1632:  MOVLW  30
1634:  BTFSS  x78.5
1636:  BRA    1654
1638:  BCF    x78.5
163A:  MOVF   x77,W
163C:  BTFSS  FD8.2
163E:  DECF   x78,F
1640:  MOVF   00,W
1642:  MOVWF  x78
1644:  MOVLW  2D
1646:  MOVWF  x80
1648:  CALL   06C8
164C:  MOVF   x78,W
164E:  MOVWF  00
1650:  CLRF   x78
1652:  MOVLW  30
1654:  ADDWF  00,F
1656:  MOVFF  00,80
165A:  CALL   06C8
165E:  BCF    FD8.1
1660:  MOVFF  7F,83
1664:  MOVFF  7E,82
1668:  MOVFF  7D,81
166C:  MOVFF  7C,80
1670:  CLRF   x87
1672:  CLRF   x86
1674:  CLRF   x85
1676:  MOVLW  0A
1678:  MOVWF  x84
167A:  RCALL  1484
167C:  MOVFF  03,7F
1680:  MOVFF  02,7E
1684:  MOVFF  01,7D
1688:  MOVFF  00,7C
168C:  DECFSZ x7A,F
168E:  BRA    15A6
1690:  RETURN 0
*
1854:  TBLRD*+
1856:  MOVF   FF5,F
1858:  BZ    1874
185A:  MOVFF  FF6,73
185E:  MOVFF  FF7,74
1862:  MOVF   FF5,W
1864:  BTFSS  F9E.4
1866:  BRA    1864
1868:  MOVWF  FAD
186A:  MOVFF  73,FF6
186E:  MOVFF  74,FF7
1872:  BRA    1854
1874:  RETURN 0
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
*
11C6:  CLRF   x7A
11C8:  CLRF   x79
11CA:  CLRF   x78
11CC:  MOVLW  7F
11CE:  MOVWF  x77
11D0:  CLRF   x7E
11D2:  CLRF   x7D
11D4:  CLRF   x7C
11D6:  CLRF   x7B
11D8:  BSF    x7F.0
11DA:  BCF    x7F.1
11DC:  BCF    x7F.2
11DE:  CLRF   x81
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
11E0:  MOVF   x73,W
11E2:  IORWF  x74,W
11E4:  BNZ   11F0
....................       return 0; 
11E6:  CLRF   00
11E8:  CLRF   01
11EA:  CLRF   02
11EC:  CLRF   03
11EE:  BRA    13FC
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
11F0:  MOVF   x81,W
11F2:  INCF   x81,F
11F4:  CLRF   03
11F6:  ADDWF  x73,W
11F8:  MOVWF  FE9
11FA:  MOVF   x74,W
11FC:  ADDWFC 03,W
11FE:  MOVWF  FEA
1200:  MOVFF  FEF,80
1204:  MOVF   x80,F
1206:  BTFSC  FD8.2
1208:  BRA    1386
....................    { 
....................       if (skip && !isspace(c)) 
120A:  BTFSS  x7F.0
120C:  BRA    122C
120E:  MOVF   x80,W
1210:  SUBLW  20
1212:  BZ    122C
....................       { 
....................          skip = 0; 
1214:  BCF    x7F.0
....................          if (c == '+') 
1216:  MOVF   x80,W
1218:  SUBLW  2B
121A:  BNZ   1222
....................          { 
....................             sign = 0; 
121C:  BCF    x7F.1
....................             continue; 
121E:  BRA    1370
....................          }             
1220:  BRA    122C
....................          else if (c == '-') 
1222:  MOVF   x80,W
1224:  SUBLW  2D
1226:  BNZ   122C
....................          { 
....................             sign = 1; 
1228:  BSF    x7F.1
....................             continue; 
122A:  BRA    1370
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
122C:  BTFSC  x7F.0
122E:  BRA    123E
1230:  MOVF   x80,W
1232:  SUBLW  2E
1234:  BNZ   123E
1236:  BTFSC  x7F.2
1238:  BRA    123E
....................          point = 1; 
123A:  BSF    x7F.2
123C:  BRA    1370
....................       else if (!skip && isdigit(c)) 
123E:  BTFSC  x7F.0
1240:  BRA    136A
1242:  MOVF   x80,W
1244:  SUBLW  2F
1246:  BTFSC  FD8.0
1248:  BRA    136A
124A:  MOVF   x80,W
124C:  SUBLW  39
124E:  BTFSS  FD8.0
1250:  BRA    136A
....................       { 
....................          c -= '0'; 
1252:  MOVLW  30
1254:  SUBWF  x80,F
....................          if (point) 
1256:  BTFSS  x7F.2
1258:  BRA    12FC
....................          { 
....................             pow10 = pow10 * 10.0; 
125A:  MOVFF  7A,85
125E:  MOVFF  79,84
1262:  MOVFF  78,83
1266:  MOVFF  77,82
126A:  CLRF   x89
126C:  CLRF   x88
126E:  MOVLW  20
1270:  MOVWF  x87
1272:  MOVLW  82
1274:  MOVWF  x86
1276:  RCALL  109E
1278:  MOVFF  03,7A
127C:  MOVFF  02,79
1280:  MOVFF  01,78
1284:  MOVFF  00,77
....................             result += (float)c / pow10;    
1288:  CLRF   x87
128A:  MOVFF  80,86
128E:  RCALL  1190
1290:  MOVFF  03,85
1294:  MOVFF  02,84
1298:  MOVFF  01,83
129C:  MOVFF  00,82
12A0:  MOVFF  03,89
12A4:  MOVFF  02,88
12A8:  MOVFF  01,87
12AC:  MOVFF  00,86
12B0:  MOVFF  7A,8D
12B4:  MOVFF  79,8C
12B8:  MOVFF  78,8B
12BC:  MOVFF  77,8A
12C0:  CALL   08DA
12C4:  BCF    FD8.1
12C6:  MOVFF  7E,89
12CA:  MOVFF  7D,88
12CE:  MOVFF  7C,87
12D2:  MOVFF  7B,86
12D6:  MOVFF  03,8D
12DA:  MOVFF  02,8C
12DE:  MOVFF  01,8B
12E2:  MOVFF  00,8A
12E6:  CALL   0AAA
12EA:  MOVFF  03,7E
12EE:  MOVFF  02,7D
12F2:  MOVFF  01,7C
12F6:  MOVFF  00,7B
....................          } 
12FA:  BRA    1368
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
12FC:  CLRF   x85
12FE:  CLRF   x84
1300:  MOVLW  20
1302:  MOVWF  x83
1304:  MOVLW  82
1306:  MOVWF  x82
1308:  MOVFF  7E,89
130C:  MOVFF  7D,88
1310:  MOVFF  7C,87
1314:  MOVFF  7B,86
1318:  RCALL  109E
131A:  MOVFF  03,85
131E:  MOVFF  02,84
1322:  MOVFF  01,83
1326:  MOVFF  00,82
132A:  CLRF   x87
132C:  MOVFF  80,86
1330:  RCALL  1190
1332:  BCF    FD8.1
1334:  MOVFF  85,89
1338:  MOVFF  84,88
133C:  MOVFF  83,87
1340:  MOVFF  82,86
1344:  MOVFF  03,8D
1348:  MOVFF  02,8C
134C:  MOVFF  01,8B
1350:  MOVFF  00,8A
1354:  CALL   0AAA
1358:  MOVFF  03,7E
135C:  MOVFF  02,7D
1360:  MOVFF  01,7C
1364:  MOVFF  00,7B
....................          } 
....................       } 
1368:  BRA    1370
....................       else if (!skip) 
136A:  BTFSC  x7F.0
136C:  BRA    1370
....................          break; 
136E:  BRA    1386
1370:  MOVF   x81,W
1372:  INCF   x81,F
1374:  CLRF   03
1376:  ADDWF  x73,W
1378:  MOVWF  FE9
137A:  MOVF   x74,W
137C:  ADDWFC 03,W
137E:  MOVWF  FEA
1380:  MOVFF  FEF,80
1384:  BRA    1204
....................    } 
....................  
....................    if (sign) 
1386:  BTFSS  x7F.1
1388:  BRA    13B8
....................       result = -1*result; 
138A:  CLRF   x85
138C:  CLRF   x84
138E:  MOVLW  80
1390:  MOVWF  x83
1392:  MOVLW  7F
1394:  MOVWF  x82
1396:  MOVFF  7E,89
139A:  MOVFF  7D,88
139E:  MOVFF  7C,87
13A2:  MOVFF  7B,86
13A6:  RCALL  109E
13A8:  MOVFF  03,7E
13AC:  MOVFF  02,7D
13B0:  MOVFF  01,7C
13B4:  MOVFF  00,7B
....................        
....................    if(endptr) 
13B8:  MOVF   x75,W
13BA:  IORWF  x76,W
13BC:  BZ    13EC
....................    { 
....................       if (ptr) { 
13BE:  MOVF   x81,F
13C0:  BZ    13DA
....................          ptr--; 
13C2:  DECF   x81,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
13C4:  MOVFF  75,FE9
13C8:  MOVFF  76,FEA
13CC:  MOVF   x81,W
13CE:  ADDWF  x73,W
13D0:  MOVWF  FEF
13D2:  MOVLW  00
13D4:  ADDWFC x74,W
13D6:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
13D8:  BRA    13EC
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
13DA:  MOVFF  75,FE9
13DE:  MOVFF  76,FEA
13E2:  MOVFF  74,FEC
13E6:  MOVF   FED,F
13E8:  MOVFF  73,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
13EC:  MOVFF  7B,00
13F0:  MOVFF  7C,01
13F4:  MOVFF  7D,02
13F8:  MOVFF  7E,03
13FC:  RETURN 0
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,PLL5,CPUDIV1,VREGEN,MCLR,USBDIV,  // 48 MHz  para  el  USB y 48 MHz para  el resto del sistema 
.................... #use delay(clock=48000000) 
*
0172:  CLRF   FEA
0174:  MOVLW  96
0176:  MOVWF  FE9
0178:  MOVF   FEF,W
017A:  BZ    0198
017C:  MOVLW  0F
017E:  MOVWF  01
0180:  CLRF   00
0182:  DECFSZ 00,F
0184:  BRA    0182
0186:  DECFSZ 01,F
0188:  BRA    0180
018A:  MOVLW  8F
018C:  MOVWF  00
018E:  DECFSZ 00,F
0190:  BRA    018E
0192:  NOP   
0194:  DECFSZ FEF,F
0196:  BRA    017C
0198:  RETURN 0
019A:  MOVLW  01
019C:  SUBWF  x96,F
019E:  BNC   01B8
01A0:  CLRF   FEA
01A2:  MOVLW  96
01A4:  MOVWF  FE9
01A6:  MOVF   FEF,W
01A8:  BZ    01B8
01AA:  MOVLW  02
01AC:  MOVWF  00
01AE:  DECFSZ 00,F
01B0:  BRA    01AE
01B2:  BRA    01B4
01B4:  DECFSZ FEF,F
01B6:  BRA    01AA
01B8:  RETURN 0
.................... #use rs232(baud=9600, xmit=pin_c6, rcv=pin_c7, bits=8, parity=N,stream=standard)  
*
0158:  BTFSS  F9E.4
015A:  BRA    0158
015C:  MOVWF  FAD
015E:  RETURN 0
.................... #include <LCD420-FLEX.c> 
.................... // Flex_LCD420.c 
....................  
.................... // These pins are for my Microchip PicDem2-Plus board, 
.................... // which I used to test this driver. 
.................... // An external 20x4 LCD is connected to these pins. 
.................... // Change these pins to match your own board's connections. 
.................... /* 
.................... #define LCD_DB4   PIN_B4 
.................... #define LCD_DB5   PIN_B5 
.................... #define LCD_DB6   PIN_B6 
.................... #define LCD_DB7   PIN_B7 
....................  
.................... #define LCD_RS    PIN_B3 
.................... //#define LCD_RW    PIN_B0 it is earthed at the display 
.................... #define LCD_E     PIN_B2 
.................... */ 
....................  
.................... // To prove that the driver can be used with random 
.................... // pins, I also tested it with these pins: 
.................... #define LCD_DB4   PIN_B4 
.................... #define LCD_DB5   PIN_B5 
.................... #define LCD_DB6   PIN_B6 
.................... #define LCD_DB7   PIN_B7 
....................  
.................... #define LCD_RS    PIN_C2 
.................... //#define LCD_RW    PIN_B1 
.................... #define LCD_E     PIN_B3 
....................  
....................  
.................... // If you want only a 6-pin interface to your LCD, then 
.................... // connect the R/W pin on the LCD to ground, and comment 
.................... // out the following line.  Doing so will save one PIC 
.................... // pin, but at the cost of losing the ability to read from 
.................... // the LCD.  It also makes the write time a little longer 
.................... // because a static delay must be used, instead of polling 
.................... // the LCD's busy bit.  Normally a 6-pin interface is only 
.................... // used if you are running out of PIC pins, and you need 
.................... // to use as few as possible for the LCD. 
....................  
.................... //#define USE_RW_PIN   1      
....................  
....................  
.................... // These are the line addresses for most 4x20 LCDs. 
.................... #define LCD_LINE_1_ADDRESS 0x00 
.................... #define LCD_LINE_2_ADDRESS 0x40 
.................... #define LCD_LINE_3_ADDRESS 0x14 
.................... #define LCD_LINE_4_ADDRESS 0x54 
....................  
.................... // These are the line addresses for LCD's which use 
.................... // the Hitachi HD66712U controller chip. 
.................... /* 
.................... #define LCD_LINE_1_ADDRESS 0x00 
.................... #define LCD_LINE_2_ADDRESS 0x20 
.................... #define LCD_LINE_3_ADDRESS 0x40 
.................... #define LCD_LINE_4_ADDRESS 0x60 
.................... */ 
....................  
....................  
.................... //======================================== 
....................  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more) 
....................  
.................... int8 lcd_line; 
....................  
.................... int8 const LCD_INIT_STRING[4] = 
.................... { 
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots 
....................  0xc,                     // Display on 
....................  1,                       // Clear display 
....................  6                        // Increment cursor 
....................  }; 
....................                               
....................  
.................... //------------------------------------- 
.................... void lcd_send_nibble(int8 nibble) 
.................... { 
.................... // Note:  !! converts an integer expression 
.................... // to a boolean (1 or 0). 
....................  output_bit(LCD_DB4, !!(nibble & 1)); 
*
0574:  BTFSC  x88.0
0576:  BRA    057C
0578:  BCF    F8A.4
057A:  BRA    057E
057C:  BSF    F8A.4
057E:  BCF    F93.4
....................  output_bit(LCD_DB5, !!(nibble & 2));  
0580:  BTFSC  x88.1
0582:  BRA    0588
0584:  BCF    F8A.5
0586:  BRA    058A
0588:  BSF    F8A.5
058A:  BCF    F93.5
....................  output_bit(LCD_DB6, !!(nibble & 4));    
058C:  BTFSC  x88.2
058E:  BRA    0594
0590:  BCF    F8A.6
0592:  BRA    0596
0594:  BSF    F8A.6
0596:  BCF    F93.6
....................  output_bit(LCD_DB7, !!(nibble & 8));    
0598:  BTFSC  x88.3
059A:  BRA    05A0
059C:  BCF    F8A.7
059E:  BRA    05A2
05A0:  BSF    F8A.7
05A2:  BCF    F93.7
....................  
....................  delay_us(2); 
05A4:  MOVLW  07
05A6:  MOVWF  00
05A8:  DECFSZ 00,F
05AA:  BRA    05A8
05AC:  BRA    05AE
....................  output_high(LCD_E); 
05AE:  BCF    F93.3
05B0:  BSF    F8A.3
....................  delay_us(2); 
05B2:  MOVLW  07
05B4:  MOVWF  00
05B6:  DECFSZ 00,F
05B8:  BRA    05B6
05BA:  BRA    05BC
....................  output_low(LCD_E); 
05BC:  BCF    F93.3
05BE:  BCF    F8A.3
05C0:  RETURN 0
.................... } 
....................  
.................... //----------------------------------- 
.................... // This sub-routine is only called by lcd_read_byte(). 
.................... // It's not a stand-alone routine.  For example, the 
.................... // R/W signal is set high by lcd_read_byte() before 
.................... // this routine is called.      
....................  
.................... #ifdef USE_RW_PIN 
.................... int8 lcd_read_nibble(void) 
.................... { 
.................... int8 retval; 
.................... // Create bit variables so that we can easily set 
.................... // individual bits in the retval variable. 
.................... #bit retval_0 = retval.0 
.................... #bit retval_1 = retval.1 
.................... #bit retval_2 = retval.2 
.................... #bit retval_3 = retval.3 
....................  
.................... retval = 0; 
....................     
.................... output_high(LCD_E); 
.................... delay_us(1); 
....................  
.................... retval_0 = input(LCD_DB4); 
.................... retval_1 = input(LCD_DB5); 
.................... retval_2 = input(LCD_DB6); 
.................... retval_3 = input(LCD_DB7); 
....................   
.................... output_low(LCD_E); 
.................... delay_us(1); 
....................     
.................... return(retval);    
.................... }    
.................... #endif 
....................  
.................... //--------------------------------------- 
.................... // Read a byte from the LCD and return it. 
....................  
.................... #ifdef USE_RW_PIN 
.................... int8 lcd_read_byte(void) 
.................... { 
.................... int8 low; 
.................... int8 high; 
....................  
.................... output_high(LCD_RW); 
.................... delay_cycles(1); 
....................  
.................... high = lcd_read_nibble(); 
....................  
.................... low = lcd_read_nibble(); 
....................  
.................... return( (high<<4) | low); 
.................... } 
.................... #endif 
....................  
.................... //---------------------------------------- 
.................... // Send a byte to the LCD. 
.................... void lcd_send_byte(int8 address, int8 n) 
.................... { 
.................... output_low(LCD_RS); 
05C2:  BCF    F94.2
05C4:  BCF    F8B.2
....................  
.................... #ifdef USE_RW_PIN 
.................... while(bit_test(lcd_read_byte(),7)) ; 
.................... #else 
.................... delay_us(60);  
05C6:  MOVLW  EF
05C8:  MOVWF  00
05CA:  DECFSZ 00,F
05CC:  BRA    05CA
05CE:  BRA    05D0
.................... #endif 
....................  
.................... if(address) 
05D0:  MOVF   x85,F
05D2:  BZ    05DA
....................    output_high(LCD_RS); 
05D4:  BCF    F94.2
05D6:  BSF    F8B.2
05D8:  BRA    05DE
.................... else 
....................    output_low(LCD_RS); 
05DA:  BCF    F94.2
05DC:  BCF    F8B.2
....................       
....................  //delay_cycles(1); 
.................... delay_us(2); 
05DE:  MOVLW  07
05E0:  MOVWF  00
05E2:  DECFSZ 00,F
05E4:  BRA    05E2
05E6:  BRA    05E8
....................  
.................... #ifdef USE_RW_PIN 
.................... output_low(LCD_RW); 
.................... delay_cycles(1); 
.................... #endif 
....................  
.................... output_low(LCD_E); 
05E8:  BCF    F93.3
05EA:  BCF    F8A.3
....................  
.................... lcd_send_nibble(n >> 4); 
05EC:  SWAPF  x86,W
05EE:  MOVWF  x87
05F0:  MOVLW  0F
05F2:  ANDWF  x87,F
05F4:  MOVFF  87,88
05F8:  RCALL  0574
.................... lcd_send_nibble(n & 0xf); 
05FA:  MOVF   x86,W
05FC:  ANDLW  0F
05FE:  MOVWF  x87
0600:  MOVWF  x88
0602:  RCALL  0574
0604:  RETURN 0
.................... } 
.................... //---------------------------- 
....................  
.................... void lcd_init(void) 
.................... { 
.................... int8 i; 
....................  
.................... lcd_line = 1; 
0606:  MOVLW  01
0608:  MOVWF  1D
....................  
.................... output_low(LCD_RS); 
060A:  BCF    F94.2
060C:  BCF    F8B.2
....................  
.................... #ifdef USE_RW_PIN 
.................... output_low(LCD_RW); 
.................... #endif 
....................  
.................... output_low(LCD_E); 
060E:  BCF    F93.3
0610:  BCF    F8A.3
0612:  CLRF   16
0614:  BTFSC  FF2.7
0616:  BSF    16.7
0618:  BCF    FF2.7
....................  
.................... // Some LCDs require 15 ms minimum delay after 
.................... // power-up.  Others require 30 ms.  I'm going 
.................... // to set it to 35 ms, so it should work with 
.................... // all of them. 
.................... delay_ms(35);          
061A:  MOVLW  23
061C:  MOVWF  x96
061E:  RCALL  0172
0620:  BTFSC  16.7
0622:  BSF    FF2.7
....................  
.................... for(i=0 ;i < 3; i++) 
0624:  CLRF   x73
0626:  MOVF   x73,W
0628:  SUBLW  02
062A:  BNC   0648
....................    { 
....................     lcd_send_nibble(0x03); 
062C:  MOVLW  03
062E:  MOVWF  x88
0630:  RCALL  0574
0632:  CLRF   16
0634:  BTFSC  FF2.7
0636:  BSF    16.7
0638:  BCF    FF2.7
....................     delay_ms(5); 
063A:  MOVLW  05
063C:  MOVWF  x96
063E:  RCALL  0172
0640:  BTFSC  16.7
0642:  BSF    FF2.7
0644:  INCF   x73,F
0646:  BRA    0626
....................    } 
....................  
.................... lcd_send_nibble(0x02); 
0648:  MOVLW  02
064A:  MOVWF  x88
064C:  RCALL  0574
....................  
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++) 
064E:  CLRF   x73
0650:  MOVF   x73,W
0652:  SUBLW  03
0654:  BNC   0684
....................    { 
....................     lcd_send_byte(0, LCD_INIT_STRING[i]); 
0656:  CLRF   03
0658:  MOVF   x73,W
065A:  MOVFF  FF2,74
065E:  BCF    FF2.7
0660:  RCALL  00BA
0662:  BTFSC  x74.7
0664:  BSF    FF2.7
0666:  MOVWF  x74
0668:  CLRF   x85
066A:  MOVWF  x86
066C:  RCALL  05C2
066E:  CLRF   16
0670:  BTFSC  FF2.7
0672:  BSF    16.7
0674:  BCF    FF2.7
....................     
....................     // If the R/W signal is not used, then 
....................     // the busy bit can't be polled.  One of 
....................     // the init commands takes longer than 
....................     // the hard-coded delay of 50 us, so in 
....................     // that case, lets just do a 5 ms delay 
....................     // after all four of them. 
....................     #ifndef USE_RW_PIN 
....................     delay_ms(5); 
0676:  MOVLW  05
0678:  MOVWF  x96
067A:  RCALL  0172
067C:  BTFSC  16.7
067E:  BSF    FF2.7
....................     #endif 
0680:  INCF   x73,F
0682:  BRA    0650
....................    } 
0684:  GOTO   19B8 (RETURN)
....................  
.................... } 
....................  
.................... //---------------------------- 
....................  
.................... void lcd_gotoxy(int8 x, int8 y) 
.................... { 
.................... int8 address; 
....................  
....................  
.................... switch(y) 
0688:  MOVF   x82,W
068A:  XORLW  01
068C:  BZ    069C
068E:  XORLW  03
0690:  BZ    06A0
0692:  XORLW  01
0694:  BZ    06A6
0696:  XORLW  07
0698:  BZ    06AC
069A:  BRA    06B2
....................   { 
....................    case 1: 
....................      address = LCD_LINE_1_ADDRESS; 
069C:  CLRF   x83
....................      break; 
069E:  BRA    06B4
....................  
....................    case 2: 
....................      address = LCD_LINE_2_ADDRESS; 
06A0:  MOVLW  40
06A2:  MOVWF  x83
....................      break; 
06A4:  BRA    06B4
....................  
....................    case 3: 
....................      address = LCD_LINE_3_ADDRESS; 
06A6:  MOVLW  14
06A8:  MOVWF  x83
....................      break; 
06AA:  BRA    06B4
....................  
....................    case 4: 
....................      address = LCD_LINE_4_ADDRESS; 
06AC:  MOVLW  54
06AE:  MOVWF  x83
....................      break; 
06B0:  BRA    06B4
....................  
....................    default: 
....................      address = LCD_LINE_1_ADDRESS; 
06B2:  CLRF   x83
....................      break; 
....................       
....................   } 
....................  
.................... address += x-1; 
06B4:  MOVLW  01
06B6:  SUBWF  x81,W
06B8:  ADDWF  x83,F
.................... lcd_send_byte(0, 0x80 | address); 
06BA:  MOVF   x83,W
06BC:  IORLW  80
06BE:  MOVWF  x84
06C0:  CLRF   x85
06C2:  MOVWF  x86
06C4:  RCALL  05C2
06C6:  RETURN 0
.................... } 
....................  
.................... //----------------------------- 
.................... void lcd_putc(char c) 
.................... { 
....................  switch(c) 
06C8:  MOVF   x80,W
06CA:  XORLW  0C
06CC:  BZ    06D8
06CE:  XORLW  06
06D0:  BZ    06F8
06D2:  XORLW  02
06D4:  BZ    0706
06D6:  BRA    0710
....................    { 
....................     case '\f': 
....................       lcd_send_byte(0,1); 
06D8:  CLRF   x85
06DA:  MOVLW  01
06DC:  MOVWF  x86
06DE:  RCALL  05C2
....................       lcd_line = 1; 
06E0:  MOVLW  01
06E2:  MOVWF  1D
06E4:  CLRF   16
06E6:  BTFSC  FF2.7
06E8:  BSF    16.7
06EA:  BCF    FF2.7
....................       delay_ms(2); 
06EC:  MOVLW  02
06EE:  MOVWF  x96
06F0:  RCALL  0172
06F2:  BTFSC  16.7
06F4:  BSF    FF2.7
....................       break; 
06F6:  BRA    071A
....................     
....................     case '\n': 
....................        lcd_gotoxy(1, ++lcd_line); 
06F8:  INCF   1D,F
06FA:  MOVLW  01
06FC:  MOVWF  x81
06FE:  MOVFF  1D,82
0702:  RCALL  0688
....................        break; 
0704:  BRA    071A
....................     
....................     case '\b': 
....................        lcd_send_byte(0,0x10); 
0706:  CLRF   x85
0708:  MOVLW  10
070A:  MOVWF  x86
070C:  RCALL  05C2
....................        break; 
070E:  BRA    071A
....................     
....................     default: 
....................        lcd_send_byte(1,c); 
0710:  MOVLW  01
0712:  MOVWF  x85
0714:  MOVFF  80,86
0718:  RCALL  05C2
....................        break; 
....................    } 
071A:  RETURN 0
.................... } 
....................  
.................... //------------------------------ 
.................... #ifdef USE_RW_PIN 
.................... char lcd_getc(int8 x, int8 y) 
.................... { 
.................... char value; 
....................  
.................... lcd_gotoxy(x,y); 
....................  
.................... // Wait until busy flag is low. 
.................... while(bit_test(lcd_read_byte(),7));  
....................  
.................... output_high(LCD_RS); 
.................... value = lcd_read_byte(); 
.................... output_low(LCD_RS); 
....................  
.................... return(value); 
.................... } 
.................... #endif 
....................  
.................... #include <MATH.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define sentidox PIN_D0 
.................... #define sentidoy PIN_D1 
.................... #define sentidoz PIN_D2 
.................... #define motorx PIN_D3 
.................... #define motory PIN_D4 
.................... #define motorz PIN_D5 
.................... #define cerox PIN_D6 
.................... #define ceroy PIN_D7 
.................... #define ceroz PIN_C0 
.................... #define profunz PIN_C1 
.................... #define dremel PIN_E0 
.................... #define enter PIN_E1 
.................... #define habilx PIN_E2 
.................... #define habily PIN_A0 
.................... #define habilz PIN_A1 
.................... #define canalb PIN_A2 
....................  
.................... char ch; 
.................... char mech[5]; 
.................... char datox[7]; 
.................... char datoy[7]; 
.................... int i, j, h, flagfin, salir; 
.................... int contador; 
.................... signed int32 x, y, xini, yini, pasosx, pasosy; 
.................... float broca, pasosxflot, pasosyflot; 
.................... int flagx, flagy, flagxy, flagcomienzo, flagmecha, flagboton; 
.................... short int flagpaquete, flagajuste; 
.................... signed int32 pasosz, zini, z, alturamecha; 
....................  
.................... void moverz(void) 
.................... { 
....................     output_low(habilz); 
*
1738:  BCF    F92.1
173A:  BCF    F89.1
....................     pasosz = z - zini; 
173C:  MOVF   x67,W
173E:  SUBWF  x6B,W
1740:  MOVWF  x63
1742:  MOVF   x68,W
1744:  SUBWFB x6C,W
1746:  MOVWF  x64
1748:  MOVF   x69,W
174A:  SUBWFB x6D,W
174C:  MOVWF  x65
174E:  MOVF   x6A,W
1750:  SUBWFB x6E,W
1752:  MOVWF  x66
....................  
....................     while (pasosz > 0) 
1754:  BTFSC  x66.7
1756:  BRA    17D4
1758:  MOVF   x66,F
175A:  BNZ   176A
175C:  MOVF   x65,F
175E:  BNZ   176A
1760:  MOVF   x64,F
1762:  BNZ   176A
1764:  MOVF   x63,W
1766:  SUBLW  00
1768:  BC    17D4
....................     { 
....................         output_high(sentidoz); //para abajo 
176A:  BCF    F95.2
176C:  BSF    F8C.2
....................         output_high(motorz); 
176E:  BCF    F95.5
1770:  BSF    F8C.5
....................         delay_us(1200); 
1772:  CLRF   16
1774:  BTFSC  FF2.7
1776:  BSF    16.7
1778:  BCF    FF2.7
177A:  MOVLW  01
177C:  MOVWF  x96
177E:  CALL   0172
1782:  BTFSC  16.7
1784:  BSF    FF2.7
1786:  CLRF   16
1788:  BTFSC  FF2.7
178A:  BSF    16.7
178C:  BCF    FF2.7
178E:  MOVLW  C8
1790:  MOVWF  x96
1792:  CALL   019A
1796:  BTFSC  16.7
1798:  BSF    FF2.7
....................         output_low(motorz); 
179A:  BCF    F95.5
179C:  BCF    F8C.5
....................         delay_us(1200); 
179E:  CLRF   16
17A0:  BTFSC  FF2.7
17A2:  BSF    16.7
17A4:  BCF    FF2.7
17A6:  MOVLW  01
17A8:  MOVWF  x96
17AA:  CALL   0172
17AE:  BTFSC  16.7
17B0:  BSF    FF2.7
17B2:  CLRF   16
17B4:  BTFSC  FF2.7
17B6:  BSF    16.7
17B8:  BCF    FF2.7
17BA:  MOVLW  C8
17BC:  MOVWF  x96
17BE:  CALL   019A
17C2:  BTFSC  16.7
17C4:  BSF    FF2.7
....................         pasosz = pasosz - 1; 
17C6:  MOVLW  01
17C8:  SUBWF  x63,F
17CA:  MOVLW  00
17CC:  SUBWFB x64,F
17CE:  SUBWFB x65,F
17D0:  SUBWFB x66,F
17D2:  BRA    1754
....................     } 
....................     while (pasosz < 0) 
17D4:  BTFSS  x66.7
17D6:  BRA    1842
....................     { 
....................         output_low(sentidoz); //para arriba 
17D8:  BCF    F95.2
17DA:  BCF    F8C.2
....................         output_high(motorz); 
17DC:  BCF    F95.5
17DE:  BSF    F8C.5
....................         delay_us(1200); 
17E0:  CLRF   16
17E2:  BTFSC  FF2.7
17E4:  BSF    16.7
17E6:  BCF    FF2.7
17E8:  MOVLW  01
17EA:  MOVWF  x96
17EC:  CALL   0172
17F0:  BTFSC  16.7
17F2:  BSF    FF2.7
17F4:  CLRF   16
17F6:  BTFSC  FF2.7
17F8:  BSF    16.7
17FA:  BCF    FF2.7
17FC:  MOVLW  C8
17FE:  MOVWF  x96
1800:  CALL   019A
1804:  BTFSC  16.7
1806:  BSF    FF2.7
....................         output_low(motorz); 
1808:  BCF    F95.5
180A:  BCF    F8C.5
....................         delay_us(1200); 
180C:  CLRF   16
180E:  BTFSC  FF2.7
1810:  BSF    16.7
1812:  BCF    FF2.7
1814:  MOVLW  01
1816:  MOVWF  x96
1818:  CALL   0172
181C:  BTFSC  16.7
181E:  BSF    FF2.7
1820:  CLRF   16
1822:  BTFSC  FF2.7
1824:  BSF    16.7
1826:  BCF    FF2.7
1828:  MOVLW  C8
182A:  MOVWF  x96
182C:  CALL   019A
1830:  BTFSC  16.7
1832:  BSF    FF2.7
....................         pasosz = pasosz + 1; 
1834:  MOVLW  01
1836:  ADDWF  x63,F
1838:  MOVLW  00
183A:  ADDWFC x64,F
183C:  ADDWFC x65,F
183E:  ADDWFC x66,F
1840:  BRA    17D4
....................     } 
....................     zini = z; 
1842:  MOVFF  6E,6A
1846:  MOVFF  6D,69
184A:  MOVFF  6C,68
184E:  MOVFF  6B,67
1852:  RETURN 0
.................... } 
....................  
.................... void bajarz(void) 
.................... { 
....................     while (pasosz > 0) 
....................     { //rutina que baja el cabezal 
....................         output_low(habilz); 
....................         pasosz = pasosz - 1; 
....................         output_high(sentidoz); 
....................         output_toggle(motorz); 
....................         delay_us(1200); 
....................     } 
.................... } 
....................  
.................... void subirz(void) 
.................... { 
....................     while (pasosz > 0) 
....................     { //rutina que sube el cabezal 
....................         output_low(sentidoz); 
....................         pasosz = pasosz - 1; 
....................         output_toggle(motorz); 
....................         delay_us(1200); 
....................     } 
.................... } 
....................  
.................... void conversionpasos(void) 
.................... { 
....................     pasosxflot = (x - xini) / 200.0; 
*
0DA0:  MOVF   40,W
0DA2:  SUBWF  38,W
0DA4:  MOVWF  x73
0DA6:  MOVF   41,W
0DA8:  SUBWFB 39,W
0DAA:  MOVWF  x74
0DAC:  MOVF   42,W
0DAE:  SUBWFB 3A,W
0DB0:  MOVWF  x75
0DB2:  MOVF   43,W
0DB4:  SUBWFB 3B,W
0DB6:  MOVWF  x76
0DB8:  MOVWF  x7A
0DBA:  MOVFF  75,79
0DBE:  MOVFF  74,78
0DC2:  MOVFF  73,77
0DC6:  RCALL  0884
0DC8:  MOVFF  03,89
0DCC:  MOVFF  02,88
0DD0:  MOVFF  01,87
0DD4:  MOVFF  00,86
0DD8:  CLRF   x8D
0DDA:  CLRF   x8C
0DDC:  MOVLW  48
0DDE:  MOVWF  x8B
0DE0:  MOVLW  86
0DE2:  MOVWF  x8A
0DE4:  RCALL  08DA
0DE6:  MOVFF  03,57
0DEA:  MOVFF  02,56
0DEE:  MOVFF  01,55
0DF2:  MOVFF  00,54
....................     pasosyflot = (y - yini) / 200.0; 
0DF6:  MOVF   44,W
0DF8:  SUBWF  3C,W
0DFA:  MOVWF  x73
0DFC:  MOVF   45,W
0DFE:  SUBWFB 3D,W
0E00:  MOVWF  x74
0E02:  MOVF   46,W
0E04:  SUBWFB 3E,W
0E06:  MOVWF  x75
0E08:  MOVF   47,W
0E0A:  SUBWFB 3F,W
0E0C:  MOVWF  x76
0E0E:  MOVWF  x7A
0E10:  MOVFF  75,79
0E14:  MOVFF  74,78
0E18:  MOVFF  73,77
0E1C:  RCALL  0884
0E1E:  MOVFF  03,89
0E22:  MOVFF  02,88
0E26:  MOVFF  01,87
0E2A:  MOVFF  00,86
0E2E:  CLRF   x8D
0E30:  CLRF   x8C
0E32:  MOVLW  48
0E34:  MOVWF  x8B
0E36:  MOVLW  86
0E38:  MOVWF  x8A
0E3A:  RCALL  08DA
0E3C:  MOVFF  03,5B
0E40:  MOVFF  02,5A
0E44:  MOVFF  01,59
0E48:  MOVFF  00,58
....................     if (pasosxflot >= 0) 
0E4C:  CLRF   x76
0E4E:  CLRF   x75
0E50:  CLRF   x74
0E52:  CLRF   x73
0E54:  MOVFF  57,7A
0E58:  MOVFF  56,79
0E5C:  MOVFF  55,78
0E60:  MOVFF  54,77
0E64:  RCALL  0A34
0E66:  BC    0E6A
0E68:  BNZ   0EC0
....................         pasosx = (signed long int) (pasosxflot + 0.5); 
0E6A:  BCF    FD8.1
0E6C:  MOVFF  57,89
0E70:  MOVFF  56,88
0E74:  MOVFF  55,87
0E78:  MOVFF  54,86
0E7C:  CLRF   x8D
0E7E:  CLRF   x8C
0E80:  CLRF   x8B
0E82:  MOVLW  7E
0E84:  MOVWF  x8A
0E86:  RCALL  0AAA
0E88:  MOVFF  03,76
0E8C:  MOVFF  02,75
0E90:  MOVFF  01,74
0E94:  MOVFF  00,73
0E98:  RCALL  0D14
0E9A:  MOVFF  01,00
0E9E:  MOVFF  02,01
0EA2:  CLRF   02
0EA4:  CLRF   03
0EA6:  BTFSS  01.7
0EA8:  BRA    0EAE
0EAA:  DECF   02,F
0EAC:  DECF   03,F
0EAE:  MOVFF  03,4B
0EB2:  MOVFF  02,4A
0EB6:  MOVFF  01,49
0EBA:  MOVFF  00,48
0EBE:  BRA    0F14
....................     else 
....................         pasosx = (signed long int) (pasosxflot - 0.5); 
0EC0:  BSF    FD8.1
0EC2:  MOVFF  57,89
0EC6:  MOVFF  56,88
0ECA:  MOVFF  55,87
0ECE:  MOVFF  54,86
0ED2:  CLRF   x8D
0ED4:  CLRF   x8C
0ED6:  CLRF   x8B
0ED8:  MOVLW  7E
0EDA:  MOVWF  x8A
0EDC:  RCALL  0AAA
0EDE:  MOVFF  03,76
0EE2:  MOVFF  02,75
0EE6:  MOVFF  01,74
0EEA:  MOVFF  00,73
0EEE:  RCALL  0D14
0EF0:  MOVFF  01,00
0EF4:  MOVFF  02,01
0EF8:  CLRF   02
0EFA:  CLRF   03
0EFC:  BTFSS  01.7
0EFE:  BRA    0F04
0F00:  DECF   02,F
0F02:  DECF   03,F
0F04:  MOVFF  03,4B
0F08:  MOVFF  02,4A
0F0C:  MOVFF  01,49
0F10:  MOVFF  00,48
....................  
....................     if (pasosyflot >= 0) 
0F14:  CLRF   x76
0F16:  CLRF   x75
0F18:  CLRF   x74
0F1A:  CLRF   x73
0F1C:  MOVFF  5B,7A
0F20:  MOVFF  5A,79
0F24:  MOVFF  59,78
0F28:  MOVFF  58,77
0F2C:  RCALL  0A34
0F2E:  BC    0F32
0F30:  BNZ   0F88
....................         pasosy = (signed long int) (pasosyflot + 0.5); 
0F32:  BCF    FD8.1
0F34:  MOVFF  5B,89
0F38:  MOVFF  5A,88
0F3C:  MOVFF  59,87
0F40:  MOVFF  58,86
0F44:  CLRF   x8D
0F46:  CLRF   x8C
0F48:  CLRF   x8B
0F4A:  MOVLW  7E
0F4C:  MOVWF  x8A
0F4E:  RCALL  0AAA
0F50:  MOVFF  03,76
0F54:  MOVFF  02,75
0F58:  MOVFF  01,74
0F5C:  MOVFF  00,73
0F60:  RCALL  0D14
0F62:  MOVFF  01,00
0F66:  MOVFF  02,01
0F6A:  CLRF   02
0F6C:  CLRF   03
0F6E:  BTFSS  01.7
0F70:  BRA    0F76
0F72:  DECF   02,F
0F74:  DECF   03,F
0F76:  MOVFF  03,4F
0F7A:  MOVFF  02,4E
0F7E:  MOVFF  01,4D
0F82:  MOVFF  00,4C
0F86:  BRA    0FDC
....................     else 
....................         pasosy = (signed long int) (pasosyflot - 0.5); 
0F88:  BSF    FD8.1
0F8A:  MOVFF  5B,89
0F8E:  MOVFF  5A,88
0F92:  MOVFF  59,87
0F96:  MOVFF  58,86
0F9A:  CLRF   x8D
0F9C:  CLRF   x8C
0F9E:  CLRF   x8B
0FA0:  MOVLW  7E
0FA2:  MOVWF  x8A
0FA4:  RCALL  0AAA
0FA6:  MOVFF  03,76
0FAA:  MOVFF  02,75
0FAE:  MOVFF  01,74
0FB2:  MOVFF  00,73
0FB6:  RCALL  0D14
0FB8:  MOVFF  01,00
0FBC:  MOVFF  02,01
0FC0:  CLRF   02
0FC2:  CLRF   03
0FC4:  BTFSS  01.7
0FC6:  BRA    0FCC
0FC8:  DECF   02,F
0FCA:  DECF   03,F
0FCC:  MOVFF  03,4F
0FD0:  MOVFF  02,4E
0FD4:  MOVFF  01,4D
0FD8:  MOVFF  00,4C
....................  
....................     pasosx = pasosx * 2; 
0FDC:  MOVFF  4B,76
0FE0:  MOVFF  4A,75
0FE4:  MOVFF  49,74
0FE8:  MOVFF  48,73
0FEC:  CLRF   x7A
0FEE:  CLRF   x79
0FF0:  CLRF   x78
0FF2:  MOVLW  02
0FF4:  MOVWF  x77
0FF6:  RCALL  0D4C
0FF8:  MOVFF  03,4B
0FFC:  MOVFF  02,4A
1000:  MOVFF  01,49
1004:  MOVFF  00,48
....................     pasosy = pasosy * 2; 
1008:  MOVFF  4F,76
100C:  MOVFF  4E,75
1010:  MOVFF  4D,74
1014:  MOVFF  4C,73
1018:  CLRF   x7A
101A:  CLRF   x79
101C:  CLRF   x78
101E:  MOVLW  02
1020:  MOVWF  x77
1022:  RCALL  0D4C
1024:  MOVFF  03,4F
1028:  MOVFF  02,4E
102C:  MOVFF  01,4D
1030:  MOVFF  00,4C
1034:  RETURN 0
.................... } 
....................  
.................... void perforacion(void) 
.................... { 
....................     output_high(dremel); 
*
1876:  BCF    F96.0
1878:  BSF    F8D.0
....................     while (flagpaquete == 0); 
187A:  BTFSS  x62.0
187C:  BRA    187A
....................     while (flagpaquete == 1) 
187E:  BTFSS  x62.0
1880:  BRA    1956
....................     { 
....................         while (flagxy == 0); 
1882:  MOVF   5E,F
1884:  BZ    1882
....................         while (flagxy == 1) 
1886:  DECFSZ 5E,W
1888:  BRA    1954
....................         { 
....................             x = (signed long long int) atof(datox); 
188A:  CLRF   x74
188C:  MOVLW  24
188E:  MOVWF  x73
1890:  CLRF   x76
1892:  CLRF   x75
1894:  RCALL  11C6
1896:  MOVFF  03,83
189A:  MOVFF  02,82
189E:  MOVFF  01,81
18A2:  MOVFF  00,80
18A6:  RCALL  1446
18A8:  MOVFF  03,3B
18AC:  MOVFF  02,3A
18B0:  MOVFF  01,39
18B4:  MOVFF  00,38
....................             y = (signed long long int) atof(datoy); 
18B8:  CLRF   x74
18BA:  MOVLW  2B
18BC:  MOVWF  x73
18BE:  CLRF   x76
18C0:  CLRF   x75
18C2:  RCALL  11C6
18C4:  MOVFF  03,83
18C8:  MOVFF  02,82
18CC:  MOVFF  01,81
18D0:  MOVFF  00,80
18D4:  RCALL  1446
18D6:  MOVFF  03,3F
18DA:  MOVFF  02,3E
18DE:  MOVFF  01,3D
18E2:  MOVFF  00,3C
....................             conversionpasos(); 
18E6:  CALL   0DA0
....................             xini = x; 
18EA:  MOVFF  3B,43
18EE:  MOVFF  3A,42
18F2:  MOVFF  39,41
18F6:  MOVFF  38,40
....................             yini = y; 
18FA:  MOVFF  3F,47
18FE:  MOVFF  3E,46
1902:  MOVFF  3D,45
1906:  MOVFF  3C,44
....................             clear_interrupt(INT_TIMER0); 
190A:  BCF    FF2.2
....................             set_timer0(230); 
190C:  CLRF   FD7
190E:  MOVLW  E6
1910:  MOVWF  FD6
....................             enable_interrupts(INT_TIMER0); //Habilita interrupcin timer0 
1912:  BSF    FF2.5
....................             flagx = 1; 
1914:  MOVLW  01
1916:  MOVWF  5C
....................             flagy = 1; 
1918:  MOVWF  5D
....................             while (flagxy == 1); 
191A:  DECFSZ 5E,W
191C:  BRA    1920
191E:  BRA    191A
....................             z = alturamecha + 300; 
1920:  MOVLW  2C
1922:  ADDWF  x6F,W
1924:  MOVWF  x6B
1926:  MOVLW  01
1928:  ADDWFC x70,W
192A:  MOVWF  x6C
192C:  MOVLW  00
192E:  ADDWFC x71,W
1930:  MOVWF  x6D
1932:  MOVLW  00
1934:  ADDWFC x72,W
1936:  MOVWF  x6E
....................             moverz(); 
1938:  RCALL  1738
....................             z = alturamecha; //trabajando a por paso completo son 1cm(100*0,2)/2 
193A:  MOVFF  72,6E
193E:  MOVFF  71,6D
1942:  MOVFF  70,6C
1946:  MOVFF  6F,6B
....................             moverz(); 
194A:  RCALL  1738
....................             putc('*'); 
194C:  MOVLW  2A
194E:  CALL   0158
1952:  BRA    1886
....................         } 
1954:  BRA    187E
....................     } 
....................     output_low(dremel); 
1956:  BCF    F96.0
1958:  BCF    F8D.0
195A:  GOTO   1D5C (RETURN)
.................... } 
....................  
.................... void moverxy(void) 
.................... { 
....................     clear_interrupt(INT_TIMER0); 
*
1036:  BCF    FF2.2
....................     set_timer0(230); 
1038:  CLRF   FD7
103A:  MOVLW  E6
103C:  MOVWF  FD6
....................     enable_interrupts(INT_TIMER0); //Habilita interrupcin timer0 
103E:  BSF    FF2.5
....................     flagx = 1; 
1040:  MOVLW  01
1042:  MOVWF  5C
....................     flagy = 1; 
1044:  MOVWF  5D
....................     flagxy = 1; 
1046:  MOVWF  5E
....................     while (flagxy == 1); 
1048:  DECFSZ 5E,W
104A:  BRA    104E
104C:  BRA    1048
104E:  GOTO   1096 (RETURN)
.................... } 
....................  
.................... void posicionmecha(void) 
.................... { 
....................     x = +150000; 
1052:  CLRF   3B
1054:  MOVLW  02
1056:  MOVWF  3A
1058:  MOVLW  49
105A:  MOVWF  39
105C:  MOVLW  F0
105E:  MOVWF  38
....................     y = +200000; 
1060:  CLRF   3F
1062:  MOVLW  03
1064:  MOVWF  3E
1066:  MOVLW  0D
1068:  MOVWF  3D
106A:  MOVLW  40
106C:  MOVWF  3C
....................     conversionpasos(); 
106E:  RCALL  0DA0
....................     xini = x; 
1070:  MOVFF  3B,43
1074:  MOVFF  3A,42
1078:  MOVFF  39,41
107C:  MOVFF  38,40
....................     yini = y; 
1080:  MOVFF  3F,47
1084:  MOVFF  3E,46
1088:  MOVFF  3D,45
108C:  MOVFF  3C,44
....................     // pasosx=+1500;     //pasos para ir a punto de prueba 
....................     //pasosy=+1000;     //pasos para ir a puto de prueba 
....................     contador = 2; 
1090:  MOVLW  02
1092:  MOVWF  37
....................     moverxy(); 
1094:  BRA    1036
....................     putc('M'); 
1096:  MOVLW  4D
1098:  CALL   0158
109C:  RETURN 0
.................... } 
....................  
.................... void profundidadmecha(void) 
.................... { 
....................     lcd_putc("\fAjustando Z\n"); 
*
1692:  MOVLW  D8
1694:  MOVWF  FF6
1696:  MOVLW  00
1698:  MOVWF  FF7
169A:  CALL   071C
....................     lcd_putc("Profundidad de mecha"); 
169E:  MOVLW  E6
16A0:  MOVWF  FF6
16A2:  MOVLW  00
16A4:  MOVWF  FF7
16A6:  CALL   071C
....................     output_low(habilz); 
16AA:  BCF    F92.1
16AC:  BCF    F89.1
....................     output_low(habilx); 
16AE:  BCF    F96.2
16B0:  BCF    F8D.2
....................     output_low(habily); 
16B2:  BCF    F92.0
16B4:  BCF    F89.0
....................     output_low(motorz); 
16B6:  BCF    F95.5
16B8:  BCF    F8C.5
....................     while (input(profunz) == 1) 
16BA:  BSF    F94.1
16BC:  BTFSS  F82.1
16BE:  BRA    172A
....................     { 
....................         output_high(sentidoz); 
16C0:  BCF    F95.2
16C2:  BSF    F8C.2
....................         output_high(motorz); 
16C4:  BCF    F95.5
16C6:  BSF    F8C.5
....................         delay_us(1200); 
16C8:  CLRF   16
16CA:  BTFSC  FF2.7
16CC:  BSF    16.7
16CE:  BCF    FF2.7
16D0:  MOVLW  01
16D2:  MOVWF  x96
16D4:  CALL   0172
16D8:  BTFSC  16.7
16DA:  BSF    FF2.7
16DC:  CLRF   16
16DE:  BTFSC  FF2.7
16E0:  BSF    16.7
16E2:  BCF    FF2.7
16E4:  MOVLW  C8
16E6:  MOVWF  x96
16E8:  CALL   019A
16EC:  BTFSC  16.7
16EE:  BSF    FF2.7
....................         output_low(motorz); 
16F0:  BCF    F95.5
16F2:  BCF    F8C.5
....................         delay_us(1200); 
16F4:  CLRF   16
16F6:  BTFSC  FF2.7
16F8:  BSF    16.7
16FA:  BCF    FF2.7
16FC:  MOVLW  01
16FE:  MOVWF  x96
1700:  CALL   0172
1704:  BTFSC  16.7
1706:  BSF    FF2.7
1708:  CLRF   16
170A:  BTFSC  FF2.7
170C:  BSF    16.7
170E:  BCF    FF2.7
1710:  MOVLW  C8
1712:  MOVWF  x96
1714:  CALL   019A
1718:  BTFSC  16.7
171A:  BSF    FF2.7
....................         alturamecha = alturamecha + 1; 
171C:  MOVLW  01
171E:  ADDWF  x6F,F
1720:  MOVLW  00
1722:  ADDWFC x70,F
1724:  ADDWFC x71,F
1726:  ADDWFC x72,F
1728:  BRA    16BA
....................     } 
....................     alturamecha = alturamecha - 200; //le resta el espesor de la base y le da un mm ms 
172A:  MOVLW  C8
172C:  SUBWF  x6F,F
172E:  MOVLW  00
1730:  SUBWFB x70,F
1732:  SUBWFB x71,F
1734:  SUBWFB x72,F
1736:  RETURN 0
.................... } 
....................  
.................... void ajusteceroz(void) 
.................... { 
....................     output_low(habilz); 
*
073C:  BCF    F92.1
073E:  BCF    F89.1
....................     lcd_putc("Buscando cero Z"); 
0740:  MOVLW  FC
0742:  MOVWF  FF6
0744:  MOVLW  00
0746:  MOVWF  FF7
0748:  RCALL  071C
....................     while ((input(ceroz)) == 0) 
074A:  BSF    F94.0
074C:  BTFSC  F82.0
074E:  BRA    077E
....................     { 
....................         output_low(sentidoz); 
0750:  BCF    F95.2
0752:  BCF    F8C.2
....................         output_toggle(motorz); 
0754:  BCF    F95.5
0756:  BTG    F8C.5
....................         delay_us(1200); 
0758:  CLRF   16
075A:  BTFSC  FF2.7
075C:  BSF    16.7
075E:  BCF    FF2.7
0760:  MOVLW  01
0762:  MOVWF  x96
0764:  RCALL  0172
0766:  BTFSC  16.7
0768:  BSF    FF2.7
076A:  CLRF   16
076C:  BTFSC  FF2.7
076E:  BSF    16.7
0770:  BCF    FF2.7
0772:  MOVLW  C8
0774:  MOVWF  x96
0776:  RCALL  019A
0778:  BTFSC  16.7
077A:  BSF    FF2.7
077C:  BRA    074A
....................     } 
....................     lcd_putc(" OK\n"); 
077E:  MOVLW  0C
0780:  MOVWF  FF6
0782:  MOVLW  01
0784:  MOVWF  FF7
0786:  RCALL  071C
....................     zini = 0; 
0788:  CLRF   x6A
078A:  CLRF   x69
078C:  CLRF   x68
078E:  CLRF   x67
0790:  GOTO   07A0 (RETURN)
.................... } 
....................  
.................... void ajustedecero(void) 
.................... { 
....................     lcd_putc("\fBuscando origen\n"); 
0794:  MOVLW  12
0796:  MOVWF  FF6
0798:  MOVLW  01
079A:  MOVWF  FF7
079C:  RCALL  071C
....................     ajusteceroz(); 
079E:  BRA    073C
....................     lcd_putc("Buscando cero X\n"); 
07A0:  MOVLW  24
07A2:  MOVWF  FF6
07A4:  MOVLW  01
07A6:  MOVWF  FF7
07A8:  RCALL  071C
....................     lcd_putc("Buscando cero Y\n"); 
07AA:  MOVLW  36
07AC:  MOVWF  FF6
07AE:  MOVLW  01
07B0:  MOVWF  FF7
07B2:  RCALL  071C
....................     output_low(habilx); 
07B4:  BCF    F96.2
07B6:  BCF    F8D.2
....................     output_low(habily); 
07B8:  BCF    F92.0
07BA:  BCF    F89.0
....................     while ((input(cerox) == 0) || (input(ceroy)) == 0) 
07BC:  BSF    F95.6
07BE:  BTFSS  F83.6
07C0:  BRA    07C8
07C2:  BSF    F95.7
07C4:  BTFSC  F83.7
07C6:  BRA    083E
....................     { 
....................         if (input(cerox) == 0) 
07C8:  BSF    F95.6
07CA:  BTFSC  F83.6
07CC:  BRA    07D6
....................         { 
....................             output_low(sentidox); 
07CE:  BCF    F95.0
07D0:  BCF    F8C.0
....................             output_toggle(motorx); 
07D2:  BCF    F95.3
07D4:  BTG    F8C.3
....................         } 
....................         if (input(cerox) == 1) 
07D6:  BSF    F95.6
07D8:  BTFSS  F83.6
07DA:  BRA    07F0
....................         { 
....................             lcd_gotoxy(17, 3); 
07DC:  MOVLW  11
07DE:  MOVWF  x81
07E0:  MOVLW  03
07E2:  MOVWF  x82
07E4:  RCALL  0688
....................             lcd_putc("OK"); 
07E6:  MOVLW  48
07E8:  MOVWF  FF6
07EA:  MOVLW  01
07EC:  MOVWF  FF7
07EE:  RCALL  071C
....................         } 
....................         if (input(ceroy) == 0) 
07F0:  BSF    F95.7
07F2:  BTFSC  F83.7
07F4:  BRA    07FE
....................         { 
....................             output_high(sentidoy); 
07F6:  BCF    F95.1
07F8:  BSF    F8C.1
....................             output_toggle(motory); 
07FA:  BCF    F95.4
07FC:  BTG    F8C.4
....................         } 
....................         if (input(ceroy) == 1) 
07FE:  BSF    F95.7
0800:  BTFSS  F83.7
0802:  BRA    0818
....................         { 
....................             lcd_gotoxy(17, 4); 
0804:  MOVLW  11
0806:  MOVWF  x81
0808:  MOVLW  04
080A:  MOVWF  x82
080C:  RCALL  0688
....................             lcd_putc("OK"); 
080E:  MOVLW  4C
0810:  MOVWF  FF6
0812:  MOVLW  01
0814:  MOVWF  FF7
0816:  RCALL  071C
....................         } 
....................         delay_us(1200); 
0818:  CLRF   16
081A:  BTFSC  FF2.7
081C:  BSF    16.7
081E:  BCF    FF2.7
0820:  MOVLW  01
0822:  MOVWF  x96
0824:  RCALL  0172
0826:  BTFSC  16.7
0828:  BSF    FF2.7
082A:  CLRF   16
082C:  BTFSC  FF2.7
082E:  BSF    16.7
0830:  BCF    FF2.7
0832:  MOVLW  C8
0834:  MOVWF  x96
0836:  RCALL  019A
0838:  BTFSC  16.7
083A:  BSF    FF2.7
083C:  BRA    07BC
....................     } 
....................     lcd_gotoxy(17, 3); 
083E:  MOVLW  11
0840:  MOVWF  x81
0842:  MOVLW  03
0844:  MOVWF  x82
0846:  RCALL  0688
....................     lcd_putc("OK"); 
0848:  MOVLW  50
084A:  MOVWF  FF6
084C:  MOVLW  01
084E:  MOVWF  FF7
0850:  RCALL  071C
....................     lcd_gotoxy(17, 4); 
0852:  MOVLW  11
0854:  MOVWF  x81
0856:  MOVLW  04
0858:  MOVWF  x82
085A:  RCALL  0688
....................     lcd_putc("OK"); 
085C:  MOVLW  54
085E:  MOVWF  FF6
0860:  MOVLW  01
0862:  MOVWF  FF7
0864:  RCALL  071C
....................     output_low(motorx); 
0866:  BCF    F95.3
0868:  BCF    F8C.3
....................     output_low(motory); 
086A:  BCF    F95.4
086C:  BCF    F8C.4
....................     output_low(motorz); 
086E:  BCF    F95.5
0870:  BCF    F8C.5
....................     xini = 0; 
0872:  CLRF   43
0874:  CLRF   42
0876:  CLRF   41
0878:  CLRF   40
....................     yini = 0; 
087A:  CLRF   47
087C:  CLRF   46
087E:  CLRF   45
0880:  CLRF   44
0882:  RETURN 0
.................... } 
....................  
.................... void mecha(void) 
.................... { 
....................     while (flagmecha == 0); 
*
13FE:  MOVF   x60,F
1400:  BZ    13FE
....................     while (flagmecha == 1); 
1402:  DECFSZ x60,W
1404:  BRA    1408
1406:  BRA    1402
....................     broca = atof(mech); 
1408:  CLRF   x74
140A:  MOVLW  1F
140C:  MOVWF  x73
140E:  CLRF   x76
1410:  CLRF   x75
1412:  RCALL  11C6
1414:  MOVFF  03,53
1418:  MOVFF  02,52
141C:  MOVFF  01,51
1420:  MOVFF  00,50
1424:  RETURN 0
.................... } 
....................  
....................  
.................... #INT_EXT2         //Atencin a interrupcin por cambio en RB2 
....................  
.................... ext_isr1() 
.................... { //Funcin de interrupcin 
....................     putc('F'); 
*
0160:  MOVLW  46
0162:  RCALL  0158
....................     flagajuste = 0; 
0164:  BCF    x62.1
....................     salir = 1; 
0166:  MOVLW  01
0168:  MOVWF  36
....................     disable_interrupts(INT_EXT2_L2H); 
016A:  BCF    FF0.4
.................... } 
....................  
016C:  BCF    FF0.1
016E:  GOTO   0078
.................... #INT_EXT         //Atencin a interrupcin por cambio en RB0 
....................  
.................... void INTEXT_isr(void) 
.................... { //Funcin de interrupcin 
....................     output_low(motorz); 
*
01BA:  BCF    F95.5
01BC:  BCF    F8C.5
....................     if (input(canalb) == 0) 
01BE:  BSF    F92.2
01C0:  BTFSC  F80.2
01C2:  BRA    01F8
....................     { 
....................         output_low(habilz); 
01C4:  BCF    F92.1
01C6:  BCF    F89.1
....................         output_low(sentidoz); //mecha para abajo 
01C8:  BCF    F95.2
01CA:  BCF    F8C.2
....................         z = z - 2; 
01CC:  MOVLW  02
01CE:  SUBWF  x6B,F
01D0:  MOVLW  00
01D2:  SUBWFB x6C,F
01D4:  SUBWFB x6D,F
01D6:  SUBWFB x6E,F
....................         output_high(motorz); 
01D8:  BCF    F95.5
01DA:  BSF    F8C.5
....................         delay_us(1200); 
01DC:  MOVLW  01
01DE:  MOVWF  x96
01E0:  RCALL  0172
01E2:  MOVLW  C8
01E4:  MOVWF  x96
01E6:  RCALL  019A
....................         output_low(motorz); 
01E8:  BCF    F95.5
01EA:  BCF    F8C.5
....................         delay_us(1200); 
01EC:  MOVLW  01
01EE:  MOVWF  x96
01F0:  RCALL  0172
01F2:  MOVLW  C8
01F4:  MOVWF  x96
01F6:  RCALL  019A
....................     } 
....................     if (input(canalb) == 1) 
01F8:  BSF    F92.2
01FA:  BTFSS  F80.2
01FC:  BRA    0232
....................     { 
....................         output_low(habilz); 
01FE:  BCF    F92.1
0200:  BCF    F89.1
....................         output_high(sentidoz); //mecha para arriba 
0202:  BCF    F95.2
0204:  BSF    F8C.2
....................         z = z + 2; 
0206:  MOVLW  02
0208:  ADDWF  x6B,F
020A:  MOVLW  00
020C:  ADDWFC x6C,F
020E:  ADDWFC x6D,F
0210:  ADDWFC x6E,F
....................         output_high(motorz); 
0212:  BCF    F95.5
0214:  BSF    F8C.5
....................         delay_us(1200); 
0216:  MOVLW  01
0218:  MOVWF  x96
021A:  RCALL  0172
021C:  MOVLW  C8
021E:  MOVWF  x96
0220:  RCALL  019A
....................         output_low(motorz); 
0222:  BCF    F95.5
0224:  BCF    F8C.5
....................         delay_us(1200); 
0226:  MOVLW  01
0228:  MOVWF  x96
022A:  RCALL  0172
022C:  MOVLW  C8
022E:  MOVWF  x96
0230:  RCALL  019A
....................     } 
.................... } 
0232:  BCF    FF2.1
0234:  GOTO   0078
.................... #int_TIMER0 
....................  
.................... void TIMER0_isr(void) 
.................... { 
....................     contador = contador - 1; 
0238:  MOVLW  01
023A:  SUBWF  37,F
....................  
....................     if (contador == 0) 
023C:  MOVF   37,F
023E:  BTFSS  FD8.2
0240:  BRA    02FA
....................     { 
....................         contador = 2; 
0242:  MOVLW  02
0244:  MOVWF  37
....................         if (pasosx == 0) 
0246:  MOVF   48,F
0248:  BNZ   0258
024A:  MOVF   49,F
024C:  BNZ   0258
024E:  MOVF   4A,F
0250:  BNZ   0258
0252:  MOVF   4B,F
0254:  BNZ   0258
....................         { 
....................             flagx = 0; 
0256:  CLRF   5C
....................         } 
....................         if (pasosx > 0) 
0258:  BTFSC  4B.7
025A:  BRA    0282
025C:  MOVF   4B,F
025E:  BNZ   026E
0260:  MOVF   4A,F
0262:  BNZ   026E
0264:  MOVF   49,F
0266:  BNZ   026E
0268:  MOVF   48,W
026A:  SUBLW  00
026C:  BC    0282
....................         { 
....................             output_high(sentidox); 
026E:  BCF    F95.0
0270:  BSF    F8C.0
....................             output_toggle(motorx); 
0272:  BCF    F95.3
0274:  BTG    F8C.3
....................             pasosx = pasosx - 1; 
0276:  MOVLW  01
0278:  SUBWF  48,F
027A:  MOVLW  00
027C:  SUBWFB 49,F
027E:  SUBWFB 4A,F
0280:  SUBWFB 4B,F
....................         } 
....................         if (pasosx < 0) 
0282:  BTFSS  4B.7
0284:  BRA    029A
....................         { 
....................             output_low(sentidox); 
0286:  BCF    F95.0
0288:  BCF    F8C.0
....................             output_toggle(motorx); 
028A:  BCF    F95.3
028C:  BTG    F8C.3
....................             pasosx = pasosx + 1; 
028E:  MOVLW  01
0290:  ADDWF  48,F
0292:  MOVLW  00
0294:  ADDWFC 49,F
0296:  ADDWFC 4A,F
0298:  ADDWFC 4B,F
....................         } 
....................  
....................         if (pasosy == 0) 
029A:  MOVF   4C,F
029C:  BNZ   02AC
029E:  MOVF   4D,F
02A0:  BNZ   02AC
02A2:  MOVF   4E,F
02A4:  BNZ   02AC
02A6:  MOVF   4F,F
02A8:  BNZ   02AC
....................         { 
....................             flagy = 0; 
02AA:  CLRF   5D
....................         } 
....................         if (pasosy > 0) 
02AC:  BTFSC  4F.7
02AE:  BRA    02D6
02B0:  MOVF   4F,F
02B2:  BNZ   02C2
02B4:  MOVF   4E,F
02B6:  BNZ   02C2
02B8:  MOVF   4D,F
02BA:  BNZ   02C2
02BC:  MOVF   4C,W
02BE:  SUBLW  00
02C0:  BC    02D6
....................         { 
....................             output_low(sentidoy); 
02C2:  BCF    F95.1
02C4:  BCF    F8C.1
....................             output_toggle(motory); 
02C6:  BCF    F95.4
02C8:  BTG    F8C.4
....................             pasosy = pasosy - 1; 
02CA:  MOVLW  01
02CC:  SUBWF  4C,F
02CE:  MOVLW  00
02D0:  SUBWFB 4D,F
02D2:  SUBWFB 4E,F
02D4:  SUBWFB 4F,F
....................         } 
....................         if (pasosy < 0) 
02D6:  BTFSS  4F.7
02D8:  BRA    02EE
....................         { 
....................             output_high(sentidoy); 
02DA:  BCF    F95.1
02DC:  BSF    F8C.1
....................             output_toggle(motory); 
02DE:  BCF    F95.4
02E0:  BTG    F8C.4
....................             pasosy = pasosy + 1; 
02E2:  MOVLW  01
02E4:  ADDWF  4C,F
02E6:  MOVLW  00
02E8:  ADDWFC 4D,F
02EA:  ADDWFC 4E,F
02EC:  ADDWFC 4F,F
....................         } 
....................  
....................         if (flagx == 0 && flagy == 0) 
02EE:  MOVF   5C,F
02F0:  BNZ   02FA
02F2:  MOVF   5D,F
02F4:  BNZ   02FA
....................         { 
....................             flagxy = 0; 
02F6:  CLRF   5E
....................             disable_interrupts(INT_TIMER0); //deshabilita interrupcin timer0 
02F8:  BCF    FF2.5
....................         } 
....................     } 
....................     set_timer0(230); //Se recarga el timer0 
02FA:  CLRF   FD7
02FC:  MOVLW  E6
02FE:  MOVWF  FD6
.................... } 
....................  
0300:  BCF    FF2.2
0302:  GOTO   0078
.................... #int_rda 
....................  
.................... void serial_isr() 
.................... { 
....................     ch = getchar(); 
0306:  BTFSS  F9E.5
0308:  BRA    0306
030A:  MOVFF  FAE,1E
....................     if (ch == 'F' && flagpaquete == 1) 
030E:  MOVF   1E,W
0310:  SUBLW  46
0312:  BNZ   032A
0314:  BTFSS  x62.0
0316:  BRA    032A
....................     { 
....................         flagpaquete = flagpaquete + 1; 
0318:  MOVLW  00
031A:  BTFSC  x62.0
031C:  MOVLW  01
031E:  ADDLW  01
0320:  BCF    x62.0
0322:  BTFSC  FE8.0
0324:  BSF    x62.0
....................         flagfin = 1; 
0326:  MOVLW  01
0328:  MOVWF  35
....................     } 
....................     if (ch == 'A') 
032A:  MOVF   1E,W
032C:  SUBLW  41
032E:  BNZ   033E
....................     { 
....................         flagajuste = flagajuste + 1; 
0330:  MOVLW  00
0332:  BTFSC  x62.1
0334:  MOVLW  01
0336:  ADDLW  01
0338:  BCF    x62.1
033A:  BTFSC  FE8.0
033C:  BSF    x62.1
....................     } 
....................     if (ch == 'P') 
033E:  MOVF   1E,W
0340:  SUBLW  50
0342:  BNZ   0352
....................     { 
....................         flagpaquete = flagpaquete + 1; 
0344:  MOVLW  00
0346:  BTFSC  x62.0
0348:  MOVLW  01
034A:  ADDLW  01
034C:  BCF    x62.0
034E:  BTFSC  FE8.0
0350:  BSF    x62.0
....................     } 
....................     if (ch == '*') 
0352:  MOVF   1E,W
0354:  SUBLW  2A
0356:  BNZ   035C
....................     { 
....................         flagcomienzo = 1; 
0358:  MOVLW  01
035A:  MOVWF  5F
....................     } 
....................     if (ch == 'M') 
035C:  MOVF   1E,W
035E:  SUBLW  4D
0360:  BNZ   0368
....................     { 
....................         flagmecha = 1; 
0362:  MOVLW  01
0364:  MOVWF  x60
....................         h = 0; 
0366:  CLRF   34
....................     } 
....................     if ((flagmecha) == 1 && (ch != 'M')) 
0368:  DECFSZ x60,W
036A:  BRA    0390
036C:  MOVF   1E,W
036E:  SUBLW  4D
0370:  BZ    0390
....................     { 
....................  
....................         mech[h] = ch; 
0372:  CLRF   03
0374:  MOVF   34,W
0376:  ADDLW  1F
0378:  MOVWF  FE9
037A:  MOVLW  00
037C:  ADDWFC 03,W
037E:  MOVWF  FEA
0380:  MOVFF  1E,FEF
....................         h = h + 1; 
0384:  MOVLW  01
0386:  ADDWF  34,F
....................         if (h == 6) 
0388:  MOVF   34,W
038A:  SUBLW  06
038C:  BNZ   0390
....................         { 
....................             flagmecha = 0; 
038E:  CLRF   x60
....................         } 
....................     } 
....................     if (ch == 'X') 
0390:  MOVF   1E,W
0392:  SUBLW  58
0394:  BNZ   039C
....................     { 
....................         flagx = 1; 
0396:  MOVLW  01
0398:  MOVWF  5C
....................         i = 0; 
039A:  CLRF   32
....................     } 
....................     if (ch == 'Y') 
039C:  MOVF   1E,W
039E:  SUBLW  59
03A0:  BNZ   03A8
....................     { 
....................         flagy = 1; 
03A2:  MOVLW  01
03A4:  MOVWF  5D
....................         j = 0; 
03A6:  CLRF   33
....................     } 
....................     if ((flagx) == 1 && (ch != 'X')) 
03A8:  DECFSZ 5C,W
03AA:  BRA    03D4
03AC:  MOVF   1E,W
03AE:  SUBLW  58
03B0:  BZ    03D4
....................     { 
....................         datox[i] = ch; 
03B2:  CLRF   03
03B4:  MOVF   32,W
03B6:  ADDLW  24
03B8:  MOVWF  FE9
03BA:  MOVLW  00
03BC:  ADDWFC 03,W
03BE:  MOVWF  FEA
03C0:  MOVFF  1E,FEF
....................         i = i + 1; 
03C4:  MOVLW  01
03C6:  ADDWF  32,F
....................         if (i == 7) 
03C8:  MOVF   32,W
03CA:  SUBLW  07
03CC:  BNZ   03D4
....................         { 
....................             flagx = 0; 
03CE:  CLRF   5C
....................             putc('*'); 
03D0:  MOVLW  2A
03D2:  RCALL  0158
....................         } 
....................     } 
....................     if ((flagy) == 1 && (ch != 'Y')) 
03D4:  DECFSZ 5D,W
03D6:  BRA    0404
03D8:  MOVF   1E,W
03DA:  SUBLW  59
03DC:  BZ    0404
....................     { 
....................         datoy[j] = ch; 
03DE:  CLRF   03
03E0:  MOVF   33,W
03E2:  ADDLW  2B
03E4:  MOVWF  FE9
03E6:  MOVLW  00
03E8:  ADDWFC 03,W
03EA:  MOVWF  FEA
03EC:  MOVFF  1E,FEF
....................         j = j + 1; 
03F0:  MOVLW  01
03F2:  ADDWF  33,F
....................         if (j == 7) 
03F4:  MOVF   33,W
03F6:  SUBLW  07
03F8:  BNZ   0404
....................         { 
....................             flagy = 0; 
03FA:  CLRF   5D
....................             flagxy = 1; 
03FC:  MOVLW  01
03FE:  MOVWF  5E
....................             putc('*'); 
0400:  MOVLW  2A
0402:  RCALL  0158
....................         } 
....................     } 
0404:  BCF    F9E.5
0406:  GOTO   0078
.................... } 
.................... void main() 
*
195E:  CLRF   FF8
1960:  BCF    FD0.7
1962:  BSF    07.7
1964:  BSF    FB8.3
1966:  MOVLW  E1
1968:  MOVWF  FAF
196A:  MOVLW  04
196C:  MOVWF  FB0
196E:  MOVLW  A6
1970:  MOVWF  FAC
1972:  MOVLW  90
1974:  MOVWF  FAB
1976:  MOVF   FC1,W
1978:  ANDLW  C0
197A:  IORLW  0F
197C:  MOVWF  FC1
197E:  MOVLW  07
1980:  MOVWF  FB4
1982:  CLRF   17
1984:  CLRF   18
.................... { 
....................     output_high(habilx); //motor desenergizado 
1986:  BCF    F96.2
1988:  BSF    F8D.2
....................     output_high(habily); 
198A:  BCF    F92.0
198C:  BSF    F89.0
....................     output_high(habilz); 
198E:  BCF    F92.1
1990:  BSF    F89.1
1992:  CLRF   16
1994:  BTFSC  FF2.7
1996:  BSF    16.7
1998:  BCF    FF2.7
....................     delay_ms(100); 
199A:  MOVLW  64
199C:  MOVWF  x96
199E:  CALL   0172
19A2:  BTFSC  16.7
19A4:  BSF    FF2.7
....................     enable_interrupts(INT_RDA); 
19A6:  BSF    F9D.5
....................     setup_timer_0(RTCC_8_BIT | RTCC_DIV_256); //Configuracin timer0 
19A8:  MOVLW  C7
19AA:  MOVWF  FD5
....................  
....................     enable_interrupts(INT_EXT2_L2H); //Habilita int. RB2? 
19AC:  BSF    FF0.4
19AE:  BSF    FF1.4
....................     //ext_int_edge(L_TO_H);              //por flanco de subida 
....................     enable_interrupts(GLOBAL); //Habilita interrupcin general 
19B0:  MOVLW  C0
19B2:  IORWF  FF2,F
....................     lcd_init(); 
19B4:  GOTO   0606
....................  
....................     while (1) 
....................     { 
....................         flagfin = 0; 
19B8:  CLRF   35
....................         flagmecha = 0; 
19BA:  CLRF   x60
....................         flagcomienzo = 0; 
19BC:  CLRF   5F
....................         xini = 0; 
19BE:  CLRF   43
19C0:  CLRF   42
19C2:  CLRF   41
19C4:  CLRF   40
....................         yini = 0; 
19C6:  CLRF   47
19C8:  CLRF   46
19CA:  CLRF   45
19CC:  CLRF   44
....................         zini = 0; 
19CE:  CLRF   x6A
19D0:  CLRF   x69
19D2:  CLRF   x68
19D4:  CLRF   x67
....................         flagajuste = 0; 
19D6:  BCF    x62.1
....................         flagpaquete = 0; 
19D8:  BCF    x62.0
....................         pasosx = 0; 
19DA:  CLRF   4B
19DC:  CLRF   4A
19DE:  CLRF   49
19E0:  CLRF   48
....................         pasosz = 0; 
19E2:  CLRF   x66
19E4:  CLRF   x65
19E6:  CLRF   x64
19E8:  CLRF   x63
....................         pasosy = 0; 
19EA:  CLRF   4F
19EC:  CLRF   4E
19EE:  CLRF   4D
19F0:  CLRF   4C
....................         alturamecha = 0; 
19F2:  CLRF   x72
19F4:  CLRF   x71
19F6:  CLRF   x70
19F8:  CLRF   x6F
....................         x = 0; 
19FA:  CLRF   3B
19FC:  CLRF   3A
19FE:  CLRF   39
1A00:  CLRF   38
....................         y = 0; 
1A02:  CLRF   3F
1A04:  CLRF   3E
1A06:  CLRF   3D
1A08:  CLRF   3C
....................         z = 0; 
1A0A:  CLRF   x6E
1A0C:  CLRF   x6D
1A0E:  CLRF   x6C
1A10:  CLRF   x6B
....................         flagboton = 0; 
1A12:  CLRF   x61
....................         flagxy = 0; 
1A14:  CLRF   5E
....................         flagx = 0; 
1A16:  CLRF   5C
....................         flagy = 0; 
1A18:  CLRF   5D
....................         broca = 0; 
1A1A:  CLRF   53
1A1C:  CLRF   52
1A1E:  CLRF   51
1A20:  CLRF   50
....................         pasosxflot = 0; 
1A22:  CLRF   57
1A24:  CLRF   56
1A26:  CLRF   55
1A28:  CLRF   54
....................         pasosyflot = 0; 
1A2A:  CLRF   5B
1A2C:  CLRF   5A
1A2E:  CLRF   59
1A30:  CLRF   58
....................         salir = 0; 
1A32:  CLRF   36
....................         i = 0; 
1A34:  CLRF   32
....................         j = 0; 
1A36:  CLRF   33
....................         h = 0; 
1A38:  CLRF   34
....................         lcd_putc("\fHAGA CLICK EN\n"); 
1A3A:  MOVLW  0A
1A3C:  MOVWF  FF6
1A3E:  MOVLW  04
1A40:  MOVWF  FF7
1A42:  CALL   071C
....................         lcd_putc("EN CALIBRAR EN EL\n"); 
1A46:  MOVLW  1A
1A48:  MOVWF  FF6
1A4A:  MOVLW  04
1A4C:  MOVWF  FF7
1A4E:  CALL   071C
....................         lcd_putc("PROGRAMA Y ESPERE \n"); 
1A52:  MOVLW  2E
1A54:  MOVWF  FF6
1A56:  MOVLW  04
1A58:  MOVWF  FF7
1A5A:  CALL   071C
....................         lcd_putc("UN MOMENTO."); 
1A5E:  MOVLW  42
1A60:  MOVWF  FF6
1A62:  MOVLW  04
1A64:  MOVWF  FF7
1A66:  CALL   071C
....................         while (flagcomienzo == 0); 
1A6A:  MOVF   5F,F
1A6C:  BZ    1A6A
....................         flagcomienzo = 0; 
1A6E:  CLRF   5F
....................         ajustedecero(); 
1A70:  CALL   0794
....................         posicionmecha(); 
1A74:  CALL   1052
....................         mecha(); 
1A78:  RCALL  13FE
....................         printf(lcd_putc"\fPoner mecha %01.3fmm", broca); 
1A7A:  MOVLW  4E
1A7C:  MOVWF  FF6
1A7E:  MOVLW  04
1A80:  MOVWF  FF7
1A82:  MOVLW  0D
1A84:  MOVWF  x73
1A86:  RCALL  1426
1A88:  MOVLW  C9
1A8A:  MOVWF  FE9
1A8C:  MOVFF  53,76
1A90:  MOVFF  52,75
1A94:  MOVFF  51,74
1A98:  MOVFF  50,73
1A9C:  MOVLW  03
1A9E:  MOVWF  x77
1AA0:  RCALL  1512
1AA2:  MOVLW  6D
1AA4:  MOVWF  x80
1AA6:  CALL   06C8
1AAA:  MOVLW  6D
1AAC:  MOVWF  x80
1AAE:  CALL   06C8
....................         lcd_putc("\nPresione enter para\n"); 
1AB2:  MOVLW  64
1AB4:  MOVWF  FF6
1AB6:  MOVLW  04
1AB8:  MOVWF  FF7
1ABA:  CALL   071C
....................         lcd_putc("comenzar el ajuste\n"); 
1ABE:  MOVLW  7A
1AC0:  MOVWF  FF6
1AC2:  MOVLW  04
1AC4:  MOVWF  FF7
1AC6:  CALL   071C
....................         lcd_putc("de la placa."); 
1ACA:  MOVLW  8E
1ACC:  MOVWF  FF6
1ACE:  MOVLW  04
1AD0:  MOVWF  FF7
1AD2:  CALL   071C
....................         while (input(enter) == 0) 
1AD6:  BSF    F96.1
1AD8:  BTFSC  F84.1
1ADA:  BRA    1ADE
....................         { 
1ADC:  BRA    1AD6
1ADE:  CLRF   16
1AE0:  BTFSC  FF2.7
1AE2:  BSF    16.7
1AE4:  BCF    FF2.7
....................         } 
....................         delay_ms(10); 
1AE6:  MOVLW  0A
1AE8:  MOVWF  x96
1AEA:  CALL   0172
1AEE:  BTFSC  16.7
1AF0:  BSF    FF2.7
....................         while (input(enter) == 1) 
1AF2:  BSF    F96.1
1AF4:  BTFSS  F84.1
1AF6:  BRA    1AFA
....................         { 
1AF8:  BRA    1AF2
....................         } 
....................         profundidadmecha(); 
1AFA:  RCALL  1692
....................         //ajustedecero(); 
....................         z = alturamecha; //******OK****** 
1AFC:  MOVFF  72,6E
1B00:  MOVFF  71,6D
1B04:  MOVFF  70,6C
1B08:  MOVFF  6F,6B
....................         moverz(); 
1B0C:  RCALL  1738
....................         putc('A'); 
1B0E:  MOVLW  41
1B10:  CALL   0158
....................         while (flagajuste == 0 && salir == 0); 
1B14:  BTFSC  x62.1
1B16:  BRA    1B1C
1B18:  MOVF   36,F
1B1A:  BZ    1B14
....................  
....................         while (flagajuste == 1) 
1B1C:  BTFSS  x62.1
1B1E:  BRA    1C58
....................         { 
....................             while (flagxy == 0); 
1B20:  MOVF   5E,F
1B22:  BZ    1B20
....................             while (flagxy == 1) 
1B24:  DECFSZ 5E,W
1B26:  BRA    1C56
....................             { 
....................                 x = (signed long long int) atof(datox); 
1B28:  CLRF   x74
1B2A:  MOVLW  24
1B2C:  MOVWF  x73
1B2E:  CLRF   x76
1B30:  CLRF   x75
1B32:  CALL   11C6
1B36:  MOVFF  03,83
1B3A:  MOVFF  02,82
1B3E:  MOVFF  01,81
1B42:  MOVFF  00,80
1B46:  RCALL  1446
1B48:  MOVFF  03,3B
1B4C:  MOVFF  02,3A
1B50:  MOVFF  01,39
1B54:  MOVFF  00,38
....................                 y = (signed long long int) atof(datoy); 
1B58:  CLRF   x74
1B5A:  MOVLW  2B
1B5C:  MOVWF  x73
1B5E:  CLRF   x76
1B60:  CLRF   x75
1B62:  CALL   11C6
1B66:  MOVFF  03,83
1B6A:  MOVFF  02,82
1B6E:  MOVFF  01,81
1B72:  MOVFF  00,80
1B76:  RCALL  1446
1B78:  MOVFF  03,3F
1B7C:  MOVFF  02,3E
1B80:  MOVFF  01,3D
1B84:  MOVFF  00,3C
....................                 conversionpasos(); 
1B88:  CALL   0DA0
....................                 xini = x; 
1B8C:  MOVFF  3B,43
1B90:  MOVFF  3A,42
1B94:  MOVFF  39,41
1B98:  MOVFF  38,40
....................                 yini = y; 
1B9C:  MOVFF  3F,47
1BA0:  MOVFF  3E,46
1BA4:  MOVFF  3D,45
1BA8:  MOVFF  3C,44
....................                 clear_interrupt(INT_TIMER0); 
1BAC:  BCF    FF2.2
....................                 set_timer0(230); 
1BAE:  CLRF   FD7
1BB0:  MOVLW  E6
1BB2:  MOVWF  FD6
....................                 enable_interrupts(INT_TIMER0); //Habilita interrupcin timer0 
1BB4:  BSF    FF2.5
....................                 flagx = 1; 
1BB6:  MOVLW  01
1BB8:  MOVWF  5C
....................                 flagy = 1; 
1BBA:  MOVWF  5D
....................                 while (flagxy == 1); 
1BBC:  DECFSZ 5E,W
1BBE:  BRA    1BC2
1BC0:  BRA    1BBC
....................                 //bajarz(); 
....................                 //moverz(); 
....................                 lcd_putc("\fGire para subir o\n"); 
1BC2:  MOVLW  9C
1BC4:  MOVWF  FF6
1BC6:  MOVLW  04
1BC8:  MOVWF  FF7
1BCA:  CALL   071C
....................                 lcd_putc("bajar mecha.Presione\n"); 
1BCE:  MOVLW  B0
1BD0:  MOVWF  FF6
1BD2:  MOVLW  04
1BD4:  MOVWF  FF7
1BD6:  CALL   071C
....................                 lcd_putc("\enter nuevo punto.\n"); 
1BDA:  MOVLW  C6
1BDC:  MOVWF  FF6
1BDE:  MOVLW  04
1BE0:  MOVWF  FF7
1BE2:  CALL   071C
....................                 lcd_putc("Boton rojo salir.\n"); 
1BE6:  MOVLW  DA
1BE8:  MOVWF  FF6
1BEA:  MOVLW  04
1BEC:  MOVWF  FF7
1BEE:  CALL   071C
....................                 enable_interrupts(INT_EXT2_L2H); 
1BF2:  BSF    FF0.4
1BF4:  BSF    FF1.4
....................                 while (input(enter) == 0 && salir == 0) 
1BF6:  BSF    F96.1
1BF8:  BTFSC  F84.1
1BFA:  BRA    1C02
1BFC:  MOVF   36,F
1BFE:  BNZ   1C02
....................                 { 
1C00:  BRA    1BF6
1C02:  CLRF   16
1C04:  BTFSC  FF2.7
1C06:  BSF    16.7
1C08:  BCF    FF2.7
....................                 } 
....................                 delay_ms(10); 
1C0A:  MOVLW  0A
1C0C:  MOVWF  x96
1C0E:  CALL   0172
1C12:  BTFSC  16.7
1C14:  BSF    FF2.7
....................                 while (input(enter) == 1 && salir == 0) 
1C16:  BSF    F96.1
1C18:  BTFSS  F84.1
1C1A:  BRA    1C22
1C1C:  MOVF   36,F
1C1E:  BNZ   1C22
....................                 { 
1C20:  BRA    1C16
....................                 } 
....................                 if (input(enter) == 0 && salir == 0) 
1C22:  BSF    F96.1
1C24:  BTFSC  F84.1
1C26:  BRA    1C54
1C28:  MOVF   36,F
1C2A:  BNZ   1C54
....................                 { 
....................                     zini = z; 
1C2C:  MOVFF  6E,6A
1C30:  MOVFF  6D,69
1C34:  MOVFF  6C,68
1C38:  MOVFF  6B,67
....................                     z = alturamecha; 
1C3C:  MOVFF  72,6E
1C40:  MOVFF  71,6D
1C44:  MOVFF  70,6C
1C48:  MOVFF  6F,6B
....................                     moverz(); 
1C4C:  RCALL  1738
....................                     putc('A'); 
1C4E:  MOVLW  41
1C50:  CALL   0158
....................                 } 
1C54:  BRA    1B24
....................             } 
1C56:  BRA    1B1C
....................         } 
....................         disable_interrupts(INT_EXT2_L2H); 
1C58:  BCF    FF0.4
....................         //salir=0; 
....................         while (flagfin == 0) 
1C5A:  MOVF   35,F
1C5C:  BTFSS  FD8.2
1C5E:  BRA    1D60
....................         { 
....................             ajustedecero(); 
1C60:  CALL   0794
....................             if (salir == 0) 
1C64:  MOVF   36,F
1C66:  BNZ   1D06
....................             { 
....................                 posicionmecha(); 
1C68:  CALL   1052
....................                 mecha(); 
1C6C:  CALL   13FE
....................                 lcd_putc("\fPor favor coloque\n"); 
1C70:  MOVLW  EE
1C72:  MOVWF  FF6
1C74:  MOVLW  04
1C76:  MOVWF  FF7
1C78:  CALL   071C
....................                 printf(lcd_putc"mecha de %01.2fmm y", broca); 
1C7C:  MOVLW  02
1C7E:  MOVWF  FF6
1C80:  MOVLW  05
1C82:  MOVWF  FF7
1C84:  MOVLW  09
1C86:  MOVWF  x73
1C88:  CALL   1426
1C8C:  MOVLW  C9
1C8E:  MOVWF  FE9
1C90:  MOVFF  53,76
1C94:  MOVFF  52,75
1C98:  MOVFF  51,74
1C9C:  MOVFF  50,73
1CA0:  MOVLW  02
1CA2:  MOVWF  x77
1CA4:  RCALL  1512
1CA6:  MOVLW  11
1CA8:  MOVWF  FF6
1CAA:  MOVLW  05
1CAC:  MOVWF  FF7
1CAE:  MOVLW  04
1CB0:  MOVWF  x73
1CB2:  CALL   1426
....................                 lcd_putc("\npresione enter"); 
1CB6:  MOVLW  16
1CB8:  MOVWF  FF6
1CBA:  MOVLW  05
1CBC:  MOVWF  FF7
1CBE:  CALL   071C
....................  
....................                 while (input(enter) == 0) 
1CC2:  BSF    F96.1
1CC4:  BTFSC  F84.1
1CC6:  BRA    1CCA
....................                 { 
1CC8:  BRA    1CC2
1CCA:  CLRF   16
1CCC:  BTFSC  FF2.7
1CCE:  BSF    16.7
1CD0:  BCF    FF2.7
....................                 } 
....................                 delay_ms(10); 
1CD2:  MOVLW  0A
1CD4:  MOVWF  x96
1CD6:  CALL   0172
1CDA:  BTFSC  16.7
1CDC:  BSF    FF2.7
....................                 while (input(enter) == 1) 
1CDE:  BSF    F96.1
1CE0:  BTFSS  F84.1
1CE2:  BRA    1CE6
....................                 { 
1CE4:  BRA    1CDE
....................                 } 
....................                 profundidadmecha(); 
1CE6:  RCALL  1692
....................                 ajustedecero(); 
1CE8:  CALL   0794
....................                 puts("OK"); 
1CEC:  MOVLW  26
1CEE:  MOVWF  FF6
1CF0:  MOVLW  05
1CF2:  MOVWF  FF7
1CF4:  RCALL  1854
1CF6:  MOVLW  0D
1CF8:  BTFSS  F9E.4
1CFA:  BRA    1CF8
1CFC:  MOVWF  FAD
1CFE:  MOVLW  0A
1D00:  BTFSS  F9E.4
1D02:  BRA    1D00
1D04:  MOVWF  FAD
....................             } 
....................             contador = 2; 
1D06:  MOVLW  02
1D08:  MOVWF  37
....................             lcd_putc("\fPerforadora Lista\n"); 
1D0A:  MOVLW  2A
1D0C:  MOVWF  FF6
1D0E:  MOVLW  05
1D10:  MOVWF  FF7
1D12:  CALL   071C
....................             lcd_putc("para operar pulse *\n"); 
1D16:  MOVLW  3E
1D18:  MOVWF  FF6
1D1A:  MOVLW  05
1D1C:  MOVWF  FF7
1D1E:  CALL   071C
....................             lcd_putc("para comenzar"); 
1D22:  MOVLW  54
1D24:  MOVWF  FF6
1D26:  MOVLW  05
1D28:  MOVWF  FF7
1D2A:  CALL   071C
....................  
....................             puts("OK"); 
1D2E:  MOVLW  62
1D30:  MOVWF  FF6
1D32:  MOVLW  05
1D34:  MOVWF  FF7
1D36:  RCALL  1854
1D38:  MOVLW  0D
1D3A:  BTFSS  F9E.4
1D3C:  BRA    1D3A
1D3E:  MOVWF  FAD
1D40:  MOVLW  0A
1D42:  BTFSS  F9E.4
1D44:  BRA    1D42
1D46:  MOVWF  FAD
....................             while (flagcomienzo == 0); 
1D48:  MOVF   5F,F
1D4A:  BZ    1D48
....................             lcd_putc("\fPERFORANDO\n"); 
1D4C:  MOVLW  66
1D4E:  MOVWF  FF6
1D50:  MOVLW  05
1D52:  MOVWF  FF7
1D54:  CALL   071C
....................             flagcomienzo = 0; 
1D58:  CLRF   5F
....................             perforacion(); 
1D5A:  BRA    1876
....................             salir = 0; 
1D5C:  CLRF   36
1D5E:  BRA    1C5A
....................         } 
1D60:  BRA    19B8
....................     } 
.................... } 
1D62:  SLEEP 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
