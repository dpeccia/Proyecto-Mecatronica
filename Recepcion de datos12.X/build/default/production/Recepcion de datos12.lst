CCS PCH C Compiler, Version 5.015, 59972               11-oct.-18 00:39

               Filename:   E:\Proyecto\GUI\Recepcion de datos12.X\build\default\production\Recepcion de datos12.lst

               ROM used:   7770 bytes (24%)
                           Largest free fragment is 24994
               RAM used:   122 (6%) at main() level
                           158 (8%) worst case
               Stack used: 10 locations (8 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   1AC2
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   0210
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   02DE
0060:  BTFSS  FF2.4
0062:  GOTO   006C
0066:  BTFSC  FF2.1
0068:  GOTO   0192
006C:  BTFSS  FF0.4
006E:  GOTO   0078
0072:  BTFSC  FF0.1
0074:  GOTO   013A
0078:  BTFSS  F9D.5
007A:  GOTO   0084
007E:  BTFSC  F9E.5
0080:  GOTO   02F6
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVF   04,W
00BC:  MOVFF  06,FE0
00C0:  MOVFF  05,FD8
00C4:  RETFIE 0
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00C6:  DATA 41,6A
00C8:  DATA 75,73
00CA:  DATA 74,61
00CC:  DATA 6E,64
00CE:  DATA 6F,20
00D0:  DATA 5A,00
00D2:  DATA 50,72
00D4:  DATA 6F,66
00D6:  DATA 75,6E
00D8:  DATA 64,69
00DA:  DATA 64,61
00DC:  DATA 64,20
00DE:  DATA 64,65
00E0:  DATA 20,6D
00E2:  DATA 65,63
00E4:  DATA 68,61
00E6:  DATA 00,00
00E8:  DATA 42,75
00EA:  DATA 73,63
00EC:  DATA 61,6E
00EE:  DATA 64,6F
00F0:  DATA 20,63
00F2:  DATA 65,72
00F4:  DATA 6F,20
00F6:  DATA 5A,00
00F8:  DATA 42,75
00FA:  DATA 73,63
00FC:  DATA 61,6E
00FE:  DATA 64,6F
0100:  DATA 20,63
0102:  DATA 65,72
0104:  DATA 6F,20
0106:  DATA 5A,20
0108:  DATA 4F,4B
010A:  DATA 00,00
010C:  DATA 41,6A
010E:  DATA 75,73
0110:  DATA 74,61
0112:  DATA 6E,64
0114:  DATA 6F,20
0116:  DATA 65,6A
0118:  DATA 65,73
011A:  DATA 20,58
011C:  DATA 2D,59
011E:  DATA 00,00
0120:  DATA 45,73
0122:  DATA 70,65
0124:  DATA 72,65
0126:  DATA 20,70
0128:  DATA 6F,72
012A:  DATA 20,66
012C:  DATA 61,76
012E:  DATA 6F,72
0130:  DATA 00,00
*
03D8:  DATA 0C,01
03DA:  DATA 50,6F
03DC:  DATA 72,20
03DE:  DATA 66,61
03E0:  DATA 76,6F
03E2:  DATA 72,20
03E4:  DATA 63,6F
03E6:  DATA 6C,6F
03E8:  DATA 71,75
03EA:  DATA 65,00
03EC:  DATA 02,6D
03EE:  DATA 65,63
03F0:  DATA 68,61
03F2:  DATA 20,64
03F4:  DATA 65,20
03F6:  DATA 25,30
03F8:  DATA 31,2E
03FA:  DATA 32,66
03FC:  DATA 6D,6D
03FE:  DATA 20,79
0400:  DATA 00,00
0402:  DATA 03,70
0404:  DATA 72,65
0406:  DATA 73,69
0408:  DATA 6F,6E
040A:  DATA 65,20
040C:  DATA 65,6E
040E:  DATA 74,65
0410:  DATA 72,00
0412:  DATA 43,00
0414:  DATA 0C,48
0416:  DATA 41,47
0418:  DATA 41,20
041A:  DATA 43,4C
041C:  DATA 49,43
041E:  DATA 4B,20
0420:  DATA 45,4E
0422:  DATA 00,00
0424:  DATA 02,43
0426:  DATA 41,4C
0428:  DATA 49,42
042A:  DATA 52,41
042C:  DATA 52,20
042E:  DATA 45,4E
0430:  DATA 20,4C
0432:  DATA 41,00
0434:  DATA 03,43
0436:  DATA 4F,4D
0438:  DATA 50,55
043A:  DATA 54,41
043C:  DATA 44,4F
043E:  DATA 52,41
0440:  DATA 20,59
0442:  DATA 20,45
0444:  DATA 53,50
0446:  DATA 45,52
0448:  DATA 45,00
044A:  DATA 04,55
044C:  DATA 4E,20
044E:  DATA 4D,4F
0450:  DATA 4D,45
0452:  DATA 4E,54
0454:  DATA 4F,2E
0456:  DATA 00,00
0458:  DATA 0C,01
045A:  DATA 43,6F
045C:  DATA 6C,6F
045E:  DATA 71,75
0460:  DATA 65,20
0462:  DATA 6D,65
0464:  DATA 63,68
0466:  DATA 61,20
0468:  DATA 25,30
046A:  DATA 31,2E
046C:  DATA 32,66
046E:  DATA 6D,6D
0470:  DATA 00,00
0472:  DATA 02,50
0474:  DATA 72,65
0476:  DATA 73,69
0478:  DATA 6F,6E
047A:  DATA 65,20
047C:  DATA 65,6E
047E:  DATA 74,65
0480:  DATA 72,20
0482:  DATA 70,61
0484:  DATA 72,61
0486:  DATA 00,00
0488:  DATA 03,63
048A:  DATA 6F,6D
048C:  DATA 65,6E
048E:  DATA 7A,61
0490:  DATA 72,20
0492:  DATA 65,6C
0494:  DATA 20,61
0496:  DATA 6A,75
0498:  DATA 73,74
049A:  DATA 65,00
049C:  DATA 04,64
049E:  DATA 65,20
04A0:  DATA 6C,61
04A2:  DATA 20,70
04A4:  DATA 6C,61
04A6:  DATA 63,61
04A8:  DATA 2E,00
04AA:  DATA 0C,01
04AC:  DATA 47,69
04AE:  DATA 72,65
04B0:  DATA 20,70
04B2:  DATA 61,72
04B4:  DATA 61,20
04B6:  DATA 73,75
04B8:  DATA 62,69
04BA:  DATA 72,20
04BC:  DATA 6F,00
04BE:  DATA 02,62
04C0:  DATA 61,6A
04C2:  DATA 61,72
04C4:  DATA 20,6D
04C6:  DATA 65,63
04C8:  DATA 68,61
04CA:  DATA 2E,50
04CC:  DATA 72,65
04CE:  DATA 73,69
04D0:  DATA 6F,6E
04D2:  DATA 65,00
04D4:  DATA 03,65
04D6:  DATA 6E,74
04D8:  DATA 65,72
04DA:  DATA 20,6E
04DC:  DATA 75,65
04DE:  DATA 76,6F
04E0:  DATA 20,70
04E2:  DATA 75,6E
04E4:  DATA 74,6F
04E6:  DATA 2E,00
04E8:  DATA 04,42
04EA:  DATA 6F,74
04EC:  DATA 6F,6E
04EE:  DATA 20,72
04F0:  DATA 6F,6A
04F2:  DATA 6F,20
04F4:  DATA 73,61
04F6:  DATA 6C,69
04F8:  DATA 72,2E
04FA:  DATA 00,00
04FC:  DATA 0C,01
04FE:  DATA 50,65
0500:  DATA 72,66
0502:  DATA 6F,72
0504:  DATA 61,64
0506:  DATA 6F,72
0508:  DATA 61,20
050A:  DATA 4C,69
050C:  DATA 73,74
050E:  DATA 61,00
0510:  DATA 02,70
0512:  DATA 61,72
0514:  DATA 61,20
0516:  DATA 6F,70
0518:  DATA 65,72
051A:  DATA 61,72
051C:  DATA 20,68
051E:  DATA 61,67
0520:  DATA 61,20
0522:  DATA 63,6C
0524:  DATA 69,63
0526:  DATA 6B,00
0528:  DATA 03,65
052A:  DATA 6E,20
052C:  DATA 22,43
052E:  DATA 6F,6D
0530:  DATA 65,6E
0532:  DATA 7A,61
0534:  DATA 72,22
0536:  DATA 00,00
0538:  DATA 0C,01
053A:  DATA 50,45
053C:  DATA 52,46
053E:  DATA 4F,52
0540:  DATA 41,4E
0542:  DATA 44,4F
0544:  DATA 00,00
*
0798:  TBLRD*+
079A:  MOVF   FF5,F
079C:  BZ    07B6
079E:  MOVFF  FF6,79
07A2:  MOVFF  FF7,7A
07A6:  MOVFF  FF5,86
07AA:  RCALL  072A
07AC:  MOVFF  79,FF6
07B0:  MOVFF  7A,FF7
07B4:  BRA    0798
07B6:  RETURN 0
*
08C0:  MOVLW  B6
08C2:  MOVWF  00
08C4:  CLRF   03
08C6:  CLRF   02
08C8:  CLRF   01
08CA:  BCF    x81.0
08CC:  BTFSS  x80.7
08CE:  BRA    08E8
08D0:  BSF    x81.0
08D2:  COMF   x7D,F
08D4:  COMF   x7E,F
08D6:  COMF   x7F,F
08D8:  COMF   x80,F
08DA:  INCF   x7D,F
08DC:  BNZ   08E8
08DE:  INCF   x7E,F
08E0:  BNZ   08E8
08E2:  INCF   x7F,F
08E4:  BTFSC  FD8.2
08E6:  INCF   x80,F
08E8:  MOVF   x7D,W
08EA:  IORWF  x7E,W
08EC:  IORWF  x7F,W
08EE:  IORWF  x80,W
08F0:  BNZ   08F6
08F2:  CLRF   00
08F4:  BRA    0914
08F6:  BCF    FD8.0
08F8:  BTFSC  01.7
08FA:  BRA    090E
08FC:  RLCF   x7D,F
08FE:  RLCF   x7E,F
0900:  RLCF   x7F,F
0902:  RLCF   x80,F
0904:  RLCF   03,F
0906:  RLCF   02,F
0908:  RLCF   01,F
090A:  DECFSZ 00,F
090C:  BRA    08F6
090E:  BCF    01.7
0910:  BTFSC  x81.0
0912:  BSF    01.7
0914:  RETURN 0
0916:  MOVF   x8C,W
0918:  BTFSC  FD8.2
091A:  BRA    0A66
091C:  MOVWF  x98
091E:  MOVF   x90,W
0920:  BTFSC  FD8.2
0922:  BRA    0A66
0924:  SUBWF  x98,F
0926:  BNC   0932
0928:  MOVLW  7F
092A:  ADDWF  x98,F
092C:  BTFSC  FD8.0
092E:  BRA    0A66
0930:  BRA    093E
0932:  MOVLW  81
0934:  SUBWF  x98,F
0936:  BTFSS  FD8.0
0938:  BRA    0A66
093A:  BTFSC  FD8.2
093C:  BRA    0A66
093E:  MOVFF  98,00
0942:  CLRF   01
0944:  CLRF   02
0946:  CLRF   03
0948:  CLRF   x97
094A:  MOVFF  8D,96
094E:  BSF    x96.7
0950:  MOVFF  8E,95
0954:  MOVFF  8F,94
0958:  MOVLW  19
095A:  MOVWF  x98
095C:  MOVF   x93,W
095E:  SUBWF  x94,F
0960:  BC    097C
0962:  MOVLW  01
0964:  SUBWF  x95,F
0966:  BC    097C
0968:  SUBWF  x96,F
096A:  BC    097C
096C:  SUBWF  x97,F
096E:  BC    097C
0970:  INCF   x97,F
0972:  INCF   x96,F
0974:  INCF   x95,F
0976:  MOVF   x93,W
0978:  ADDWF  x94,F
097A:  BRA    09CC
097C:  MOVF   x92,W
097E:  SUBWF  x95,F
0980:  BC    09A6
0982:  MOVLW  01
0984:  SUBWF  x96,F
0986:  BC    09A6
0988:  SUBWF  x97,F
098A:  BC    09A6
098C:  INCF   x97,F
098E:  INCF   x96,F
0990:  MOVF   x92,W
0992:  ADDWF  x95,F
0994:  MOVF   x93,W
0996:  ADDWF  x94,F
0998:  BNC   09CC
099A:  INCF   x95,F
099C:  BNZ   09CC
099E:  INCF   x96,F
09A0:  BNZ   09CC
09A2:  INCF   x97,F
09A4:  BRA    09CC
09A6:  MOVF   x91,W
09A8:  IORLW  80
09AA:  SUBWF  x96,F
09AC:  BC    09CA
09AE:  MOVLW  01
09B0:  SUBWF  x97,F
09B2:  BC    09CA
09B4:  INCF   x97,F
09B6:  MOVF   x91,W
09B8:  IORLW  80
09BA:  ADDWF  x96,F
09BC:  MOVF   x92,W
09BE:  ADDWF  x95,F
09C0:  BNC   0994
09C2:  INCF   x96,F
09C4:  BNZ   0994
09C6:  INCF   x97,F
09C8:  BRA    0994
09CA:  BSF    03.0
09CC:  DECFSZ x98,F
09CE:  BRA    09D2
09D0:  BRA    09E8
09D2:  BCF    FD8.0
09D4:  RLCF   x94,F
09D6:  RLCF   x95,F
09D8:  RLCF   x96,F
09DA:  RLCF   x97,F
09DC:  BCF    FD8.0
09DE:  RLCF   03,F
09E0:  RLCF   02,F
09E2:  RLCF   01,F
09E4:  RLCF   x99,F
09E6:  BRA    095C
09E8:  BTFSS  x99.0
09EA:  BRA    09F8
09EC:  BCF    FD8.0
09EE:  RRCF   01,F
09F0:  RRCF   02,F
09F2:  RRCF   03,F
09F4:  RRCF   x99,F
09F6:  BRA    09FC
09F8:  DECF   00,F
09FA:  BZ    0A66
09FC:  BTFSC  x99.7
09FE:  BRA    0A3C
0A00:  BCF    FD8.0
0A02:  RLCF   x94,F
0A04:  RLCF   x95,F
0A06:  RLCF   x96,F
0A08:  RLCF   x97,F
0A0A:  MOVF   x93,W
0A0C:  SUBWF  x94,F
0A0E:  BC    0A1E
0A10:  MOVLW  01
0A12:  SUBWF  x95,F
0A14:  BC    0A1E
0A16:  SUBWF  x96,F
0A18:  BC    0A1E
0A1A:  SUBWF  x97,F
0A1C:  BNC   0A52
0A1E:  MOVF   x92,W
0A20:  SUBWF  x95,F
0A22:  BC    0A2E
0A24:  MOVLW  01
0A26:  SUBWF  x96,F
0A28:  BC    0A2E
0A2A:  SUBWF  x97,F
0A2C:  BNC   0A52
0A2E:  MOVF   x91,W
0A30:  IORLW  80
0A32:  SUBWF  x96,F
0A34:  BC    0A3C
0A36:  MOVLW  01
0A38:  SUBWF  x97,F
0A3A:  BNC   0A52
0A3C:  INCF   03,F
0A3E:  BNZ   0A52
0A40:  INCF   02,F
0A42:  BNZ   0A52
0A44:  INCF   01,F
0A46:  BNZ   0A52
0A48:  INCF   00,F
0A4A:  BZ    0A66
0A4C:  RRCF   01,F
0A4E:  RRCF   02,F
0A50:  RRCF   03,F
0A52:  MOVFF  8D,98
0A56:  MOVF   x91,W
0A58:  XORWF  x98,F
0A5A:  BTFSS  x98.7
0A5C:  BRA    0A62
0A5E:  BSF    01.7
0A60:  BRA    0A6E
0A62:  BCF    01.7
0A64:  BRA    0A6E
0A66:  CLRF   00
0A68:  CLRF   01
0A6A:  CLRF   02
0A6C:  CLRF   03
0A6E:  RETURN 0
0A70:  MOVFF  7A,81
0A74:  MOVF   x7E,W
0A76:  XORWF  x81,F
0A78:  BTFSS  x81.7
0A7A:  BRA    0A86
0A7C:  BCF    FD8.2
0A7E:  BCF    FD8.0
0A80:  BTFSC  x7A.7
0A82:  BSF    FD8.0
0A84:  BRA    0AE4
0A86:  MOVFF  7A,81
0A8A:  MOVFF  7D,82
0A8E:  MOVF   x79,W
0A90:  SUBWF  x82,F
0A92:  BZ    0AA0
0A94:  BTFSS  x81.7
0A96:  BRA    0AE4
0A98:  MOVF   FD8,W
0A9A:  XORLW  01
0A9C:  MOVWF  FD8
0A9E:  BRA    0AE4
0AA0:  MOVFF  7E,82
0AA4:  MOVF   x7A,W
0AA6:  SUBWF  x82,F
0AA8:  BZ    0AB6
0AAA:  BTFSS  x81.7
0AAC:  BRA    0AE4
0AAE:  MOVF   FD8,W
0AB0:  XORLW  01
0AB2:  MOVWF  FD8
0AB4:  BRA    0AE4
0AB6:  MOVFF  7F,82
0ABA:  MOVF   x7B,W
0ABC:  SUBWF  x82,F
0ABE:  BZ    0ACC
0AC0:  BTFSS  x81.7
0AC2:  BRA    0AE4
0AC4:  MOVF   FD8,W
0AC6:  XORLW  01
0AC8:  MOVWF  FD8
0ACA:  BRA    0AE4
0ACC:  MOVFF  80,82
0AD0:  MOVF   x7C,W
0AD2:  SUBWF  x82,F
0AD4:  BZ    0AE2
0AD6:  BTFSS  x81.7
0AD8:  BRA    0AE4
0ADA:  MOVF   FD8,W
0ADC:  XORLW  01
0ADE:  MOVWF  FD8
0AE0:  BRA    0AE4
0AE2:  BCF    FD8.0
0AE4:  RETURN 0
0AE6:  MOVLW  80
0AE8:  BTFSC  FD8.1
0AEA:  XORWF  x91,F
0AEC:  CLRF   x96
0AEE:  CLRF   x97
0AF0:  MOVFF  8D,95
0AF4:  MOVF   x91,W
0AF6:  XORWF  x95,F
0AF8:  MOVF   x8C,W
0AFA:  BTFSC  FD8.2
0AFC:  BRA    0CB6
0AFE:  MOVWF  x94
0B00:  MOVWF  00
0B02:  MOVF   x90,W
0B04:  BTFSC  FD8.2
0B06:  BRA    0CC8
0B08:  SUBWF  x94,F
0B0A:  BTFSC  FD8.2
0B0C:  BRA    0C10
0B0E:  BNC   0B8A
0B10:  MOVFF  91,9A
0B14:  BSF    x9A.7
0B16:  MOVFF  92,99
0B1A:  MOVFF  93,98
0B1E:  CLRF   x97
0B20:  BCF    FD8.0
0B22:  RRCF   x9A,F
0B24:  RRCF   x99,F
0B26:  RRCF   x98,F
0B28:  RRCF   x97,F
0B2A:  DECFSZ x94,F
0B2C:  BRA    0B1E
0B2E:  BTFSS  x95.7
0B30:  BRA    0B38
0B32:  BSF    x96.0
0B34:  BRA    0CF0
0B36:  BCF    x96.0
0B38:  BCF    x94.0
0B3A:  BSF    x96.4
0B3C:  CLRF   FEA
0B3E:  MOVLW  8F
0B40:  MOVWF  FE9
0B42:  BRA    0D16
0B44:  BCF    x96.4
0B46:  BTFSC  x95.7
0B48:  BRA    0B5E
0B4A:  BTFSS  x94.0
0B4C:  BRA    0B74
0B4E:  RRCF   x9A,F
0B50:  RRCF   x99,F
0B52:  RRCF   x98,F
0B54:  RRCF   x97,F
0B56:  INCF   00,F
0B58:  BTFSC  FD8.2
0B5A:  BRA    0CE6
0B5C:  BRA    0B74
0B5E:  BTFSC  x9A.7
0B60:  BRA    0B7A
0B62:  BCF    FD8.0
0B64:  RLCF   x97,F
0B66:  RLCF   x98,F
0B68:  RLCF   x99,F
0B6A:  RLCF   x9A,F
0B6C:  DECF   00,F
0B6E:  BTFSC  FD8.2
0B70:  BRA    0CE6
0B72:  BRA    0B5E
0B74:  BSF    x96.6
0B76:  BRA    0C4E
0B78:  BCF    x96.6
0B7A:  MOVFF  8D,95
0B7E:  BTFSS  x8D.7
0B80:  BRA    0B86
0B82:  BSF    x9A.7
0B84:  BRA    0CD8
0B86:  BCF    x9A.7
0B88:  BRA    0CD8
0B8A:  MOVFF  90,94
0B8E:  MOVFF  90,00
0B92:  MOVF   x8C,W
0B94:  SUBWF  x94,F
0B96:  MOVFF  8D,9A
0B9A:  BSF    x9A.7
0B9C:  MOVFF  8E,99
0BA0:  MOVFF  8F,98
0BA4:  CLRF   x97
0BA6:  BCF    FD8.0
0BA8:  RRCF   x9A,F
0BAA:  RRCF   x99,F
0BAC:  RRCF   x98,F
0BAE:  RRCF   x97,F
0BB0:  DECFSZ x94,F
0BB2:  BRA    0BA4
0BB4:  BTFSS  x95.7
0BB6:  BRA    0BBE
0BB8:  BSF    x96.1
0BBA:  BRA    0CF0
0BBC:  BCF    x96.1
0BBE:  BCF    x94.0
0BC0:  BSF    x96.5
0BC2:  CLRF   FEA
0BC4:  MOVLW  93
0BC6:  MOVWF  FE9
0BC8:  BRA    0D16
0BCA:  BCF    x96.5
0BCC:  BTFSC  x95.7
0BCE:  BRA    0BE4
0BD0:  BTFSS  x94.0
0BD2:  BRA    0BFA
0BD4:  RRCF   x9A,F
0BD6:  RRCF   x99,F
0BD8:  RRCF   x98,F
0BDA:  RRCF   x97,F
0BDC:  INCF   00,F
0BDE:  BTFSC  FD8.2
0BE0:  BRA    0CE6
0BE2:  BRA    0BFA
0BE4:  BTFSC  x9A.7
0BE6:  BRA    0C00
0BE8:  BCF    FD8.0
0BEA:  RLCF   x97,F
0BEC:  RLCF   x98,F
0BEE:  RLCF   x99,F
0BF0:  RLCF   x9A,F
0BF2:  DECF   00,F
0BF4:  BTFSC  FD8.2
0BF6:  BRA    0CE6
0BF8:  BRA    0BE4
0BFA:  BSF    x96.7
0BFC:  BRA    0C4E
0BFE:  BCF    x96.7
0C00:  MOVFF  91,95
0C04:  BTFSS  x91.7
0C06:  BRA    0C0C
0C08:  BSF    x9A.7
0C0A:  BRA    0CD8
0C0C:  BCF    x9A.7
0C0E:  BRA    0CD8
0C10:  MOVFF  91,9A
0C14:  BSF    x9A.7
0C16:  MOVFF  92,99
0C1A:  MOVFF  93,98
0C1E:  BTFSS  x95.7
0C20:  BRA    0C2A
0C22:  BCF    x9A.7
0C24:  BSF    x96.2
0C26:  BRA    0CF0
0C28:  BCF    x96.2
0C2A:  CLRF   x97
0C2C:  BCF    x94.0
0C2E:  CLRF   FEA
0C30:  MOVLW  8F
0C32:  MOVWF  FE9
0C34:  BRA    0D16
0C36:  BTFSC  x95.7
0C38:  BRA    0C72
0C3A:  MOVFF  8D,95
0C3E:  BTFSS  x94.0
0C40:  BRA    0C4E
0C42:  RRCF   x9A,F
0C44:  RRCF   x99,F
0C46:  RRCF   x98,F
0C48:  RRCF   x97,F
0C4A:  INCF   00,F
0C4C:  BZ    0CE6
0C4E:  BTFSS  x97.7
0C50:  BRA    0C68
0C52:  INCF   x98,F
0C54:  BNZ   0C68
0C56:  INCF   x99,F
0C58:  BNZ   0C68
0C5A:  INCF   x9A,F
0C5C:  BNZ   0C68
0C5E:  RRCF   x9A,F
0C60:  RRCF   x99,F
0C62:  RRCF   x98,F
0C64:  INCF   00,F
0C66:  BZ    0CE6
0C68:  BTFSC  x96.6
0C6A:  BRA    0B78
0C6C:  BTFSC  x96.7
0C6E:  BRA    0BFE
0C70:  BRA    0CAA
0C72:  MOVLW  80
0C74:  XORWF  x9A,F
0C76:  BTFSS  x9A.7
0C78:  BRA    0C82
0C7A:  BRA    0CF0
0C7C:  MOVFF  91,95
0C80:  BRA    0C96
0C82:  MOVFF  8D,95
0C86:  MOVF   x9A,F
0C88:  BNZ   0C96
0C8A:  MOVF   x99,F
0C8C:  BNZ   0C96
0C8E:  MOVF   x98,F
0C90:  BNZ   0C96
0C92:  CLRF   00
0C94:  BRA    0CD8
0C96:  BTFSC  x9A.7
0C98:  BRA    0CAA
0C9A:  BCF    FD8.0
0C9C:  RLCF   x97,F
0C9E:  RLCF   x98,F
0CA0:  RLCF   x99,F
0CA2:  RLCF   x9A,F
0CA4:  DECFSZ 00,F
0CA6:  BRA    0C96
0CA8:  BRA    0CE6
0CAA:  BTFSS  x95.7
0CAC:  BRA    0CB2
0CAE:  BSF    x9A.7
0CB0:  BRA    0CD8
0CB2:  BCF    x9A.7
0CB4:  BRA    0CD8
0CB6:  MOVFF  90,00
0CBA:  MOVFF  91,9A
0CBE:  MOVFF  92,99
0CC2:  MOVFF  93,98
0CC6:  BRA    0CD8
0CC8:  MOVFF  8C,00
0CCC:  MOVFF  8D,9A
0CD0:  MOVFF  8E,99
0CD4:  MOVFF  8F,98
0CD8:  MOVFF  9A,01
0CDC:  MOVFF  99,02
0CE0:  MOVFF  98,03
0CE4:  BRA    0D4E
0CE6:  CLRF   00
0CE8:  CLRF   01
0CEA:  CLRF   02
0CEC:  CLRF   03
0CEE:  BRA    0D4E
0CF0:  CLRF   x97
0CF2:  COMF   x98,F
0CF4:  COMF   x99,F
0CF6:  COMF   x9A,F
0CF8:  COMF   x97,F
0CFA:  INCF   x97,F
0CFC:  BNZ   0D08
0CFE:  INCF   x98,F
0D00:  BNZ   0D08
0D02:  INCF   x99,F
0D04:  BNZ   0D08
0D06:  INCF   x9A,F
0D08:  BTFSC  x96.0
0D0A:  BRA    0B36
0D0C:  BTFSC  x96.1
0D0E:  BRA    0BBC
0D10:  BTFSC  x96.2
0D12:  BRA    0C28
0D14:  BRA    0C7C
0D16:  MOVF   FEF,W
0D18:  ADDWF  x98,F
0D1A:  BNC   0D26
0D1C:  INCF   x99,F
0D1E:  BNZ   0D26
0D20:  INCF   x9A,F
0D22:  BTFSC  FD8.2
0D24:  BSF    x94.0
0D26:  MOVF   FED,F
0D28:  MOVF   FEF,W
0D2A:  ADDWF  x99,F
0D2C:  BNC   0D34
0D2E:  INCF   x9A,F
0D30:  BTFSC  FD8.2
0D32:  BSF    x94.0
0D34:  MOVF   FED,F
0D36:  MOVF   FEF,W
0D38:  BTFSC  FEF.7
0D3A:  BRA    0D3E
0D3C:  XORLW  80
0D3E:  ADDWF  x9A,F
0D40:  BTFSC  FD8.0
0D42:  BSF    x94.0
0D44:  BTFSC  x96.4
0D46:  BRA    0B44
0D48:  BTFSC  x96.5
0D4A:  BRA    0BCA
0D4C:  BRA    0C36
0D4E:  RETURN 0
0D50:  MOVLW  8E
0D52:  MOVWF  00
0D54:  MOVF   x79,W
0D56:  SUBWF  00,F
0D58:  MOVFF  7A,02
0D5C:  MOVFF  7B,01
0D60:  BSF    02.7
0D62:  MOVF   00,F
0D64:  BZ    0D78
0D66:  BCF    FD8.0
0D68:  MOVF   02,F
0D6A:  BNZ   0D70
0D6C:  MOVF   01,F
0D6E:  BZ    0D78
0D70:  RRCF   02,F
0D72:  RRCF   01,F
0D74:  DECFSZ 00,F
0D76:  BRA    0D66
0D78:  BTFSS  x7A.7
0D7A:  BRA    0D86
0D7C:  COMF   01,F
0D7E:  COMF   02,F
0D80:  INCF   01,F
0D82:  BTFSC  FD8.2
0D84:  INCF   02,F
0D86:  RETURN 0
0D88:  CLRF   x81
0D8A:  CLRF   x82
0D8C:  MOVLW  01
0D8E:  MOVWF  x83
0D90:  CLRF   FDA
0D92:  CLRF   FD9
0D94:  CLRF   x86
0D96:  MOVLW  79
0D98:  MOVWF  x85
0D9A:  CLRF   FEA
0D9C:  MOVLW  7D
0D9E:  MOVWF  FE9
0DA0:  MOVFF  86,FE2
0DA4:  MOVFF  85,FE1
0DA8:  MOVFF  83,84
0DAC:  BCF    FD8.0
0DAE:  MOVF   FE5,W
0DB0:  MULWF  FEE
0DB2:  MOVF   FF3,W
0DB4:  ADDWFC x81,F
0DB6:  MOVF   FF4,W
0DB8:  ADDWFC x82,F
0DBA:  DECFSZ x84,F
0DBC:  BRA    0DAC
0DBE:  MOVFF  81,FDE
0DC2:  MOVFF  82,81
0DC6:  CLRF   x82
0DC8:  BTFSC  FD8.0
0DCA:  INCF   x82,F
0DCC:  INCF   x85,F
0DCE:  BTFSC  FD8.2
0DD0:  INCF   x86,F
0DD2:  INCF   x83,F
0DD4:  MOVF   x83,W
0DD6:  SUBLW  05
0DD8:  BNZ   0D9A
0DDA:  RETURN 0
*
10DA:  MOVF   x88,W
10DC:  BTFSC  FD8.2
10DE:  BRA    11C2
10E0:  MOVWF  00
10E2:  MOVF   x8C,W
10E4:  BTFSC  FD8.2
10E6:  BRA    11C2
10E8:  ADDWF  00,F
10EA:  BNC   10F4
10EC:  MOVLW  81
10EE:  ADDWF  00,F
10F0:  BC    11C2
10F2:  BRA    10FC
10F4:  MOVLW  7F
10F6:  SUBWF  00,F
10F8:  BNC   11C2
10FA:  BZ    11C2
10FC:  MOVFF  89,90
1100:  MOVF   x8D,W
1102:  XORWF  x90,F
1104:  BSF    x89.7
1106:  BSF    x8D.7
1108:  MOVF   x8B,W
110A:  MULWF  x8F
110C:  MOVFF  FF4,92
1110:  MOVF   x8A,W
1112:  MULWF  x8E
1114:  MOVFF  FF4,03
1118:  MOVFF  FF3,91
111C:  MULWF  x8F
111E:  MOVF   FF3,W
1120:  ADDWF  x92,F
1122:  MOVF   FF4,W
1124:  ADDWFC x91,F
1126:  MOVLW  00
1128:  ADDWFC 03,F
112A:  MOVF   x8B,W
112C:  MULWF  x8E
112E:  MOVF   FF3,W
1130:  ADDWF  x92,F
1132:  MOVF   FF4,W
1134:  ADDWFC x91,F
1136:  MOVLW  00
1138:  CLRF   02
113A:  ADDWFC 03,F
113C:  ADDWFC 02,F
113E:  MOVF   x89,W
1140:  MULWF  x8F
1142:  MOVF   FF3,W
1144:  ADDWF  x91,F
1146:  MOVF   FF4,W
1148:  ADDWFC 03,F
114A:  MOVLW  00
114C:  ADDWFC 02,F
114E:  MOVF   x89,W
1150:  MULWF  x8E
1152:  MOVF   FF3,W
1154:  ADDWF  03,F
1156:  MOVF   FF4,W
1158:  ADDWFC 02,F
115A:  MOVLW  00
115C:  CLRF   01
115E:  ADDWFC 01,F
1160:  MOVF   x8B,W
1162:  MULWF  x8D
1164:  MOVF   FF3,W
1166:  ADDWF  x91,F
1168:  MOVF   FF4,W
116A:  ADDWFC 03,F
116C:  MOVLW  00
116E:  ADDWFC 02,F
1170:  ADDWFC 01,F
1172:  MOVF   x8A,W
1174:  MULWF  x8D
1176:  MOVF   FF3,W
1178:  ADDWF  03,F
117A:  MOVF   FF4,W
117C:  ADDWFC 02,F
117E:  MOVLW  00
1180:  ADDWFC 01,F
1182:  MOVF   x89,W
1184:  MULWF  x8D
1186:  MOVF   FF3,W
1188:  ADDWF  02,F
118A:  MOVF   FF4,W
118C:  ADDWFC 01,F
118E:  INCF   00,F
1190:  BTFSC  01.7
1192:  BRA    119E
1194:  RLCF   x91,F
1196:  RLCF   03,F
1198:  RLCF   02,F
119A:  RLCF   01,F
119C:  DECF   00,F
119E:  MOVLW  00
11A0:  BTFSS  x91.7
11A2:  BRA    11B8
11A4:  INCF   03,F
11A6:  ADDWFC 02,F
11A8:  ADDWFC 01,F
11AA:  MOVF   01,W
11AC:  BNZ   11B8
11AE:  MOVF   02,W
11B0:  BNZ   11B8
11B2:  MOVF   03,W
11B4:  BNZ   11B8
11B6:  INCF   00,F
11B8:  BTFSC  x90.7
11BA:  BSF    01.7
11BC:  BTFSS  x90.7
11BE:  BCF    01.7
11C0:  BRA    11CA
11C2:  CLRF   00
11C4:  CLRF   01
11C6:  CLRF   02
11C8:  CLRF   03
11CA:  RETURN 0
11CC:  MOVLW  8E
11CE:  MOVWF  00
11D0:  MOVFF  8D,01
11D4:  MOVFF  8C,02
11D8:  CLRF   03
11DA:  MOVF   01,F
11DC:  BNZ   11F0
11DE:  MOVFF  02,01
11E2:  CLRF   02
11E4:  MOVLW  08
11E6:  SUBWF  00,F
11E8:  MOVF   01,F
11EA:  BNZ   11F0
11EC:  CLRF   00
11EE:  BRA    1200
11F0:  BCF    FD8.0
11F2:  BTFSC  01.7
11F4:  BRA    11FE
11F6:  RLCF   02,F
11F8:  RLCF   01,F
11FA:  DECF   00,F
11FC:  BRA    11F0
11FE:  BCF    01.7
1200:  RETURN 0
*
1462:  TBLRD*+
1464:  MOVFF  FF6,7A
1468:  MOVFF  FF7,7B
146C:  MOVFF  FF5,86
1470:  CALL   072A
1474:  MOVFF  7A,FF6
1478:  MOVFF  7B,FF7
147C:  DECFSZ x79,F
147E:  BRA    1462
1480:  RETURN 0
1482:  MOVF   x86,W
1484:  SUBLW  B6
1486:  MOVWF  x86
1488:  CLRF   03
148A:  MOVFF  87,8A
148E:  BSF    x87.7
1490:  BCF    FD8.0
1492:  RRCF   x87,F
1494:  RRCF   x88,F
1496:  RRCF   x89,F
1498:  RRCF   03,F
149A:  RRCF   02,F
149C:  RRCF   01,F
149E:  RRCF   00,F
14A0:  DECFSZ x86,F
14A2:  BRA    1490
14A4:  BTFSS  x8A.7
14A6:  BRA    14BE
14A8:  COMF   00,F
14AA:  COMF   01,F
14AC:  COMF   02,F
14AE:  COMF   03,F
14B0:  INCF   00,F
14B2:  BTFSC  FD8.2
14B4:  INCF   01,F
14B6:  BTFSC  FD8.2
14B8:  INCF   02,F
14BA:  BTFSC  FD8.2
14BC:  INCF   03,F
14BE:  RETURN 0
14C0:  BTFSC  FD8.1
14C2:  BRA    14CA
14C4:  CLRF   FEA
14C6:  MOVLW  8E
14C8:  MOVWF  FE9
14CA:  CLRF   00
14CC:  CLRF   01
14CE:  CLRF   02
14D0:  CLRF   03
14D2:  CLRF   x8E
14D4:  CLRF   x8F
14D6:  CLRF   x90
14D8:  CLRF   x91
14DA:  MOVF   x8D,W
14DC:  IORWF  x8C,W
14DE:  IORWF  x8B,W
14E0:  IORWF  x8A,W
14E2:  BZ    153C
14E4:  MOVLW  20
14E6:  MOVWF  x92
14E8:  BCF    FD8.0
14EA:  RLCF   x86,F
14EC:  RLCF   x87,F
14EE:  RLCF   x88,F
14F0:  RLCF   x89,F
14F2:  RLCF   x8E,F
14F4:  RLCF   x8F,F
14F6:  RLCF   x90,F
14F8:  RLCF   x91,F
14FA:  MOVF   x8D,W
14FC:  SUBWF  x91,W
14FE:  BNZ   1510
1500:  MOVF   x8C,W
1502:  SUBWF  x90,W
1504:  BNZ   1510
1506:  MOVF   x8B,W
1508:  SUBWF  x8F,W
150A:  BNZ   1510
150C:  MOVF   x8A,W
150E:  SUBWF  x8E,W
1510:  BNC   1530
1512:  MOVF   x8A,W
1514:  SUBWF  x8E,F
1516:  MOVF   x8B,W
1518:  BTFSS  FD8.0
151A:  INCFSZ x8B,W
151C:  SUBWF  x8F,F
151E:  MOVF   x8C,W
1520:  BTFSS  FD8.0
1522:  INCFSZ x8C,W
1524:  SUBWF  x90,F
1526:  MOVF   x8D,W
1528:  BTFSS  FD8.0
152A:  INCFSZ x8D,W
152C:  SUBWF  x91,F
152E:  BSF    FD8.0
1530:  RLCF   00,F
1532:  RLCF   01,F
1534:  RLCF   02,F
1536:  RLCF   03,F
1538:  DECFSZ x92,F
153A:  BRA    14E8
153C:  MOVFF  8E,FEF
1540:  MOVFF  8F,FEC
1544:  MOVFF  90,FEC
1548:  MOVFF  91,FEC
154C:  RETURN 0
154E:  MOVF   FE9,W
1550:  MOVWF  x7E
1552:  MOVF   x7D,W
1554:  MOVWF  x80
1556:  BZ    158A
1558:  MOVFF  7C,8B
155C:  MOVFF  7B,8A
1560:  MOVFF  7A,89
1564:  MOVFF  79,88
1568:  CLRF   x8F
156A:  CLRF   x8E
156C:  MOVLW  20
156E:  MOVWF  x8D
1570:  MOVLW  82
1572:  MOVWF  x8C
1574:  RCALL  10DA
1576:  MOVFF  03,7C
157A:  MOVFF  02,7B
157E:  MOVFF  01,7A
1582:  MOVFF  00,79
1586:  DECFSZ x80,F
1588:  BRA    1558
158A:  MOVFF  7C,89
158E:  MOVFF  7B,88
1592:  MOVFF  7A,87
1596:  MOVFF  79,86
159A:  RCALL  1482
159C:  MOVFF  03,7C
15A0:  MOVFF  02,7B
15A4:  MOVFF  01,7A
15A8:  MOVFF  00,79
15AC:  BTFSS  x7C.7
15AE:  BRA    15CA
15B0:  DECF   x7E,F
15B2:  BSF    x7E.5
15B4:  COMF   x79,F
15B6:  COMF   x7A,F
15B8:  COMF   x7B,F
15BA:  COMF   x7C,F
15BC:  INCF   x79,F
15BE:  BTFSC  FD8.2
15C0:  INCF   x7A,F
15C2:  BTFSC  FD8.2
15C4:  INCF   x7B,F
15C6:  BTFSC  FD8.2
15C8:  INCF   x7C,F
15CA:  MOVLW  3B
15CC:  MOVWF  x85
15CE:  MOVLW  9A
15D0:  MOVWF  x84
15D2:  MOVLW  CA
15D4:  MOVWF  x83
15D6:  CLRF   x82
15D8:  MOVLW  0A
15DA:  MOVWF  x80
15DC:  MOVF   x7D,W
15DE:  BTFSC  FD8.2
15E0:  INCF   x7E,F
15E2:  BSF    FD8.1
15E4:  CLRF   FEA
15E6:  MOVLW  79
15E8:  MOVWF  FE9
15EA:  MOVFF  7C,89
15EE:  MOVFF  7B,88
15F2:  MOVFF  7A,87
15F6:  MOVFF  79,86
15FA:  MOVFF  85,8D
15FE:  MOVFF  84,8C
1602:  MOVFF  83,8B
1606:  MOVFF  82,8A
160A:  RCALL  14C0
160C:  MOVF   01,W
160E:  MOVF   00,F
1610:  BNZ   1630
1612:  INCF   x7D,W
1614:  SUBWF  x80,W
1616:  BZ    1630
1618:  MOVF   x7E,W
161A:  BZ    1634
161C:  ANDLW  0F
161E:  SUBWF  x80,W
1620:  BZ    1624
1622:  BC    169A
1624:  BTFSC  x7E.7
1626:  BRA    169A
1628:  BTFSC  x7E.6
162A:  BRA    1634
162C:  MOVLW  20
162E:  BRA    1690
1630:  MOVLW  20
1632:  ANDWF  x7E,F
1634:  BTFSS  x7E.5
1636:  BRA    1652
1638:  BCF    x7E.5
163A:  MOVF   x7D,W
163C:  BTFSS  FD8.2
163E:  DECF   x7E,F
1640:  MOVF   00,W
1642:  MOVWF  x7E
1644:  MOVLW  2D
1646:  MOVWF  x86
1648:  CALL   072A
164C:  MOVF   x7E,W
164E:  MOVWF  00
1650:  CLRF   x7E
1652:  MOVF   x7D,W
1654:  SUBWF  x80,W
1656:  BNZ   166E
1658:  MOVF   00,W
165A:  MOVWF  x7E
165C:  MOVLW  2E
165E:  MOVWF  x86
1660:  CALL   072A
1664:  MOVF   x7E,W
1666:  MOVWF  00
1668:  MOVLW  20
166A:  ANDWF  x7E,F
166C:  MOVLW  00
166E:  MOVLW  30
1670:  BTFSS  x7E.5
1672:  BRA    1690
1674:  BCF    x7E.5
1676:  MOVF   x7D,W
1678:  BTFSS  FD8.2
167A:  DECF   x7E,F
167C:  MOVF   00,W
167E:  MOVWF  x7E
1680:  MOVLW  2D
1682:  MOVWF  x86
1684:  CALL   072A
1688:  MOVF   x7E,W
168A:  MOVWF  00
168C:  CLRF   x7E
168E:  MOVLW  30
1690:  ADDWF  00,F
1692:  MOVFF  00,86
1696:  CALL   072A
169A:  BCF    FD8.1
169C:  MOVFF  85,89
16A0:  MOVFF  84,88
16A4:  MOVFF  83,87
16A8:  MOVFF  82,86
16AC:  CLRF   x8D
16AE:  CLRF   x8C
16B0:  CLRF   x8B
16B2:  MOVLW  0A
16B4:  MOVWF  x8A
16B6:  RCALL  14C0
16B8:  MOVFF  03,85
16BC:  MOVFF  02,84
16C0:  MOVFF  01,83
16C4:  MOVFF  00,82
16C8:  DECFSZ x80,F
16CA:  BRA    15E2
16CC:  RETURN 0
*
18BE:  TBLRD*+
18C0:  MOVF   FF5,F
18C2:  BZ    18DE
18C4:  MOVFF  FF6,79
18C8:  MOVFF  FF7,7A
18CC:  MOVF   FF5,W
18CE:  BTFSS  F9E.4
18D0:  BRA    18CE
18D2:  MOVWF  FAD
18D4:  MOVFF  79,FF6
18D8:  MOVFF  7A,FF7
18DC:  BRA    18BE
18DE:  GOTO   19BA (RETURN)
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
*
1202:  CLRF   x80
1204:  CLRF   x7F
1206:  CLRF   x7E
1208:  MOVLW  7F
120A:  MOVWF  x7D
120C:  CLRF   x84
120E:  CLRF   x83
1210:  CLRF   x82
1212:  CLRF   x81
1214:  BSF    x85.0
1216:  BCF    x85.1
1218:  BCF    x85.2
121A:  CLRF   x87
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
121C:  MOVF   x79,W
121E:  IORWF  x7A,W
1220:  BNZ   122C
....................       return 0; 
1222:  CLRF   00
1224:  CLRF   01
1226:  CLRF   02
1228:  CLRF   03
122A:  BRA    1438
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
122C:  MOVF   x87,W
122E:  INCF   x87,F
1230:  CLRF   03
1232:  ADDWF  x79,W
1234:  MOVWF  FE9
1236:  MOVF   x7A,W
1238:  ADDWFC 03,W
123A:  MOVWF  FEA
123C:  MOVFF  FEF,86
1240:  MOVF   x86,F
1242:  BTFSC  FD8.2
1244:  BRA    13C2
....................    { 
....................       if (skip && !isspace(c)) 
1246:  BTFSS  x85.0
1248:  BRA    1268
124A:  MOVF   x86,W
124C:  SUBLW  20
124E:  BZ    1268
....................       { 
....................          skip = 0; 
1250:  BCF    x85.0
....................          if (c == '+') 
1252:  MOVF   x86,W
1254:  SUBLW  2B
1256:  BNZ   125E
....................          { 
....................             sign = 0; 
1258:  BCF    x85.1
....................             continue; 
125A:  BRA    13AC
....................          }             
125C:  BRA    1268
....................          else if (c == '-') 
125E:  MOVF   x86,W
1260:  SUBLW  2D
1262:  BNZ   1268
....................          { 
....................             sign = 1; 
1264:  BSF    x85.1
....................             continue; 
1266:  BRA    13AC
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
1268:  BTFSC  x85.0
126A:  BRA    127A
126C:  MOVF   x86,W
126E:  SUBLW  2E
1270:  BNZ   127A
1272:  BTFSC  x85.2
1274:  BRA    127A
....................          point = 1; 
1276:  BSF    x85.2
1278:  BRA    13AC
....................       else if (!skip && isdigit(c)) 
127A:  BTFSC  x85.0
127C:  BRA    13A6
127E:  MOVF   x86,W
1280:  SUBLW  2F
1282:  BTFSC  FD8.0
1284:  BRA    13A6
1286:  MOVF   x86,W
1288:  SUBLW  39
128A:  BTFSS  FD8.0
128C:  BRA    13A6
....................       { 
....................          c -= '0'; 
128E:  MOVLW  30
1290:  SUBWF  x86,F
....................          if (point) 
1292:  BTFSS  x85.2
1294:  BRA    1338
....................          { 
....................             pow10 = pow10 * 10.0; 
1296:  MOVFF  80,8B
129A:  MOVFF  7F,8A
129E:  MOVFF  7E,89
12A2:  MOVFF  7D,88
12A6:  CLRF   x8F
12A8:  CLRF   x8E
12AA:  MOVLW  20
12AC:  MOVWF  x8D
12AE:  MOVLW  82
12B0:  MOVWF  x8C
12B2:  RCALL  10DA
12B4:  MOVFF  03,80
12B8:  MOVFF  02,7F
12BC:  MOVFF  01,7E
12C0:  MOVFF  00,7D
....................             result += (float)c / pow10;    
12C4:  CLRF   x8D
12C6:  MOVFF  86,8C
12CA:  RCALL  11CC
12CC:  MOVFF  03,8B
12D0:  MOVFF  02,8A
12D4:  MOVFF  01,89
12D8:  MOVFF  00,88
12DC:  MOVFF  03,8F
12E0:  MOVFF  02,8E
12E4:  MOVFF  01,8D
12E8:  MOVFF  00,8C
12EC:  MOVFF  80,93
12F0:  MOVFF  7F,92
12F4:  MOVFF  7E,91
12F8:  MOVFF  7D,90
12FC:  CALL   0916
1300:  BCF    FD8.1
1302:  MOVFF  84,8F
1306:  MOVFF  83,8E
130A:  MOVFF  82,8D
130E:  MOVFF  81,8C
1312:  MOVFF  03,93
1316:  MOVFF  02,92
131A:  MOVFF  01,91
131E:  MOVFF  00,90
1322:  CALL   0AE6
1326:  MOVFF  03,84
132A:  MOVFF  02,83
132E:  MOVFF  01,82
1332:  MOVFF  00,81
....................          } 
1336:  BRA    13A4
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
1338:  CLRF   x8B
133A:  CLRF   x8A
133C:  MOVLW  20
133E:  MOVWF  x89
1340:  MOVLW  82
1342:  MOVWF  x88
1344:  MOVFF  84,8F
1348:  MOVFF  83,8E
134C:  MOVFF  82,8D
1350:  MOVFF  81,8C
1354:  RCALL  10DA
1356:  MOVFF  03,8B
135A:  MOVFF  02,8A
135E:  MOVFF  01,89
1362:  MOVFF  00,88
1366:  CLRF   x8D
1368:  MOVFF  86,8C
136C:  RCALL  11CC
136E:  BCF    FD8.1
1370:  MOVFF  8B,8F
1374:  MOVFF  8A,8E
1378:  MOVFF  89,8D
137C:  MOVFF  88,8C
1380:  MOVFF  03,93
1384:  MOVFF  02,92
1388:  MOVFF  01,91
138C:  MOVFF  00,90
1390:  CALL   0AE6
1394:  MOVFF  03,84
1398:  MOVFF  02,83
139C:  MOVFF  01,82
13A0:  MOVFF  00,81
....................          } 
....................       } 
13A4:  BRA    13AC
....................       else if (!skip) 
13A6:  BTFSC  x85.0
13A8:  BRA    13AC
....................          break; 
13AA:  BRA    13C2
13AC:  MOVF   x87,W
13AE:  INCF   x87,F
13B0:  CLRF   03
13B2:  ADDWF  x79,W
13B4:  MOVWF  FE9
13B6:  MOVF   x7A,W
13B8:  ADDWFC 03,W
13BA:  MOVWF  FEA
13BC:  MOVFF  FEF,86
13C0:  BRA    1240
....................    } 
....................  
....................    if (sign) 
13C2:  BTFSS  x85.1
13C4:  BRA    13F4
....................       result = -1*result; 
13C6:  CLRF   x8B
13C8:  CLRF   x8A
13CA:  MOVLW  80
13CC:  MOVWF  x89
13CE:  MOVLW  7F
13D0:  MOVWF  x88
13D2:  MOVFF  84,8F
13D6:  MOVFF  83,8E
13DA:  MOVFF  82,8D
13DE:  MOVFF  81,8C
13E2:  RCALL  10DA
13E4:  MOVFF  03,84
13E8:  MOVFF  02,83
13EC:  MOVFF  01,82
13F0:  MOVFF  00,81
....................        
....................    if(endptr) 
13F4:  MOVF   x7B,W
13F6:  IORWF  x7C,W
13F8:  BZ    1428
....................    { 
....................       if (ptr) { 
13FA:  MOVF   x87,F
13FC:  BZ    1416
....................          ptr--; 
13FE:  DECF   x87,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
1400:  MOVFF  7B,FE9
1404:  MOVFF  7C,FEA
1408:  MOVF   x87,W
140A:  ADDWF  x79,W
140C:  MOVWF  FEF
140E:  MOVLW  00
1410:  ADDWFC x7A,W
1412:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
1414:  BRA    1428
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
1416:  MOVFF  7B,FE9
141A:  MOVFF  7C,FEA
141E:  MOVFF  7A,FEC
1422:  MOVF   FED,F
1424:  MOVFF  79,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
1428:  MOVFF  81,00
142C:  MOVFF  82,01
1430:  MOVFF  83,02
1434:  MOVFF  84,03
1438:  RETURN 0
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,PLL5,CPUDIV1,VREGEN,MCLR,USBDIV,  // 48 MHz  para  el  USB y 48 MHz para  el resto del sistema 
.................... #use delay(clock=48000000) 
*
014A:  CLRF   FEA
014C:  MOVLW  9C
014E:  MOVWF  FE9
0150:  MOVF   FEF,W
0152:  BZ    0170
0154:  MOVLW  0F
0156:  MOVWF  01
0158:  CLRF   00
015A:  DECFSZ 00,F
015C:  BRA    015A
015E:  DECFSZ 01,F
0160:  BRA    0158
0162:  MOVLW  8F
0164:  MOVWF  00
0166:  DECFSZ 00,F
0168:  BRA    0166
016A:  NOP   
016C:  DECFSZ FEF,F
016E:  BRA    0154
0170:  RETURN 0
0172:  MOVLW  01
0174:  SUBWF  x9C,F
0176:  BNC   0190
0178:  CLRF   FEA
017A:  MOVLW  9C
017C:  MOVWF  FE9
017E:  MOVF   FEF,W
0180:  BZ    0190
0182:  MOVLW  02
0184:  MOVWF  00
0186:  DECFSZ 00,F
0188:  BRA    0186
018A:  BRA    018C
018C:  DECFSZ FEF,F
018E:  BRA    0182
0190:  RETURN 0
.................... #use rs232(baud=9600, xmit=pin_c6, rcv=pin_c7, bits=8, parity=N,stream=standard)  
*
0132:  BTFSS  F9E.4
0134:  BRA    0132
0136:  MOVWF  FAD
0138:  RETURN 0
.................... #use i2c(Master,sda=PIN_B4, scl=PIN_B5, force_sw,fast) 
*
0546:  MOVLW  08
0548:  MOVWF  01
054A:  MOVLW  02
054C:  MOVWF  00
054E:  DECFSZ 00,F
0550:  BRA    054E
0552:  BCF    F8A.5
0554:  BCF    F93.5
0556:  MOVLW  02
0558:  MOVWF  00
055A:  DECFSZ 00,F
055C:  BRA    055A
055E:  RLCF   x8C,F
0560:  BCF    F8A.4
0562:  BTFSC  FD8.0
0564:  BSF    F93.4
0566:  BTFSS  FD8.0
0568:  BCF    F93.4
056A:  BSF    F93.5
056C:  BTFSS  F81.5
056E:  BRA    056C
0570:  DECFSZ 01,F
0572:  BRA    054A
0574:  MOVLW  02
0576:  MOVWF  00
0578:  DECFSZ 00,F
057A:  BRA    0578
057C:  BCF    F8A.5
057E:  BCF    F93.5
0580:  NOP   
0582:  BSF    F93.4
0584:  MOVLW  02
0586:  MOVWF  00
0588:  DECFSZ 00,F
058A:  BRA    0588
058C:  MOVLW  02
058E:  MOVWF  00
0590:  DECFSZ 00,F
0592:  BRA    0590
0594:  BSF    F93.5
0596:  BTFSS  F81.5
0598:  BRA    0596
059A:  CLRF   01
059C:  MOVLW  02
059E:  MOVWF  00
05A0:  DECFSZ 00,F
05A2:  BRA    05A0
05A4:  BTFSC  F81.4
05A6:  BSF    01.0
05A8:  BCF    F8A.5
05AA:  BCF    F93.5
05AC:  BCF    F8A.4
05AE:  BCF    F93.4
05B0:  RETURN 0
.................... #include <i2c_Flex_LCD.c>    
....................  
.................... //-----------------------------------------------------------------------------  
.................... // Title:         i2c_Flex_LCD  
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol.  
.................... // Date:          Nov-2013  
.................... // Ver.Rev.:      1.0  
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S.  
.................... //-----------------------------------------------------------------------------  
.................... //  
.................... // lcd_init() Must be called before any other function.  
.................... //  
.................... // lcd_putc(c) Will display c on the next position of the LCD.  
.................... //   
.................... //     \f Clear LCD dispay  
.................... //     \1 Set write position on LCD Line 1  
.................... //     \2 Set write position on LCD Line 2  
.................... //     \3 Set write position on LCD Line 3  
.................... //     \4 Set write position on LCD Line 4  
.................... //  
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)  
.................... //  
.................... //-----------------------------------------------------------------------------  
.................... // LCD pins D0-D3 are not used.  
.................... //-----------------------------------------------------------------------------  
.................... //  
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with  
.................... //              an EXPANDER of I/O with connection I2C. The tests of these  
.................... //              routines have been programmed using the IC PCF8574T of Phillips.  
.................... //              I used 4 bits mode programming. The 8 bits mode programming  
.................... //              is possible if you use 2 x PCF8574T.  
.................... //  
.................... // As defined in the following structure the pin connection is as follows:  
.................... //  
.................... //  PCF8574P     LCD  
.................... //  ========     ======  
.................... //     P0        RS  
.................... //     P1        RW  
.................... //     P2        Enable   
.................... //     P3        Led Backlight  
.................... //     P4        D4  
.................... //     P5        D5  
.................... //     P6        D6  
.................... //     P7        D7  
.................... //  
.................... //  The SCL and SDA pins should be pull-up resistor as shown below:  
.................... //  
.................... //             +5v  
.................... //               |  
.................... //               <  
.................... //               > 4.7K         
.................... //               <           
.................... //To PIC         |          To i2c slave  
.................... //pin xx ------------------ SDA pin   
.................... //(SDA)                       
.................... //              +5v  
.................... //               |  
.................... //               <  
.................... //               > 4.7K         
.................... //               <           
.................... //To PIC         |          To i2c slave  
.................... //pin xx ------------------ SCL pin   
.................... //(SCL)  
.................... //  
.................... //To PIC                    To i2c slave  
.................... //Vss pin ----------------- Vss or ground pin   
.................... //                |  
.................... //              -----  
.................... //               ---  Ground  
.................... //                -   
.................... //   
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS"  
.................... //-----------------------------------------------------------------------------  
....................  
.................... #define LCD_ADDR       0x7E//0x4E //I2C slave address for LCD module  
....................  
.................... #define ON             1  
.................... #define OFF            0  
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS  
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW  
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN  
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED  
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1  
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2  
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3  
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4  
....................    
.................... byte address;  
.................... int1 lcd_backlight=ON;  
....................  
.................... void i2c_send_nibble(unsigned char data)  
....................    {     
....................         i2c_start();  
05B2:  BSF    F93.4
05B4:  MOVLW  02
05B6:  MOVWF  00
05B8:  DECFSZ 00,F
05BA:  BRA    05B8
05BC:  BSF    F93.5
05BE:  MOVLW  02
05C0:  MOVWF  00
05C2:  DECFSZ 00,F
05C4:  BRA    05C2
05C6:  BCF    F8A.4
05C8:  BCF    F93.4
05CA:  MOVLW  02
05CC:  MOVWF  00
05CE:  DECFSZ 00,F
05D0:  BRA    05CE
05D2:  BCF    F8A.5
05D4:  BCF    F93.5
....................         delay_us(1);  
05D6:  MOVLW  03
05D8:  MOVWF  00
05DA:  DECFSZ 00,F
05DC:  BRA    05DA
05DE:  BRA    05E0
....................         i2c_write(LCD_ADDR); //the slave addresse  
05E0:  MOVLW  7E
05E2:  MOVWF  x8C
05E4:  RCALL  0546
....................         delay_us(1);  
05E6:  MOVLW  03
05E8:  MOVWF  00
05EA:  DECFSZ 00,F
05EC:  BRA    05EA
05EE:  BRA    05F0
....................         i2c_write(data);  
05F0:  MOVFF  8B,8C
05F4:  RCALL  0546
....................         delay_us(1);  
05F6:  MOVLW  03
05F8:  MOVWF  00
05FA:  DECFSZ 00,F
05FC:  BRA    05FA
05FE:  BRA    0600
....................         i2c_stop();  
0600:  BCF    F93.4
0602:  NOP   
0604:  BSF    F93.5
0606:  BTFSS  F81.5
0608:  BRA    0606
060A:  MOVLW  02
060C:  MOVWF  00
060E:  DECFSZ 00,F
0610:  BRA    060E
0612:  BRA    0614
0614:  NOP   
0616:  BSF    F93.4
0618:  MOVLW  02
061A:  MOVWF  00
061C:  DECFSZ 00,F
061E:  BRA    061C
....................         delay_us(1);  
0620:  MOVLW  03
0622:  MOVWF  00
0624:  DECFSZ 00,F
0626:  BRA    0624
0628:  BRA    062A
062A:  RETURN 0
....................    }  
....................  
.................... void lcd_send_byte(unsigned char data)  
....................    {  
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN  
062C:  BTFSS  1E.0
062E:  BRA    063A
0630:  MOVF   x8A,W
0632:  IORLW  04
0634:  IORLW  08
0636:  MOVWF  x8A
0638:  BRA    063C
063A:  BSF    x8A.2
....................         i2c_send_nibble(data);  
063C:  MOVFF  8A,8B
0640:  RCALL  05B2
....................         data=data-4;       //toggle EN back to 0  
0642:  MOVLW  04
0644:  SUBWF  x8A,F
....................         i2c_send_nibble(data);  
0646:  MOVFF  8A,8B
064A:  RCALL  05B2
064C:  RETURN 0
....................    }  
....................      
.................... void lcd_clear()  
.................... {  
....................     lcd_send_byte(0x00);  
064E:  CLRF   x8A
0650:  RCALL  062C
....................     lcd_send_byte(0x10);  
0652:  MOVLW  10
0654:  MOVWF  x8A
0656:  RCALL  062C
0658:  CLRF   16
065A:  BTFSC  FF2.7
065C:  BSF    16.7
065E:  BCF    FF2.7
....................     delay_ms(2);  
0660:  MOVLW  02
0662:  MOVWF  x9C
0664:  RCALL  014A
0666:  BTFSC  16.7
0668:  BSF    FF2.7
066A:  RETURN 0
.................... }  
....................  
.................... void lcd_init()  
066C:  CLRF   16
066E:  BTFSC  FF2.7
0670:  BSF    16.7
0672:  BCF    FF2.7
.................... {  
....................     delay_ms(10); //LCD power up delay  
0674:  MOVLW  0A
0676:  MOVWF  x9C
0678:  RCALL  014A
067A:  BTFSC  16.7
067C:  BSF    FF2.7
....................          
....................    //Request works on the command by set the RS = 0 R/W = 0 write  
....................         lcd_send_byte(0x00);  
067E:  CLRF   x8A
0680:  RCALL  062C
....................         lcd_send_byte(0x10);  
0682:  MOVLW  10
0684:  MOVWF  x8A
0686:  RCALL  062C
....................         lcd_send_byte(0x00);  
0688:  CLRF   x8A
068A:  RCALL  062C
....................         lcd_send_byte(0x00);  
068C:  CLRF   x8A
068E:  RCALL  062C
....................         lcd_send_byte(0x10);  
0690:  MOVLW  10
0692:  MOVWF  x8A
0694:  RCALL  062C
....................            //First state in 8 bit mode  
....................         lcd_send_byte(0x30);  
0696:  MOVLW  30
0698:  MOVWF  x8A
069A:  RCALL  062C
....................         lcd_send_byte(0x30);  
069C:  MOVLW  30
069E:  MOVWF  x8A
06A0:  RCALL  062C
....................            //Then set to 4-bit mode  
....................         lcd_send_byte(0x30);  
06A2:  MOVLW  30
06A4:  MOVWF  x8A
06A6:  RCALL  062C
....................         lcd_send_byte(0x20);  
06A8:  MOVLW  20
06AA:  MOVWF  x8A
06AC:  RCALL  062C
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h)  
....................         lcd_send_byte(0x20);  
06AE:  MOVLW  20
06B0:  MOVWF  x8A
06B2:  RCALL  062C
....................         lcd_send_byte(0x80);  
06B4:  MOVLW  80
06B6:  MOVWF  x8A
06B8:  RCALL  062C
....................            //no need cursor on (0Ch)  
....................         lcd_send_byte(0x00);  
06BA:  CLRF   x8A
06BC:  RCALL  062C
....................         lcd_send_byte(0xC0);  
06BE:  MOVLW  C0
06C0:  MOVWF  x8A
06C2:  RCALL  062C
....................            //the cursor moves to the left (06 h)  
....................         lcd_send_byte(0x00);  
06C4:  CLRF   x8A
06C6:  RCALL  062C
....................         lcd_send_byte(0x60);  
06C8:  MOVLW  60
06CA:  MOVWF  x8A
06CC:  RCALL  062C
....................            //clears the display  
....................         lcd_clear();  
06CE:  RCALL  064E
06D0:  GOTO   1B20 (RETURN)
.................... }  
....................  
.................... void lcd_gotoxy( byte x, byte y)  
.................... {       
.................... static char data;  
....................        
....................    switch(y)  
06D4:  MOVF   x89,W
06D6:  XORLW  01
06D8:  BZ    06E8
06DA:  XORLW  03
06DC:  BZ    06EE
06DE:  XORLW  01
06E0:  BZ    06F4
06E2:  XORLW  07
06E4:  BZ    06FA
06E6:  BRA    0700
....................    {  
....................       case 1:  address= lcd_line_one;     break;  
06E8:  MOVLW  80
06EA:  MOVWF  1D
06EC:  BRA    0704
....................       case 2:  address= lcd_line_two;     break;  
06EE:  MOVLW  C0
06F0:  MOVWF  1D
06F2:  BRA    0704
....................       case 3:  address= lcd_line_three;   break;  
06F4:  MOVLW  94
06F6:  MOVWF  1D
06F8:  BRA    0704
....................       case 4:  address= lcd_line_four;    break;  
06FA:  MOVLW  D4
06FC:  MOVWF  1D
06FE:  BRA    0704
....................       default: address= lcd_line_one;     break;   
0700:  MOVLW  80
0702:  MOVWF  1D
....................    }  
....................    
....................    address+=x-1;  
0704:  MOVLW  01
0706:  SUBWF  x88,W
0708:  ADDWF  1D,F
....................    data=address&0xF0;  
070A:  MOVF   1D,W
070C:  ANDLW  F0
070E:  MOVWF  1F
....................    lcd_send_byte(data);  
0710:  MOVFF  1F,8A
0714:  RCALL  062C
....................    data=address&0x0F;  
0716:  MOVF   1D,W
0718:  ANDLW  0F
071A:  MOVWF  1F
....................    data=data<<4;  
071C:  SWAPF  1F,F
071E:  MOVLW  F0
0720:  ANDWF  1F,F
....................    lcd_send_byte(data);  
0722:  MOVFF  1F,8A
0726:  RCALL  062C
0728:  RETURN 0
.................... }  
....................  
.................... //Display the character on LCD screen.  
.................... void LCD_PUTC(char in_data)  
.................... {  
....................  char data;       
....................   switch(in_data)  
072A:  MOVF   x86,W
072C:  XORLW  0C
072E:  BZ    0742
0730:  XORLW  0D
0732:  BZ    0746
0734:  XORLW  03
0736:  BZ    0750
0738:  XORLW  01
073A:  BZ    075C
073C:  XORLW  07
073E:  BZ    0768
0740:  BRA    0774
....................    {   
....................      case '\f': lcd_clear()    ;  break;                 
0742:  RCALL  064E
0744:  BRA    0796
....................      case '\1': lcd_gotoxy(1,1);  break;  
0746:  MOVLW  01
0748:  MOVWF  x88
074A:  MOVWF  x89
074C:  RCALL  06D4
074E:  BRA    0796
....................      case '\2': lcd_gotoxy(1,2);  break;  
0750:  MOVLW  01
0752:  MOVWF  x88
0754:  MOVLW  02
0756:  MOVWF  x89
0758:  RCALL  06D4
075A:  BRA    0796
....................      case '\3': lcd_gotoxy(1,3);  break;  
075C:  MOVLW  01
075E:  MOVWF  x88
0760:  MOVLW  03
0762:  MOVWF  x89
0764:  RCALL  06D4
0766:  BRA    0796
....................      case '\4': lcd_gotoxy(1,4);  break;  
0768:  MOVLW  01
076A:  MOVWF  x88
076C:  MOVLW  04
076E:  MOVWF  x89
0770:  RCALL  06D4
0772:  BRA    0796
....................  
....................      default:  
....................         data=in_data&0xF0;  
0774:  MOVF   x86,W
0776:  ANDLW  F0
0778:  MOVWF  x87
....................         data=data|RS; //set RS pin to 1  
077A:  BSF    x87.0
....................         lcd_send_byte(data);  
077C:  MOVFF  87,8A
0780:  RCALL  062C
....................         data=in_data&0x0F;  
0782:  MOVF   x86,W
0784:  ANDLW  0F
0786:  MOVWF  x87
....................         data=data<<4;  
0788:  SWAPF  x87,F
078A:  MOVLW  F0
078C:  ANDWF  x87,F
....................         data=data|RS; //set RS pin to 1  
078E:  BSF    x87.0
....................         lcd_send_byte(data);  
0790:  MOVFF  87,8A
0794:  RCALL  062C
....................      break;  
....................    }  
0796:  RETURN 0
.................... }  
....................  
.................... //#include <LCD420-FLEX.c> 
....................  
.................... #define sentidox PIN_D0 
.................... #define sentidoy PIN_D1 
.................... #define sentidoz PIN_D2 
.................... #define motorx PIN_D3 
.................... #define motory PIN_D4 
.................... #define motorz PIN_D5 
.................... #define cerox PIN_D6 
.................... #define ceroy PIN_D7 
.................... #define ceroz PIN_C0 
.................... #define profunz PIN_C1 
.................... #define dremel PIN_E0 
.................... #define enter PIN_E1 
.................... #define habilx PIN_E2 
.................... #define habily PIN_A0 
.................... #define habilz PIN_A1 
.................... #define canalb PIN_A2 
.................... #define buzzer PIN_A3 
....................  
.................... char ch; 
.................... char mech[5]; 
.................... char datox[7]; 
.................... char datoy[7]; 
.................... int i, j, h, flagfin, salir; 
.................... int contador, contador1; 
.................... signed int32 x, y, xini, yini, pasosx, pasosy; 
.................... float broca, pasosxflot, pasosyflot; 
.................... int flagx, flagy, flagxy, flagcomienzo, flagmecha, flagboton; 
.................... short int flagpaquete, flagajuste, flagcambiomecha; 
.................... signed int32 pasosz, zini, z, alturamecha, guarda; 
....................  
.................... void moverz(void)  
.................... { 
....................     output_low(habilz); 
*
17A2:  BCF    F92.1
17A4:  BCF    F89.1
....................     pasosz = z - zini; 
17A6:  MOVF   x69,W
17A8:  SUBWF  x6D,W
17AA:  MOVWF  x65
17AC:  MOVF   x6A,W
17AE:  SUBWFB x6E,W
17B0:  MOVWF  x66
17B2:  MOVF   x6B,W
17B4:  SUBWFB x6F,W
17B6:  MOVWF  x67
17B8:  MOVF   x6C,W
17BA:  SUBWFB x70,W
17BC:  MOVWF  x68
....................      
....................     while (pasosz > 0)  
17BE:  BTFSC  x68.7
17C0:  BRA    183E
17C2:  MOVF   x68,F
17C4:  BNZ   17D4
17C6:  MOVF   x67,F
17C8:  BNZ   17D4
17CA:  MOVF   x66,F
17CC:  BNZ   17D4
17CE:  MOVF   x65,W
17D0:  SUBLW  00
17D2:  BC    183E
....................     { 
....................         output_high(sentidoz); //para abajo 
17D4:  BCF    F95.2
17D6:  BSF    F8C.2
....................         output_high(motorz); 
17D8:  BCF    F95.5
17DA:  BSF    F8C.5
....................         delay_us(1200); 
17DC:  CLRF   16
17DE:  BTFSC  FF2.7
17E0:  BSF    16.7
17E2:  BCF    FF2.7
17E4:  MOVLW  01
17E6:  MOVWF  x9C
17E8:  CALL   014A
17EC:  BTFSC  16.7
17EE:  BSF    FF2.7
17F0:  CLRF   16
17F2:  BTFSC  FF2.7
17F4:  BSF    16.7
17F6:  BCF    FF2.7
17F8:  MOVLW  C8
17FA:  MOVWF  x9C
17FC:  CALL   0172
1800:  BTFSC  16.7
1802:  BSF    FF2.7
....................         output_low(motorz); 
1804:  BCF    F95.5
1806:  BCF    F8C.5
....................         delay_us(1200); 
1808:  CLRF   16
180A:  BTFSC  FF2.7
180C:  BSF    16.7
180E:  BCF    FF2.7
1810:  MOVLW  01
1812:  MOVWF  x9C
1814:  CALL   014A
1818:  BTFSC  16.7
181A:  BSF    FF2.7
181C:  CLRF   16
181E:  BTFSC  FF2.7
1820:  BSF    16.7
1822:  BCF    FF2.7
1824:  MOVLW  C8
1826:  MOVWF  x9C
1828:  CALL   0172
182C:  BTFSC  16.7
182E:  BSF    FF2.7
....................         pasosz = pasosz - 1; 
1830:  MOVLW  01
1832:  SUBWF  x65,F
1834:  MOVLW  00
1836:  SUBWFB x66,F
1838:  SUBWFB x67,F
183A:  SUBWFB x68,F
183C:  BRA    17BE
....................     } 
....................     while (pasosz < 0)  
183E:  BTFSS  x68.7
1840:  BRA    18AC
....................     { 
....................         output_low(sentidoz); //para arriba 
1842:  BCF    F95.2
1844:  BCF    F8C.2
....................         output_high(motorz); 
1846:  BCF    F95.5
1848:  BSF    F8C.5
....................         delay_us(1200); 
184A:  CLRF   16
184C:  BTFSC  FF2.7
184E:  BSF    16.7
1850:  BCF    FF2.7
1852:  MOVLW  01
1854:  MOVWF  x9C
1856:  CALL   014A
185A:  BTFSC  16.7
185C:  BSF    FF2.7
185E:  CLRF   16
1860:  BTFSC  FF2.7
1862:  BSF    16.7
1864:  BCF    FF2.7
1866:  MOVLW  C8
1868:  MOVWF  x9C
186A:  CALL   0172
186E:  BTFSC  16.7
1870:  BSF    FF2.7
....................         output_low(motorz); 
1872:  BCF    F95.5
1874:  BCF    F8C.5
....................         delay_us(1200); 
1876:  CLRF   16
1878:  BTFSC  FF2.7
187A:  BSF    16.7
187C:  BCF    FF2.7
187E:  MOVLW  01
1880:  MOVWF  x9C
1882:  CALL   014A
1886:  BTFSC  16.7
1888:  BSF    FF2.7
188A:  CLRF   16
188C:  BTFSC  FF2.7
188E:  BSF    16.7
1890:  BCF    FF2.7
1892:  MOVLW  C8
1894:  MOVWF  x9C
1896:  CALL   0172
189A:  BTFSC  16.7
189C:  BSF    FF2.7
....................         pasosz = pasosz + 1; 
189E:  MOVLW  01
18A0:  ADDWF  x65,F
18A2:  MOVLW  00
18A4:  ADDWFC x66,F
18A6:  ADDWFC x67,F
18A8:  ADDWFC x68,F
18AA:  BRA    183E
....................     } 
....................     zini = z; 
18AC:  MOVFF  70,6C
18B0:  MOVFF  6F,6B
18B4:  MOVFF  6E,6A
18B8:  MOVFF  6D,69
18BC:  RETURN 0
.................... } 
....................  
.................... void bajarz(void)  
.................... { 
....................     while (pasosz > 0) //rutina que baja el cabezal 
....................     {  
....................         output_low(habilz); 
....................         pasosz = pasosz - 1; 
....................         output_high(sentidoz); 
....................         output_toggle(motorz); 
....................         delay_us(1200); 
....................     } 
.................... } 
....................  
.................... void subirz(void)  
.................... { 
....................     while (pasosz > 0) //rutina que sube el cabezal 
....................     {  
....................         output_low(sentidoz); 
....................         pasosz = pasosz - 1; 
....................         output_toggle(motorz); 
....................         delay_us(1200); 
....................     } 
.................... } 
....................  
.................... void conversionpasos(void)  
.................... { 
....................     pasosxflot = (x - xini) / 200.0; 
*
0DDC:  MOVF   43,W
0DDE:  SUBWF  3B,W
0DE0:  MOVWF  x79
0DE2:  MOVF   44,W
0DE4:  SUBWFB 3C,W
0DE6:  MOVWF  x7A
0DE8:  MOVF   45,W
0DEA:  SUBWFB 3D,W
0DEC:  MOVWF  x7B
0DEE:  MOVF   46,W
0DF0:  SUBWFB 3E,W
0DF2:  MOVWF  x7C
0DF4:  MOVWF  x80
0DF6:  MOVFF  7B,7F
0DFA:  MOVFF  7A,7E
0DFE:  MOVFF  79,7D
0E02:  RCALL  08C0
0E04:  MOVFF  03,8F
0E08:  MOVFF  02,8E
0E0C:  MOVFF  01,8D
0E10:  MOVFF  00,8C
0E14:  CLRF   x93
0E16:  CLRF   x92
0E18:  MOVLW  48
0E1A:  MOVWF  x91
0E1C:  MOVLW  86
0E1E:  MOVWF  x90
0E20:  RCALL  0916
0E22:  MOVFF  03,5A
0E26:  MOVFF  02,59
0E2A:  MOVFF  01,58
0E2E:  MOVFF  00,57
....................     pasosyflot = (y - yini) / 200.0; 
0E32:  MOVF   47,W
0E34:  SUBWF  3F,W
0E36:  MOVWF  x79
0E38:  MOVF   48,W
0E3A:  SUBWFB 40,W
0E3C:  MOVWF  x7A
0E3E:  MOVF   49,W
0E40:  SUBWFB 41,W
0E42:  MOVWF  x7B
0E44:  MOVF   4A,W
0E46:  SUBWFB 42,W
0E48:  MOVWF  x7C
0E4A:  MOVWF  x80
0E4C:  MOVFF  7B,7F
0E50:  MOVFF  7A,7E
0E54:  MOVFF  79,7D
0E58:  RCALL  08C0
0E5A:  MOVFF  03,8F
0E5E:  MOVFF  02,8E
0E62:  MOVFF  01,8D
0E66:  MOVFF  00,8C
0E6A:  CLRF   x93
0E6C:  CLRF   x92
0E6E:  MOVLW  48
0E70:  MOVWF  x91
0E72:  MOVLW  86
0E74:  MOVWF  x90
0E76:  RCALL  0916
0E78:  MOVFF  03,5E
0E7C:  MOVFF  02,5D
0E80:  MOVFF  01,5C
0E84:  MOVFF  00,5B
....................     if (pasosxflot >= 0) 
0E88:  CLRF   x7C
0E8A:  CLRF   x7B
0E8C:  CLRF   x7A
0E8E:  CLRF   x79
0E90:  MOVFF  5A,80
0E94:  MOVFF  59,7F
0E98:  MOVFF  58,7E
0E9C:  MOVFF  57,7D
0EA0:  RCALL  0A70
0EA2:  BC    0EA6
0EA4:  BNZ   0EFC
....................         pasosx = (signed long int) (pasosxflot + 0.5); 
0EA6:  BCF    FD8.1
0EA8:  MOVFF  5A,8F
0EAC:  MOVFF  59,8E
0EB0:  MOVFF  58,8D
0EB4:  MOVFF  57,8C
0EB8:  CLRF   x93
0EBA:  CLRF   x92
0EBC:  CLRF   x91
0EBE:  MOVLW  7E
0EC0:  MOVWF  x90
0EC2:  RCALL  0AE6
0EC4:  MOVFF  03,7C
0EC8:  MOVFF  02,7B
0ECC:  MOVFF  01,7A
0ED0:  MOVFF  00,79
0ED4:  RCALL  0D50
0ED6:  MOVFF  01,00
0EDA:  MOVFF  02,01
0EDE:  CLRF   02
0EE0:  CLRF   03
0EE2:  BTFSS  01.7
0EE4:  BRA    0EEA
0EE6:  DECF   02,F
0EE8:  DECF   03,F
0EEA:  MOVFF  03,4E
0EEE:  MOVFF  02,4D
0EF2:  MOVFF  01,4C
0EF6:  MOVFF  00,4B
0EFA:  BRA    0F50
....................     else 
....................         pasosx = (signed long int) (pasosxflot - 0.5); 
0EFC:  BSF    FD8.1
0EFE:  MOVFF  5A,8F
0F02:  MOVFF  59,8E
0F06:  MOVFF  58,8D
0F0A:  MOVFF  57,8C
0F0E:  CLRF   x93
0F10:  CLRF   x92
0F12:  CLRF   x91
0F14:  MOVLW  7E
0F16:  MOVWF  x90
0F18:  RCALL  0AE6
0F1A:  MOVFF  03,7C
0F1E:  MOVFF  02,7B
0F22:  MOVFF  01,7A
0F26:  MOVFF  00,79
0F2A:  RCALL  0D50
0F2C:  MOVFF  01,00
0F30:  MOVFF  02,01
0F34:  CLRF   02
0F36:  CLRF   03
0F38:  BTFSS  01.7
0F3A:  BRA    0F40
0F3C:  DECF   02,F
0F3E:  DECF   03,F
0F40:  MOVFF  03,4E
0F44:  MOVFF  02,4D
0F48:  MOVFF  01,4C
0F4C:  MOVFF  00,4B
....................  
....................     if (pasosyflot >= 0) 
0F50:  CLRF   x7C
0F52:  CLRF   x7B
0F54:  CLRF   x7A
0F56:  CLRF   x79
0F58:  MOVFF  5E,80
0F5C:  MOVFF  5D,7F
0F60:  MOVFF  5C,7E
0F64:  MOVFF  5B,7D
0F68:  RCALL  0A70
0F6A:  BC    0F6E
0F6C:  BNZ   0FC4
....................         pasosy = (signed long int) (pasosyflot + 0.5); 
0F6E:  BCF    FD8.1
0F70:  MOVFF  5E,8F
0F74:  MOVFF  5D,8E
0F78:  MOVFF  5C,8D
0F7C:  MOVFF  5B,8C
0F80:  CLRF   x93
0F82:  CLRF   x92
0F84:  CLRF   x91
0F86:  MOVLW  7E
0F88:  MOVWF  x90
0F8A:  RCALL  0AE6
0F8C:  MOVFF  03,7C
0F90:  MOVFF  02,7B
0F94:  MOVFF  01,7A
0F98:  MOVFF  00,79
0F9C:  RCALL  0D50
0F9E:  MOVFF  01,00
0FA2:  MOVFF  02,01
0FA6:  CLRF   02
0FA8:  CLRF   03
0FAA:  BTFSS  01.7
0FAC:  BRA    0FB2
0FAE:  DECF   02,F
0FB0:  DECF   03,F
0FB2:  MOVFF  03,52
0FB6:  MOVFF  02,51
0FBA:  MOVFF  01,50
0FBE:  MOVFF  00,4F
0FC2:  BRA    1018
....................     else 
....................         pasosy = (signed long int) (pasosyflot - 0.5); 
0FC4:  BSF    FD8.1
0FC6:  MOVFF  5E,8F
0FCA:  MOVFF  5D,8E
0FCE:  MOVFF  5C,8D
0FD2:  MOVFF  5B,8C
0FD6:  CLRF   x93
0FD8:  CLRF   x92
0FDA:  CLRF   x91
0FDC:  MOVLW  7E
0FDE:  MOVWF  x90
0FE0:  RCALL  0AE6
0FE2:  MOVFF  03,7C
0FE6:  MOVFF  02,7B
0FEA:  MOVFF  01,7A
0FEE:  MOVFF  00,79
0FF2:  RCALL  0D50
0FF4:  MOVFF  01,00
0FF8:  MOVFF  02,01
0FFC:  CLRF   02
0FFE:  CLRF   03
1000:  BTFSS  01.7
1002:  BRA    1008
1004:  DECF   02,F
1006:  DECF   03,F
1008:  MOVFF  03,52
100C:  MOVFF  02,51
1010:  MOVFF  01,50
1014:  MOVFF  00,4F
....................  
....................     pasosx = pasosx * 2; 
1018:  MOVFF  4E,7C
101C:  MOVFF  4D,7B
1020:  MOVFF  4C,7A
1024:  MOVFF  4B,79
1028:  CLRF   x80
102A:  CLRF   x7F
102C:  CLRF   x7E
102E:  MOVLW  02
1030:  MOVWF  x7D
1032:  RCALL  0D88
1034:  MOVFF  03,4E
1038:  MOVFF  02,4D
103C:  MOVFF  01,4C
1040:  MOVFF  00,4B
....................     pasosy = pasosy * 2; 
1044:  MOVFF  52,7C
1048:  MOVFF  51,7B
104C:  MOVFF  50,7A
1050:  MOVFF  4F,79
1054:  CLRF   x80
1056:  CLRF   x7F
1058:  CLRF   x7E
105A:  MOVLW  02
105C:  MOVWF  x7D
105E:  RCALL  0D88
1060:  MOVFF  03,52
1064:  MOVFF  02,51
1068:  MOVFF  01,50
106C:  MOVFF  00,4F
1070:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... void moverxy(void)  
.................... { 
....................     clear_interrupt(INT_TIMER0); 
1072:  BCF    FF2.2
....................     set_timer0(230); 
1074:  CLRF   FD7
1076:  MOVLW  E6
1078:  MOVWF  FD6
....................     enable_interrupts(INT_TIMER0); //Habilita interrupcin timer0 
107A:  BSF    FF2.5
....................     flagx = 1; 
107C:  MOVLW  01
107E:  MOVWF  5F
....................     flagy = 1; 
1080:  MOVWF  x60
....................     flagxy = 1; 
1082:  MOVWF  x61
....................     while (flagxy == 1); 
1084:  DECFSZ x61,W
1086:  BRA    108A
1088:  BRA    1084
108A:  GOTO   10D2 (RETURN)
.................... } 
....................  
.................... void posicionmecha(void)  
.................... { 
....................     x = +175000; 
108E:  CLRF   3E
1090:  MOVLW  02
1092:  MOVWF  3D
1094:  MOVLW  AB
1096:  MOVWF  3C
1098:  MOVLW  98
109A:  MOVWF  3B
....................     y = +205000; 
109C:  CLRF   42
109E:  MOVLW  03
10A0:  MOVWF  41
10A2:  MOVLW  20
10A4:  MOVWF  40
10A6:  MOVLW  C8
10A8:  MOVWF  3F
....................     conversionpasos(); 
10AA:  RCALL  0DDC
....................     xini = x; 
10AC:  MOVFF  3E,46
10B0:  MOVFF  3D,45
10B4:  MOVFF  3C,44
10B8:  MOVFF  3B,43
....................     yini = y; 
10BC:  MOVFF  42,4A
10C0:  MOVFF  41,49
10C4:  MOVFF  40,48
10C8:  MOVFF  3F,47
....................     // pasosx=+1500;     //pasos para ir a punto de prueba 
....................     //pasosy=+1000;     //pasos para ir a puto de prueba 
....................     contador = 2; 
10CC:  MOVLW  02
10CE:  MOVWF  39
....................     moverxy(); 
10D0:  BRA    1072
....................     putc('M'); 
10D2:  MOVLW  4D
10D4:  CALL   0132
10D8:  RETURN 0
.................... } 
....................  
.................... void profundidadmecha(void)  
.................... { 
....................     printf(LCD_PUTC, "\f\1%s", "Ajustando Z"); 
*
16E0:  MOVLW  0C
16E2:  MOVWF  x86
16E4:  CALL   072A
16E8:  MOVLW  01
16EA:  MOVWF  x86
16EC:  CALL   072A
16F0:  MOVLW  C6
16F2:  MOVWF  FF6
16F4:  MOVLW  00
16F6:  MOVWF  FF7
16F8:  CALL   0798
....................     printf(LCD_PUTC, "\2%s", "Profundidad de mecha"); 
16FC:  MOVLW  02
16FE:  MOVWF  x86
1700:  CALL   072A
1704:  MOVLW  D2
1706:  MOVWF  FF6
1708:  MOVLW  00
170A:  MOVWF  FF7
170C:  CALL   0798
....................     output_low(habilz); 
1710:  BCF    F92.1
1712:  BCF    F89.1
....................     output_low(habilx); 
1714:  BCF    F96.2
1716:  BCF    F8D.2
....................     output_low(habily); 
1718:  BCF    F92.0
171A:  BCF    F89.0
....................     output_low(motorz); 
171C:  BCF    F95.5
171E:  BCF    F8C.5
....................     while (input(profunz) == 1) { 
1720:  BSF    F94.1
1722:  BTFSS  F82.1
1724:  BRA    1790
....................         output_high(sentidoz); 
1726:  BCF    F95.2
1728:  BSF    F8C.2
....................         output_high(motorz); 
172A:  BCF    F95.5
172C:  BSF    F8C.5
....................         delay_us(1200); 
172E:  CLRF   16
1730:  BTFSC  FF2.7
1732:  BSF    16.7
1734:  BCF    FF2.7
1736:  MOVLW  01
1738:  MOVWF  x9C
173A:  CALL   014A
173E:  BTFSC  16.7
1740:  BSF    FF2.7
1742:  CLRF   16
1744:  BTFSC  FF2.7
1746:  BSF    16.7
1748:  BCF    FF2.7
174A:  MOVLW  C8
174C:  MOVWF  x9C
174E:  CALL   0172
1752:  BTFSC  16.7
1754:  BSF    FF2.7
....................         output_low(motorz); 
1756:  BCF    F95.5
1758:  BCF    F8C.5
....................         delay_us(1200); 
175A:  CLRF   16
175C:  BTFSC  FF2.7
175E:  BSF    16.7
1760:  BCF    FF2.7
1762:  MOVLW  01
1764:  MOVWF  x9C
1766:  CALL   014A
176A:  BTFSC  16.7
176C:  BSF    FF2.7
176E:  CLRF   16
1770:  BTFSC  FF2.7
1772:  BSF    16.7
1774:  BCF    FF2.7
1776:  MOVLW  C8
1778:  MOVWF  x9C
177A:  CALL   0172
177E:  BTFSC  16.7
1780:  BSF    FF2.7
....................         alturamecha = alturamecha + 1; 
1782:  MOVLW  01
1784:  ADDWF  x71,F
1786:  MOVLW  00
1788:  ADDWFC x72,F
178A:  ADDWFC x73,F
178C:  ADDWFC x74,F
178E:  BRA    1720
....................     } 
....................     // alturamecha=alturamecha-500; //le resta el espesor de la base + 1mm total 4,5 mm 
....................     zini = alturamecha; 
1790:  MOVFF  74,6C
1794:  MOVFF  73,6B
1798:  MOVFF  72,6A
179C:  MOVFF  71,69
17A0:  RETURN 0
.................... } 
....................  
.................... void ajusteceroz(void)  
.................... { 
....................     //printf(LCD_PUTC, "\f\1%s", "Ajustando eje Z"); 
....................     //printf(LCD_PUTC, "\2%s", "Espere por favor"); 
....................     output_low(habilz); 
*
07B8:  BCF    F92.1
07BA:  BCF    F89.1
....................     printf(LCD_PUTC, "\f\1%s", "Buscando cero Z"); 
07BC:  MOVLW  0C
07BE:  MOVWF  x86
07C0:  RCALL  072A
07C2:  MOVLW  01
07C4:  MOVWF  x86
07C6:  RCALL  072A
07C8:  MOVLW  E8
07CA:  MOVWF  FF6
07CC:  MOVLW  00
07CE:  MOVWF  FF7
07D0:  RCALL  0798
....................     while ((input(ceroz)) == 0) { 
07D2:  BSF    F94.0
07D4:  BTFSC  F82.0
07D6:  BRA    0806
....................         output_low(sentidoz); 
07D8:  BCF    F95.2
07DA:  BCF    F8C.2
....................         output_toggle(motorz); 
07DC:  BCF    F95.5
07DE:  BTG    F8C.5
....................         delay_us(1200); 
07E0:  CLRF   16
07E2:  BTFSC  FF2.7
07E4:  BSF    16.7
07E6:  BCF    FF2.7
07E8:  MOVLW  01
07EA:  MOVWF  x9C
07EC:  RCALL  014A
07EE:  BTFSC  16.7
07F0:  BSF    FF2.7
07F2:  CLRF   16
07F4:  BTFSC  FF2.7
07F6:  BSF    16.7
07F8:  BCF    FF2.7
07FA:  MOVLW  C8
07FC:  MOVWF  x9C
07FE:  RCALL  0172
0800:  BTFSC  16.7
0802:  BSF    FF2.7
0804:  BRA    07D2
....................     } 
....................     printf(LCD_PUTC, "\f\1%s", "Buscando cero Z OK"); 
0806:  MOVLW  0C
0808:  MOVWF  x86
080A:  RCALL  072A
080C:  MOVLW  01
080E:  MOVWF  x86
0810:  RCALL  072A
0812:  MOVLW  F8
0814:  MOVWF  FF6
0816:  MOVLW  00
0818:  MOVWF  FF7
081A:  RCALL  0798
....................     zini = 0; 
081C:  CLRF   x6C
081E:  CLRF   x6B
0820:  CLRF   x6A
0822:  CLRF   x69
0824:  RETURN 0
.................... } 
....................  
.................... void ajusteceroxy(void)  
.................... { 
....................     printf(LCD_PUTC, "\f\1%s", "Ajustando ejes X-Y"); 
0826:  MOVLW  0C
0828:  MOVWF  x86
082A:  RCALL  072A
082C:  MOVLW  01
082E:  MOVWF  x86
0830:  RCALL  072A
0832:  MOVLW  0C
0834:  MOVWF  FF6
0836:  MOVLW  01
0838:  MOVWF  FF7
083A:  RCALL  0798
....................     printf(LCD_PUTC, "\2%s", "Espere por favor"); 
083C:  MOVLW  02
083E:  MOVWF  x86
0840:  RCALL  072A
0842:  MOVLW  20
0844:  MOVWF  FF6
0846:  MOVLW  01
0848:  MOVWF  FF7
084A:  RCALL  0798
....................     //ajusteceroz(); 
....................     output_low(habilx); 
084C:  BCF    F96.2
084E:  BCF    F8D.2
....................     output_low(habily); 
0850:  BCF    F92.0
0852:  BCF    F89.0
....................     while ((input(cerox) == 0) || (input(ceroy)) == 0)  
0854:  BSF    F95.6
0856:  BTFSS  F83.6
0858:  BRA    0860
085A:  BSF    F95.7
085C:  BTFSC  F83.7
085E:  BRA    08A2
....................     { 
....................         if (input(cerox) == 0)  
0860:  BSF    F95.6
0862:  BTFSC  F83.6
0864:  BRA    086E
....................         { 
....................             output_high(sentidox); 
0866:  BCF    F95.0
0868:  BSF    F8C.0
....................             output_toggle(motorx); 
086A:  BCF    F95.3
086C:  BTG    F8C.3
....................         } 
....................         if (input(ceroy) == 0)  
086E:  BSF    F95.7
0870:  BTFSC  F83.7
0872:  BRA    087C
....................         { 
....................             output_low(sentidoy); 
0874:  BCF    F95.1
0876:  BCF    F8C.1
....................             output_toggle(motory); 
0878:  BCF    F95.4
087A:  BTG    F8C.4
....................         } 
....................         delay_us(1200); 
087C:  CLRF   16
087E:  BTFSC  FF2.7
0880:  BSF    16.7
0882:  BCF    FF2.7
0884:  MOVLW  01
0886:  MOVWF  x9C
0888:  RCALL  014A
088A:  BTFSC  16.7
088C:  BSF    FF2.7
088E:  CLRF   16
0890:  BTFSC  FF2.7
0892:  BSF    16.7
0894:  BCF    FF2.7
0896:  MOVLW  C8
0898:  MOVWF  x9C
089A:  RCALL  0172
089C:  BTFSC  16.7
089E:  BSF    FF2.7
08A0:  BRA    0854
....................     } 
....................     output_low(motorx); 
08A2:  BCF    F95.3
08A4:  BCF    F8C.3
....................     output_low(motory); 
08A6:  BCF    F95.4
08A8:  BCF    F8C.4
....................     output_low(motorz); 
08AA:  BCF    F95.5
08AC:  BCF    F8C.5
....................     xini = 0; 
08AE:  CLRF   46
08B0:  CLRF   45
08B2:  CLRF   44
08B4:  CLRF   43
....................     yini = 0; 
08B6:  CLRF   4A
08B8:  CLRF   49
08BA:  CLRF   48
08BC:  CLRF   47
08BE:  RETURN 0
.................... } 
....................  
.................... void mecha(void)  
.................... { 
....................     while (flagmecha == 0); 
*
143A:  MOVF   x63,F
143C:  BZ    143A
....................     while (flagmecha == 1); 
143E:  DECFSZ x63,W
1440:  BRA    1444
1442:  BRA    143E
....................     broca = atof(mech); 
1444:  CLRF   x7A
1446:  MOVLW  21
1448:  MOVWF  x79
144A:  CLRF   x7C
144C:  CLRF   x7B
144E:  RCALL  1202
1450:  MOVFF  03,56
1454:  MOVFF  02,55
1458:  MOVFF  01,54
145C:  MOVFF  00,53
1460:  RETURN 0
.................... } 
....................  
.................... void bip(void)  
.................... { 
....................     output_high(buzzer); 
*
16CE:  BCF    F92.3
16D0:  BSF    F89.3
....................     contador1 = 5; // 1/48*4*65586*8*23=218453useg aprox 
16D2:  MOVLW  05
16D4:  MOVWF  3A
....................     clear_interrupt(INT_TIMER1); //limpio la bandera 
16D6:  BCF    F9E.0
....................     set_timer1(0); 
16D8:  CLRF   FCF
16DA:  CLRF   FCE
....................     enable_interrupts(INT_TIMER1); 
16DC:  BSF    F9D.0
16DE:  RETURN 0
.................... } 
....................  
.................... #INT_EXT2         //Atencin a interrupcin por cambio en RB2 
....................  
.................... void ext_isr1() //Funcin de interrupcin 
.................... {  
....................     putc('F'); 
*
013A:  MOVLW  46
013C:  RCALL  0132
....................     flagajuste = 0; 
013E:  BCF    1E.2
....................     salir = 1; 
0140:  MOVLW  01
0142:  MOVWF  38
....................     // disable_interrupts(int_ext2_L2H); 
.................... } 
....................  
0144:  BCF    FF0.1
0146:  GOTO   0084
.................... #INT_EXT         //Atencin a interrupcin por cambio en RB0 
....................  
.................... void INTEXT_isr(void) //Funcin de interrupcin 
.................... {  
....................     output_low(motorz); 
*
0192:  BCF    F95.5
0194:  BCF    F8C.5
....................     if (input(canalb) == 0)  
0196:  BSF    F92.2
0198:  BTFSC  F80.2
019A:  BRA    01D0
....................     { 
....................         output_low(habilz); 
019C:  BCF    F92.1
019E:  BCF    F89.1
....................         output_low(sentidoz); //mecha para arriba 
01A0:  BCF    F95.2
01A2:  BCF    F8C.2
....................         z = z - 1; 
01A4:  MOVLW  01
01A6:  SUBWF  x6D,F
01A8:  MOVLW  00
01AA:  SUBWFB x6E,F
01AC:  SUBWFB x6F,F
01AE:  SUBWFB x70,F
....................         output_high(motorz); 
01B0:  BCF    F95.5
01B2:  BSF    F8C.5
....................         delay_us(1200); 
01B4:  MOVLW  01
01B6:  MOVWF  x9C
01B8:  RCALL  014A
01BA:  MOVLW  C8
01BC:  MOVWF  x9C
01BE:  RCALL  0172
....................         output_low(motorz); 
01C0:  BCF    F95.5
01C2:  BCF    F8C.5
....................         delay_us(1200); 
01C4:  MOVLW  01
01C6:  MOVWF  x9C
01C8:  RCALL  014A
01CA:  MOVLW  C8
01CC:  MOVWF  x9C
01CE:  RCALL  0172
....................     } 
....................     if (input(canalb) == 1)  
01D0:  BSF    F92.2
01D2:  BTFSS  F80.2
01D4:  BRA    020A
....................     { 
....................         output_low(habilz); 
01D6:  BCF    F92.1
01D8:  BCF    F89.1
....................         output_high(sentidoz); //mecha para abajo 
01DA:  BCF    F95.2
01DC:  BSF    F8C.2
....................         z = z + 1; 
01DE:  MOVLW  01
01E0:  ADDWF  x6D,F
01E2:  MOVLW  00
01E4:  ADDWFC x6E,F
01E6:  ADDWFC x6F,F
01E8:  ADDWFC x70,F
....................         output_high(motorz); 
01EA:  BCF    F95.5
01EC:  BSF    F8C.5
....................         delay_us(1200); 
01EE:  MOVLW  01
01F0:  MOVWF  x9C
01F2:  RCALL  014A
01F4:  MOVLW  C8
01F6:  MOVWF  x9C
01F8:  RCALL  0172
....................         output_low(motorz); 
01FA:  BCF    F95.5
01FC:  BCF    F8C.5
....................         delay_us(1200); 
01FE:  MOVLW  01
0200:  MOVWF  x9C
0202:  RCALL  014A
0204:  MOVLW  C8
0206:  MOVWF  x9C
0208:  RCALL  0172
....................     } 
.................... } 
020A:  BCF    FF2.1
020C:  GOTO   0084
.................... #int_TIMER0 
....................  
.................... void TIMER0_isr(void)  
.................... { 
....................     contador = contador - 1; 
0210:  MOVLW  01
0212:  SUBWF  39,F
....................  
....................     if (contador == 0)  
0214:  MOVF   39,F
0216:  BTFSS  FD8.2
0218:  BRA    02D2
....................     { 
....................         contador = 2; 
021A:  MOVLW  02
021C:  MOVWF  39
....................         if (pasosx == 0)  
021E:  MOVF   4B,F
0220:  BNZ   0230
0222:  MOVF   4C,F
0224:  BNZ   0230
0226:  MOVF   4D,F
0228:  BNZ   0230
022A:  MOVF   4E,F
022C:  BNZ   0230
....................         { 
....................             flagx = 0; 
022E:  CLRF   5F
....................         } 
....................         if (pasosx > 0)  
0230:  BTFSC  4E.7
0232:  BRA    025A
0234:  MOVF   4E,F
0236:  BNZ   0246
0238:  MOVF   4D,F
023A:  BNZ   0246
023C:  MOVF   4C,F
023E:  BNZ   0246
0240:  MOVF   4B,W
0242:  SUBLW  00
0244:  BC    025A
....................         { 
....................             output_low(sentidox); 
0246:  BCF    F95.0
0248:  BCF    F8C.0
....................             output_toggle(motorx); 
024A:  BCF    F95.3
024C:  BTG    F8C.3
....................             pasosx = pasosx - 1; 
024E:  MOVLW  01
0250:  SUBWF  4B,F
0252:  MOVLW  00
0254:  SUBWFB 4C,F
0256:  SUBWFB 4D,F
0258:  SUBWFB 4E,F
....................         } 
....................         if (pasosx < 0)  
025A:  BTFSS  4E.7
025C:  BRA    0272
....................         { 
....................             output_high(sentidox); 
025E:  BCF    F95.0
0260:  BSF    F8C.0
....................             output_toggle(motorx); 
0262:  BCF    F95.3
0264:  BTG    F8C.3
....................             pasosx = pasosx + 1; 
0266:  MOVLW  01
0268:  ADDWF  4B,F
026A:  MOVLW  00
026C:  ADDWFC 4C,F
026E:  ADDWFC 4D,F
0270:  ADDWFC 4E,F
....................         } 
....................  
....................         if (pasosy == 0)  
0272:  MOVF   4F,F
0274:  BNZ   0284
0276:  MOVF   50,F
0278:  BNZ   0284
027A:  MOVF   51,F
027C:  BNZ   0284
027E:  MOVF   52,F
0280:  BNZ   0284
....................         { 
....................             flagy = 0; 
0282:  CLRF   x60
....................         } 
....................         if (pasosy > 0)  
0284:  BTFSC  52.7
0286:  BRA    02AE
0288:  MOVF   52,F
028A:  BNZ   029A
028C:  MOVF   51,F
028E:  BNZ   029A
0290:  MOVF   50,F
0292:  BNZ   029A
0294:  MOVF   4F,W
0296:  SUBLW  00
0298:  BC    02AE
....................         { 
....................             output_high(sentidoy); 
029A:  BCF    F95.1
029C:  BSF    F8C.1
....................             output_toggle(motory); 
029E:  BCF    F95.4
02A0:  BTG    F8C.4
....................             pasosy = pasosy - 1; 
02A2:  MOVLW  01
02A4:  SUBWF  4F,F
02A6:  MOVLW  00
02A8:  SUBWFB 50,F
02AA:  SUBWFB 51,F
02AC:  SUBWFB 52,F
....................         } 
....................         if (pasosy < 0)  
02AE:  BTFSS  52.7
02B0:  BRA    02C6
....................         { 
....................             output_low(sentidoy); 
02B2:  BCF    F95.1
02B4:  BCF    F8C.1
....................             output_toggle(motory); 
02B6:  BCF    F95.4
02B8:  BTG    F8C.4
....................             pasosy = pasosy + 1; 
02BA:  MOVLW  01
02BC:  ADDWF  4F,F
02BE:  MOVLW  00
02C0:  ADDWFC 50,F
02C2:  ADDWFC 51,F
02C4:  ADDWFC 52,F
....................         } 
....................  
....................         if (flagx == 0 && flagy == 0)  
02C6:  MOVF   5F,F
02C8:  BNZ   02D2
02CA:  MOVF   x60,F
02CC:  BNZ   02D2
....................         { 
....................             flagxy = 0; 
02CE:  CLRF   x61
....................             disable_interrupts(INT_TIMER0); //deshabilita interrupcin timer0 
02D0:  BCF    FF2.5
....................         } 
....................  
....................     } 
....................     set_timer0(230); //Se recarga el timer0 
02D2:  CLRF   FD7
02D4:  MOVLW  E6
02D6:  MOVWF  FD6
.................... } 
....................  
02D8:  BCF    FF2.2
02DA:  GOTO   0084
.................... #int_TIMER1 
....................  
.................... void TIMER1_isr(void) // Timer para buzzer 
.................... { 
....................     contador1 = contador1 - 1; 
02DE:  MOVLW  01
02E0:  SUBWF  3A,F
....................  
....................     if (contador1 == 0)  
02E2:  MOVF   3A,F
02E4:  BNZ   02EC
....................     { 
....................         output_low(buzzer); 
02E6:  BCF    F92.3
02E8:  BCF    F89.3
....................         disable_interrupts(INT_TIMER1); 
02EA:  BCF    F9D.0
....................     } 
....................     set_timer1(0); 
02EC:  CLRF   FCF
02EE:  CLRF   FCE
.................... } 
02F0:  BCF    F9E.0
02F2:  GOTO   0084
.................... #int_rda 
....................  
.................... void serial_isr()  
.................... { 
....................     ch = getchar(); 
02F6:  BTFSS  F9E.5
02F8:  BRA    02F6
02FA:  MOVFF  FAE,20
....................      
....................     if (ch == 'A') //Inicio Ajuste 
02FE:  MOVF   20,W
0300:  SUBLW  41
0302:  BNZ   0306
....................     { 
....................         flagajuste = 1; 
0304:  BSF    1E.2
....................     }     
....................     if (ch == 'S')  
0306:  MOVF   20,W
0308:  SUBLW  53
030A:  BNZ   0310
....................     { 
....................         flagcomienzo = 1; 
030C:  MOVLW  01
030E:  MOVWF  x62
....................     } 
....................     if (ch == 'P') //Dato de perforacion entrante 
0310:  MOVF   20,W
0312:  SUBLW  50
0314:  BNZ   0318
....................     { 
....................         flagpaquete = 1; 
0316:  BSF    1E.1
....................     } 
....................     if (ch == 'F' && flagpaquete == 1) //Ciclo terminado 
0318:  MOVF   20,W
031A:  SUBLW  46
031C:  BNZ   0328
031E:  BTFSS  1E.1
0320:  BRA    0328
....................     { 
....................         flagpaquete = 0; 
0322:  BCF    1E.1
....................         flagfin = 1; 
0324:  MOVLW  01
0326:  MOVWF  37
....................     } 
....................     if (ch == 'C') 
0328:  MOVF   20,W
032A:  SUBLW  43
032C:  BNZ   0332
....................     { 
....................         flagpaquete = 0; 
032E:  BCF    1E.1
....................         flagcambiomecha = 1; 
0330:  BSF    1E.3
....................     } 
....................     if (ch == 'M') //Mecha entrante     
0332:  MOVF   20,W
0334:  SUBLW  4D
0336:  BNZ   033E
....................     {         
....................         flagmecha = 1; 
0338:  MOVLW  01
033A:  MOVWF  x63
....................         h = 0; 
033C:  CLRF   36
....................     } 
....................     if ((flagmecha) == 1 && (ch != 'M')) //Dato mecha 
033E:  DECFSZ x63,W
0340:  BRA    0366
0342:  MOVF   20,W
0344:  SUBLW  4D
0346:  BZ    0366
....................     { 
....................         mech[h] = ch; 
0348:  CLRF   03
034A:  MOVF   36,W
034C:  ADDLW  21
034E:  MOVWF  FE9
0350:  MOVLW  00
0352:  ADDWFC 03,W
0354:  MOVWF  FEA
0356:  MOVFF  20,FEF
....................         h = h + 1; 
035A:  MOVLW  01
035C:  ADDWF  36,F
....................         if (h == 5)  
035E:  MOVF   36,W
0360:  SUBLW  05
0362:  BNZ   0366
....................         { 
....................             flagmecha = 0; 
0364:  CLRF   x63
....................         } 
....................     } 
....................     if (ch == 'X') //Valor X entrante 
0366:  MOVF   20,W
0368:  SUBLW  58
036A:  BNZ   0372
....................     { 
....................         flagx = 1; 
036C:  MOVLW  01
036E:  MOVWF  5F
....................         i = 0; 
0370:  CLRF   34
....................     } 
....................     if (ch == 'Y') //Valor Y entrante 
0372:  MOVF   20,W
0374:  SUBLW  59
0376:  BNZ   037E
....................     { 
....................         flagy = 1; 
0378:  MOVLW  01
037A:  MOVWF  x60
....................         j = 0; 
037C:  CLRF   35
....................     } 
....................     if ((flagx) == 1 && (ch != 'X')) //Dato X 
037E:  DECFSZ 5F,W
0380:  BRA    03A6
0382:  MOVF   20,W
0384:  SUBLW  58
0386:  BZ    03A6
....................     { 
....................         datox[i] = ch; 
0388:  CLRF   03
038A:  MOVF   34,W
038C:  ADDLW  26
038E:  MOVWF  FE9
0390:  MOVLW  00
0392:  ADDWFC 03,W
0394:  MOVWF  FEA
0396:  MOVFF  20,FEF
....................         i = i + 1; 
039A:  MOVLW  01
039C:  ADDWF  34,F
....................         if (i == 7)  
039E:  MOVF   34,W
03A0:  SUBLW  07
03A2:  BNZ   03A6
....................         { 
....................             flagx = 0; 
03A4:  CLRF   5F
....................         } 
....................     } 
....................     if ((flagy) == 1 && (ch != 'Y')) //Dato Y 
03A6:  DECFSZ x60,W
03A8:  BRA    03D2
03AA:  MOVF   20,W
03AC:  SUBLW  59
03AE:  BZ    03D2
....................     { 
....................         datoy[j] = ch; 
03B0:  CLRF   03
03B2:  MOVF   35,W
03B4:  ADDLW  2D
03B6:  MOVWF  FE9
03B8:  MOVLW  00
03BA:  ADDWFC 03,W
03BC:  MOVWF  FEA
03BE:  MOVFF  20,FEF
....................         j = j + 1; 
03C2:  MOVLW  01
03C4:  ADDWF  35,F
....................         if (j == 7) { 
03C6:  MOVF   35,W
03C8:  SUBLW  07
03CA:  BNZ   03D2
....................             flagy = 0; 
03CC:  CLRF   x60
....................             flagxy = 1;             
03CE:  MOVLW  01
03D0:  MOVWF  x61
....................         } 
....................     } 
03D2:  BCF    F9E.5
03D4:  GOTO   0084
.................... } 
.................... void perforacion(void)  
.................... { 
....................     output_high(dremel); 
*
18E2:  BCF    F96.0
18E4:  BSF    F8D.0
....................     while (flagpaquete == 0) 
18E6:  BTFSC  1E.1
18E8:  BRA    19CE
....................     { 
....................         if(flagcambiomecha == 1) 
18EA:  BTFSS  1E.3
18EC:  BRA    19CC
....................         { 
....................             ajusteceroz(); 
18EE:  CALL   07B8
....................                 ajusteceroxy(); 
18F2:  CALL   0826
....................                 posicionmecha(); 
18F6:  CALL   108E
....................                 putc('M'); 
18FA:  MOVLW  4D
18FC:  CALL   0132
....................                 mecha(); 
1900:  RCALL  143A
....................                 lcd_putc("\f\1Por favor coloque"); 
1902:  MOVLW  D8
1904:  MOVWF  FF6
1906:  MOVLW  03
1908:  MOVWF  FF7
190A:  CALL   0798
....................                 printf(lcd_putc"\2mecha de %01.2fmm y", broca); 
190E:  MOVLW  EC
1910:  MOVWF  FF6
1912:  MOVLW  03
1914:  MOVWF  FF7
1916:  MOVLW  0A
1918:  MOVWF  x79
191A:  RCALL  1462
191C:  MOVLW  C9
191E:  MOVWF  FE9
1920:  MOVFF  56,7C
1924:  MOVFF  55,7B
1928:  MOVFF  54,7A
192C:  MOVFF  53,79
1930:  MOVLW  02
1932:  MOVWF  x7D
1934:  RCALL  154E
1936:  MOVLW  FC
1938:  MOVWF  FF6
193A:  MOVLW  03
193C:  MOVWF  FF7
193E:  MOVLW  04
1940:  MOVWF  x79
1942:  RCALL  1462
....................                 lcd_putc("\3presione enter"); 
1944:  MOVLW  02
1946:  MOVWF  FF6
1948:  MOVLW  04
194A:  MOVWF  FF7
194C:  CALL   0798
....................  
....................                 while (input(enter) == 0); 
1950:  BSF    F96.1
1952:  BTFSS  F84.1
1954:  BRA    1950
1956:  CLRF   16
1958:  BTFSC  FF2.7
195A:  BSF    16.7
195C:  BCF    FF2.7
....................                 delay_ms(10); 
195E:  MOVLW  0A
1960:  MOVWF  x9C
1962:  CALL   014A
1966:  BTFSC  16.7
1968:  BSF    FF2.7
....................                 bip(); 
196A:  RCALL  16CE
....................                 while (input(enter) == 1); 
196C:  BSF    F96.1
196E:  BTFSC  F84.1
1970:  BRA    196C
....................                 alturamecha = 0; 
1972:  CLRF   x74
1974:  CLRF   x73
1976:  CLRF   x72
1978:  CLRF   x71
....................                 profundidadmecha(); 
197A:  RCALL  16E0
....................                 zini = alturamecha; 
197C:  MOVFF  74,6C
1980:  MOVFF  73,6B
1984:  MOVFF  72,6A
1988:  MOVFF  71,69
....................                 z = alturamecha - 500; 
198C:  MOVLW  F4
198E:  SUBWF  x71,W
1990:  MOVWF  x6D
1992:  MOVLW  01
1994:  SUBWFB x72,W
1996:  MOVWF  x6E
1998:  MOVLW  00
199A:  SUBWFB x73,W
199C:  MOVWF  x6F
199E:  MOVLW  00
19A0:  SUBWFB x74,W
19A2:  MOVWF  x70
....................                 moverz(); 
19A4:  RCALL  17A2
....................                 ajusteceroxy(); 
19A6:  CALL   0826
....................                 flagcambiomecha = 0; 
19AA:  BCF    1E.3
....................                 flagcomienzo = 1; 
19AC:  MOVLW  01
19AE:  MOVWF  x62
....................                 puts("C");  // Confirmacion cambio de mechareturn; 
19B0:  MOVLW  12
19B2:  MOVWF  FF6
19B4:  MOVLW  04
19B6:  MOVWF  FF7
19B8:  BRA    18BE
19BA:  MOVLW  0D
19BC:  BTFSS  F9E.4
19BE:  BRA    19BC
19C0:  MOVWF  FAD
19C2:  MOVLW  0A
19C4:  BTFSS  F9E.4
19C6:  BRA    19C4
19C8:  MOVWF  FAD
....................                 return; 
19CA:  BRA    1ABE
....................         } 
19CC:  BRA    18E6
....................     } 
....................     while (flagpaquete == 1)  
19CE:  BTFSS  1E.1
19D0:  BRA    1ABA
....................     { 
....................         while (flagxy == 0) 
19D2:  MOVF   x61,F
19D4:  BNZ   19DE
....................         { 
....................             if(flagpaquete == 0) 
19D6:  BTFSC  1E.1
19D8:  BRA    19DC
....................             { 
....................                     return; 
19DA:  BRA    1ABE
....................             } 
19DC:  BRA    19D2
....................         }         
....................         while (flagxy == 1)  
19DE:  DECFSZ x61,W
19E0:  BRA    1AB8
....................         { 
....................             x = (signed long long int) atof(datox); 
19E2:  CLRF   x7A
19E4:  MOVLW  26
19E6:  MOVWF  x79
19E8:  CLRF   x7C
19EA:  CLRF   x7B
19EC:  RCALL  1202
19EE:  MOVFF  03,89
19F2:  MOVFF  02,88
19F6:  MOVFF  01,87
19FA:  MOVFF  00,86
19FE:  RCALL  1482
1A00:  MOVFF  03,3E
1A04:  MOVFF  02,3D
1A08:  MOVFF  01,3C
1A0C:  MOVFF  00,3B
....................             y = (signed long long int) atof(datoy); 
1A10:  CLRF   x7A
1A12:  MOVLW  2D
1A14:  MOVWF  x79
1A16:  CLRF   x7C
1A18:  CLRF   x7B
1A1A:  CALL   1202
1A1E:  MOVFF  03,89
1A22:  MOVFF  02,88
1A26:  MOVFF  01,87
1A2A:  MOVFF  00,86
1A2E:  RCALL  1482
1A30:  MOVFF  03,42
1A34:  MOVFF  02,41
1A38:  MOVFF  01,40
1A3C:  MOVFF  00,3F
....................             conversionpasos(); 
1A40:  CALL   0DDC
....................             xini = x; 
1A44:  MOVFF  3E,46
1A48:  MOVFF  3D,45
1A4C:  MOVFF  3C,44
1A50:  MOVFF  3B,43
....................             yini = y; 
1A54:  MOVFF  42,4A
1A58:  MOVFF  41,49
1A5C:  MOVFF  40,48
1A60:  MOVFF  3F,47
....................             clear_interrupt(INT_TIMER0); 
1A64:  BCF    FF2.2
....................             set_timer0(230); 
1A66:  CLRF   FD7
1A68:  MOVLW  E6
1A6A:  MOVWF  FD6
....................             enable_interrupts(INT_TIMER0); //Habilita interrupcin timer0 
1A6C:  BSF    FF2.5
....................             flagx = 1; 
1A6E:  MOVLW  01
1A70:  MOVWF  5F
....................             flagy = 1; 
1A72:  MOVWF  x60
....................             while (flagxy == 1); 
1A74:  DECFSZ x61,W
1A76:  BRA    1A7A
1A78:  BRA    1A74
....................             z = zini + 400; // Baja 4 mm 
1A7A:  MOVLW  90
1A7C:  ADDWF  x69,W
1A7E:  MOVWF  x6D
1A80:  MOVLW  01
1A82:  ADDWFC x6A,W
1A84:  MOVWF  x6E
1A86:  MOVLW  00
1A88:  ADDWFC x6B,W
1A8A:  MOVWF  x6F
1A8C:  MOVLW  00
1A8E:  ADDWFC x6C,W
1A90:  MOVWF  x70
....................             moverz(); 
1A92:  RCALL  17A2
....................             z = zini - 400; //sube 4mm 
1A94:  MOVLW  90
1A96:  SUBWF  x69,W
1A98:  MOVWF  x6D
1A9A:  MOVLW  01
1A9C:  SUBWFB x6A,W
1A9E:  MOVWF  x6E
1AA0:  MOVLW  00
1AA2:  SUBWFB x6B,W
1AA4:  MOVWF  x6F
1AA6:  MOVLW  00
1AA8:  SUBWFB x6C,W
1AAA:  MOVWF  x70
....................             moverz();             
1AAC:  RCALL  17A2
....................             flagpaquete = 0; 
1AAE:  BCF    1E.1
....................             putc('*'); 
1AB0:  MOVLW  2A
1AB2:  CALL   0132
1AB6:  BRA    19DE
....................         } 
1AB8:  BRA    19CE
....................     } 
....................     output_low(dremel); 
1ABA:  BCF    F96.0
1ABC:  BCF    F8D.0
1ABE:  GOTO   1E56 (RETURN)
.................... } 
.................... void main()  
1AC2:  CLRF   FF8
1AC4:  BCF    FD0.7
1AC6:  BSF    07.7
1AC8:  BSF    FB8.3
1ACA:  MOVLW  E1
1ACC:  MOVWF  FAF
1ACE:  MOVLW  04
1AD0:  MOVWF  FB0
1AD2:  MOVLW  A6
1AD4:  MOVWF  FAC
1AD6:  MOVLW  90
1AD8:  MOVWF  FAB
1ADA:  BSF    1E.0
1ADC:  MOVF   FC1,W
1ADE:  ANDLW  C0
1AE0:  IORLW  0F
1AE2:  MOVWF  FC1
1AE4:  MOVLW  07
1AE6:  MOVWF  FB4
1AE8:  CLRF   17
1AEA:  CLRF   18
1AEC:  CLRF   1F
.................... { 
....................     delay_ms(1000); 
1AEE:  MOVLW  04
1AF0:  MOVWF  x79
1AF2:  CLRF   16
1AF4:  BTFSC  FF2.7
1AF6:  BSF    16.7
1AF8:  BCF    FF2.7
1AFA:  MOVLW  FA
1AFC:  MOVWF  x9C
1AFE:  CALL   014A
1B02:  BTFSC  16.7
1B04:  BSF    FF2.7
1B06:  DECFSZ x79,F
1B08:  BRA    1AF2
....................     enable_interrupts(INT_RDA); 
1B0A:  BSF    F9D.5
....................     setup_timer_0(RTCC_8_BIT | RTCC_DIV_256); //Configuracin timer0 
1B0C:  MOVLW  C7
1B0E:  MOVWF  FD5
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); //Configuracin timer1 
1B10:  MOVLW  B5
1B12:  MOVWF  FCD
....................  
....................     enable_interrupts(INT_EXT2_L2H); //Habilita int. RB2? 
1B14:  BSF    FF0.4
1B16:  BSF    FF1.4
....................     //ext_int_edge(L_TO_H);              //por flanco de subida 
....................     enable_interrupts(GLOBAL); //Habilita interrupcin general 
1B18:  MOVLW  C0
1B1A:  IORWF  FF2,F
....................     lcd_init(); 
1B1C:  GOTO   066C
....................  
....................     while (1) { 
....................         flagfin = 0; 
1B20:  CLRF   37
....................         flagmecha = 0; 
1B22:  CLRF   x63
....................         flagcomienzo = 0; 
1B24:  CLRF   x62
....................         xini = 0; 
1B26:  CLRF   46
1B28:  CLRF   45
1B2A:  CLRF   44
1B2C:  CLRF   43
....................         yini = 0; 
1B2E:  CLRF   4A
1B30:  CLRF   49
1B32:  CLRF   48
1B34:  CLRF   47
....................         zini = 0; 
1B36:  CLRF   x6C
1B38:  CLRF   x6B
1B3A:  CLRF   x6A
1B3C:  CLRF   x69
....................         flagajuste = 0; 
1B3E:  BCF    1E.2
....................         flagpaquete = 0; 
1B40:  BCF    1E.1
....................         pasosx = 0; 
1B42:  CLRF   4E
1B44:  CLRF   4D
1B46:  CLRF   4C
1B48:  CLRF   4B
....................         pasosz = 0; 
1B4A:  CLRF   x68
1B4C:  CLRF   x67
1B4E:  CLRF   x66
1B50:  CLRF   x65
....................         pasosy = 0; 
1B52:  CLRF   52
1B54:  CLRF   51
1B56:  CLRF   50
1B58:  CLRF   4F
....................         alturamecha = 0; 
1B5A:  CLRF   x74
1B5C:  CLRF   x73
1B5E:  CLRF   x72
1B60:  CLRF   x71
....................         x = 0; 
1B62:  CLRF   3E
1B64:  CLRF   3D
1B66:  CLRF   3C
1B68:  CLRF   3B
....................         y = 0; 
1B6A:  CLRF   42
1B6C:  CLRF   41
1B6E:  CLRF   40
1B70:  CLRF   3F
....................         z = 0; 
1B72:  CLRF   x70
1B74:  CLRF   x6F
1B76:  CLRF   x6E
1B78:  CLRF   x6D
....................         flagboton = 0; 
1B7A:  CLRF   x64
....................         flagxy = 0; 
1B7C:  CLRF   x61
....................         flagx = 0; 
1B7E:  CLRF   5F
....................         flagy = 0; 
1B80:  CLRF   x60
....................         broca = 0; 
1B82:  CLRF   56
1B84:  CLRF   55
1B86:  CLRF   54
1B88:  CLRF   53
....................         pasosxflot = 0; 
1B8A:  CLRF   5A
1B8C:  CLRF   59
1B8E:  CLRF   58
1B90:  CLRF   57
....................         pasosyflot = 0; 
1B92:  CLRF   5E
1B94:  CLRF   5D
1B96:  CLRF   5C
1B98:  CLRF   5B
....................         salir = 0; 
1B9A:  CLRF   38
....................         i = 0; 
1B9C:  CLRF   34
....................         j = 0; 
1B9E:  CLRF   35
....................         h = 0; 
1BA0:  CLRF   36
....................         output_high(habilx); //motores sin energa 
1BA2:  BCF    F96.2
1BA4:  BSF    F8D.2
....................         output_high(habily); 
1BA6:  BCF    F92.0
1BA8:  BSF    F89.0
....................         output_high(habilz); 
1BAA:  BCF    F92.1
1BAC:  BSF    F89.1
....................         output_low(dremel); //apago el dremel 
1BAE:  BCF    F96.0
1BB0:  BCF    F8D.0
....................         output_low(buzzer); // apago buzzer 
1BB2:  BCF    F92.3
1BB4:  BCF    F89.3
....................         lcd_putc("\fHAGA CLICK EN"); 
1BB6:  MOVLW  14
1BB8:  MOVWF  FF6
1BBA:  MOVLW  04
1BBC:  MOVWF  FF7
1BBE:  CALL   0798
....................         lcd_putc("\2CALIBRAR EN LA"); 
1BC2:  MOVLW  24
1BC4:  MOVWF  FF6
1BC6:  MOVLW  04
1BC8:  MOVWF  FF7
1BCA:  CALL   0798
....................         lcd_putc("\3COMPUTADORA Y ESPERE"); 
1BCE:  MOVLW  34
1BD0:  MOVWF  FF6
1BD2:  MOVLW  04
1BD4:  MOVWF  FF7
1BD6:  CALL   0798
....................         lcd_putc("\4UN MOMENTO."); 
1BDA:  MOVLW  4A
1BDC:  MOVWF  FF6
1BDE:  MOVLW  04
1BE0:  MOVWF  FF7
1BE2:  CALL   0798
....................         while (flagcomienzo == 0); 
1BE6:  MOVF   x62,F
1BE8:  BZ    1BE6
....................         flagcomienzo = 0; 
1BEA:  CLRF   x62
....................         ajusteceroz(); 
1BEC:  CALL   07B8
....................         ajusteceroxy(); 
1BF0:  CALL   0826
....................         posicionmecha(); 
1BF4:  CALL   108E
....................         mecha(); 
1BF8:  RCALL  143A
....................         printf(lcd_putc"\f\1Coloque mecha %01.2fmm", broca); 
1BFA:  MOVLW  58
1BFC:  MOVWF  FF6
1BFE:  MOVLW  04
1C00:  MOVWF  FF7
1C02:  MOVLW  10
1C04:  MOVWF  x79
1C06:  RCALL  1462
1C08:  MOVLW  C9
1C0A:  MOVWF  FE9
1C0C:  MOVFF  56,7C
1C10:  MOVFF  55,7B
1C14:  MOVFF  54,7A
1C18:  MOVFF  53,79
1C1C:  MOVLW  02
1C1E:  MOVWF  x7D
1C20:  RCALL  154E
1C22:  MOVLW  6D
1C24:  MOVWF  x86
1C26:  CALL   072A
1C2A:  MOVLW  6D
1C2C:  MOVWF  x86
1C2E:  CALL   072A
....................         lcd_putc("\2Presione enter para"); 
1C32:  MOVLW  72
1C34:  MOVWF  FF6
1C36:  MOVLW  04
1C38:  MOVWF  FF7
1C3A:  CALL   0798
....................         lcd_putc("\3comenzar el ajuste"); 
1C3E:  MOVLW  88
1C40:  MOVWF  FF6
1C42:  MOVLW  04
1C44:  MOVWF  FF7
1C46:  CALL   0798
....................         lcd_putc("\4de la placa."); 
1C4A:  MOVLW  9C
1C4C:  MOVWF  FF6
1C4E:  MOVLW  04
1C50:  MOVWF  FF7
1C52:  CALL   0798
....................         while (input(enter) == 0); 
1C56:  BSF    F96.1
1C58:  BTFSS  F84.1
1C5A:  BRA    1C56
1C5C:  CLRF   16
1C5E:  BTFSC  FF2.7
1C60:  BSF    16.7
1C62:  BCF    FF2.7
....................         delay_ms(10); 
1C64:  MOVLW  0A
1C66:  MOVWF  x9C
1C68:  CALL   014A
1C6C:  BTFSC  16.7
1C6E:  BSF    FF2.7
....................         bip(); 
1C70:  RCALL  16CE
....................         while (input(enter) == 1); 
1C72:  BSF    F96.1
1C74:  BTFSC  F84.1
1C76:  BRA    1C72
....................         alturamecha = 0; 
1C78:  CLRF   x74
1C7A:  CLRF   x73
1C7C:  CLRF   x72
1C7E:  CLRF   x71
....................         profundidadmecha(); 
1C80:  RCALL  16E0
....................         zini = alturamecha; 
1C82:  MOVFF  74,6C
1C86:  MOVFF  73,6B
1C8A:  MOVFF  72,6A
1C8E:  MOVFF  71,69
....................         z = alturamecha - 500;  
1C92:  MOVLW  F4
1C94:  SUBWF  x71,W
1C96:  MOVWF  x6D
1C98:  MOVLW  01
1C9A:  SUBWFB x72,W
1C9C:  MOVWF  x6E
1C9E:  MOVLW  00
1CA0:  SUBWFB x73,W
1CA2:  MOVWF  x6F
1CA4:  MOVLW  00
1CA6:  SUBWFB x74,W
1CA8:  MOVWF  x70
....................         moverz(); 
1CAA:  RCALL  17A2
....................         ajusteceroxy(); 
1CAC:  CALL   0826
....................         putc('A'); 
1CB0:  MOVLW  41
1CB2:  CALL   0132
....................         while (flagajuste == 0 && salir == 0); 
1CB6:  BTFSC  1E.2
1CB8:  BRA    1CBE
1CBA:  MOVF   38,F
1CBC:  BZ    1CB6
....................         while (flagajuste == 1) 
1CBE:  BTFSS  1E.2
1CC0:  BRA    1E0E
....................         { 
....................             while (flagxy == 0); 
1CC2:  MOVF   x61,F
1CC4:  BZ    1CC2
....................             while (flagxy == 1) 
1CC6:  DECFSZ x61,W
1CC8:  BRA    1E0C
....................             { 
....................                 x = (signed long long int) atof(datox); 
1CCA:  CLRF   x7A
1CCC:  MOVLW  26
1CCE:  MOVWF  x79
1CD0:  CLRF   x7C
1CD2:  CLRF   x7B
1CD4:  CALL   1202
1CD8:  MOVFF  03,89
1CDC:  MOVFF  02,88
1CE0:  MOVFF  01,87
1CE4:  MOVFF  00,86
1CE8:  CALL   1482
1CEC:  MOVFF  03,3E
1CF0:  MOVFF  02,3D
1CF4:  MOVFF  01,3C
1CF8:  MOVFF  00,3B
....................                 y = (signed long long int) atof(datoy); 
1CFC:  CLRF   x7A
1CFE:  MOVLW  2D
1D00:  MOVWF  x79
1D02:  CLRF   x7C
1D04:  CLRF   x7B
1D06:  CALL   1202
1D0A:  MOVFF  03,89
1D0E:  MOVFF  02,88
1D12:  MOVFF  01,87
1D16:  MOVFF  00,86
1D1A:  CALL   1482
1D1E:  MOVFF  03,42
1D22:  MOVFF  02,41
1D26:  MOVFF  01,40
1D2A:  MOVFF  00,3F
....................                 conversionpasos(); 
1D2E:  CALL   0DDC
....................                 xini = x; 
1D32:  MOVFF  3E,46
1D36:  MOVFF  3D,45
1D3A:  MOVFF  3C,44
1D3E:  MOVFF  3B,43
....................                 yini = y; 
1D42:  MOVFF  42,4A
1D46:  MOVFF  41,49
1D4A:  MOVFF  40,48
1D4E:  MOVFF  3F,47
....................                 clear_interrupt(INT_TIMER0); 
1D52:  BCF    FF2.2
....................                 set_timer0(230); 
1D54:  CLRF   FD7
1D56:  MOVLW  E6
1D58:  MOVWF  FD6
....................                 enable_interrupts(INT_TIMER0); //Habilita interrupcin timer0 
1D5A:  BSF    FF2.5
....................                 flagx = 1; 
1D5C:  MOVLW  01
1D5E:  MOVWF  5F
....................                 flagy = 1; 
1D60:  MOVWF  x60
....................                 while (flagxy == 1); 
1D62:  DECFSZ x61,W
1D64:  BRA    1D68
1D66:  BRA    1D62
....................                 lcd_putc("\f\1Gire para subir o"); 
1D68:  MOVLW  AA
1D6A:  MOVWF  FF6
1D6C:  MOVLW  04
1D6E:  MOVWF  FF7
1D70:  CALL   0798
....................                 lcd_putc("\2bajar mecha.Presione"); 
1D74:  MOVLW  BE
1D76:  MOVWF  FF6
1D78:  MOVLW  04
1D7A:  MOVWF  FF7
1D7C:  CALL   0798
....................                 lcd_putc("\3enter nuevo punto."); 
1D80:  MOVLW  D4
1D82:  MOVWF  FF6
1D84:  MOVLW  04
1D86:  MOVWF  FF7
1D88:  CALL   0798
....................                 lcd_putc("\4Boton rojo salir."); 
1D8C:  MOVLW  E8
1D8E:  MOVWF  FF6
1D90:  MOVLW  04
1D92:  MOVWF  FF7
1D94:  CALL   0798
....................                 clear_interrupt(INT_EXT_L2H); 
1D98:  BCF    FF2.1
....................                 enable_interrupts(INT_EXT_L2H); 
1D9A:  BSF    FF2.4
1D9C:  BSF    FF1.6
....................                 while (input(enter) == 0 && salir == 0); 
1D9E:  BSF    F96.1
1DA0:  BTFSC  F84.1
1DA2:  BRA    1DA8
1DA4:  MOVF   38,F
1DA6:  BZ    1D9E
1DA8:  CLRF   16
1DAA:  BTFSC  FF2.7
1DAC:  BSF    16.7
1DAE:  BCF    FF2.7
....................                 delay_ms(10); 
1DB0:  MOVLW  0A
1DB2:  MOVWF  x9C
1DB4:  CALL   014A
1DB8:  BTFSC  16.7
1DBA:  BSF    FF2.7
....................                 bip(); 
1DBC:  RCALL  16CE
....................                 while (input(enter) == 1 && salir == 0); 
1DBE:  BSF    F96.1
1DC0:  BTFSS  F84.1
1DC2:  BRA    1DC8
1DC4:  MOVF   38,F
1DC6:  BZ    1DBE
....................                 if (input(enter) == 0 && salir == 0) 
1DC8:  BSF    F96.1
1DCA:  BTFSC  F84.1
1DCC:  BRA    1E0A
1DCE:  MOVF   38,F
1DD0:  BNZ   1E0A
....................                 { 
....................                     guarda = zini; 
1DD2:  MOVFF  6C,78
1DD6:  MOVFF  6B,77
1DDA:  MOVFF  6A,76
1DDE:  MOVFF  69,75
....................                     zini = z; 
1DE2:  MOVFF  70,6C
1DE6:  MOVFF  6F,6B
1DEA:  MOVFF  6E,6A
1DEE:  MOVFF  6D,69
....................                     z = guarda; 
1DF2:  MOVFF  78,70
1DF6:  MOVFF  77,6F
1DFA:  MOVFF  76,6E
1DFE:  MOVFF  75,6D
....................                     moverz(); 
1E02:  RCALL  17A2
....................                     putc('A'); 
1E04:  MOVLW  41
1E06:  CALL   0132
....................                 } 
1E0A:  BRA    1CC6
....................             } 
1E0C:  BRA    1CBE
....................         } 
....................          
....................         bip(); 
1E0E:  RCALL  16CE
....................         disable_interrupts(INT_EXT_L2H); 
1E10:  BCF    FF2.4
....................          
....................         /*while (flagfin == 0)  
....................         { 
....................             /* 
....................             if (salir == 0) 
....................             { 
....................                 ajusteceroz(); 
....................                 ajusteceroxy(); 
....................                 posicionmecha(); 
....................                 putc('M'); 
....................                 mecha(); 
....................                 lcd_putc("\f\1Por favor coloque"); 
....................                 printf(lcd_putc"\2mecha de %01.2fmm y", broca); 
....................                 lcd_putc("\3presione enter"); 
....................  
....................                 while (input(enter) == 0); 
....................                 delay_ms(10); 
....................                 bip(); 
....................                 while (input(enter) == 1); 
....................                 alturamecha = 0; 
....................                 profundidadmecha(); 
....................                 zini = alturamecha; 
....................                 z = alturamecha - 500; 
....................                 moverz(); 
....................                 ajusteceroxy(); 
....................                 flagcambiomecha = 0; 
....................                 flagcomienzo = 1 
....................                 puts("C");  // Confirmacion cambio de mecha 
....................             }*/ 
....................             ajusteceroxy(); 
1E12:  CALL   0826
....................             contador = 2; 
1E16:  MOVLW  02
1E18:  MOVWF  39
....................             lcd_putc("\f\1Perforadora Lista"); 
1E1A:  MOVLW  FC
1E1C:  MOVWF  FF6
1E1E:  MOVLW  04
1E20:  MOVWF  FF7
1E22:  CALL   0798
....................             lcd_putc("\2para operar haga click"); 
1E26:  MOVLW  10
1E28:  MOVWF  FF6
1E2A:  MOVLW  05
1E2C:  MOVWF  FF7
1E2E:  CALL   0798
....................             lcd_putc("\3en \"Comenzar\""); 
1E32:  MOVLW  28
1E34:  MOVWF  FF6
1E36:  MOVLW  05
1E38:  MOVWF  FF7
1E3A:  CALL   0798
....................             while (flagcomienzo == 0); 
1E3E:  MOVF   x62,F
1E40:  BZ    1E3E
....................         while (flagfin == 0) 
1E42:  MOVF   37,F
1E44:  BNZ   1E5A
....................         { 
....................             lcd_putc("\f\1PERFORANDO"); 
1E46:  MOVLW  38
1E48:  MOVWF  FF6
1E4A:  MOVLW  05
1E4C:  MOVWF  FF7
1E4E:  CALL   0798
....................             flagcomienzo = 0; 
1E52:  CLRF   x62
....................             perforacion(); 
1E54:  BRA    18E2
....................             salir = 0; 
1E56:  CLRF   38
1E58:  BRA    1E42
....................         } 
1E5A:  BRA    1B20
....................     } 
.................... } 
1E5C:  SLEEP 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
