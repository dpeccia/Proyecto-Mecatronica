CCS PCH C Compiler, Version 5.015, 59972               08-oct.-18 00:05

               Filename:   E:\Proyecto\GUI\Recepcion de datos12.X\build\default\production\Recepcion de datos12.lst

               ROM used:   7796 bytes (24%)
                           Largest free fragment is 24968
               RAM used:   122 (6%) at main() level
                           158 (8%) worst case
               Stack used: 9 locations (7 in main + 2 for interrupts)
               Stack size: 31

*
0000:  GOTO   19F6
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   0210
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   02DE
0060:  BTFSS  FF2.4
0062:  GOTO   006C
0066:  BTFSC  FF2.1
0068:  GOTO   0192
006C:  BTFSS  FF0.4
006E:  GOTO   0078
0072:  BTFSC  FF0.1
0074:  GOTO   013A
0078:  BTFSS  F9D.5
007A:  GOTO   0084
007E:  BTFSC  F9E.5
0080:  GOTO   02F6
0084:  MOVFF  0E,00
0088:  MOVFF  0F,01
008C:  MOVFF  10,02
0090:  MOVFF  11,03
0094:  MOVFF  0C,FE9
0098:  MOVFF  07,FEA
009C:  BSF    07.7
009E:  MOVFF  08,FE1
00A2:  MOVFF  09,FE2
00A6:  MOVFF  0A,FD9
00AA:  MOVFF  0B,FDA
00AE:  MOVFF  12,FF3
00B2:  MOVFF  13,FF4
00B6:  MOVFF  14,FFA
00BA:  MOVF   04,W
00BC:  MOVFF  06,FE0
00C0:  MOVFF  05,FD8
00C4:  RETFIE 0
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
00C6:  DATA 41,6A
00C8:  DATA 75,73
00CA:  DATA 74,61
00CC:  DATA 6E,64
00CE:  DATA 6F,20
00D0:  DATA 5A,00
00D2:  DATA 50,72
00D4:  DATA 6F,66
00D6:  DATA 75,6E
00D8:  DATA 64,69
00DA:  DATA 64,61
00DC:  DATA 64,20
00DE:  DATA 64,65
00E0:  DATA 20,6D
00E2:  DATA 65,63
00E4:  DATA 68,61
00E6:  DATA 00,00
00E8:  DATA 42,75
00EA:  DATA 73,63
00EC:  DATA 61,6E
00EE:  DATA 64,6F
00F0:  DATA 20,63
00F2:  DATA 65,72
00F4:  DATA 6F,20
00F6:  DATA 5A,00
00F8:  DATA 42,75
00FA:  DATA 73,63
00FC:  DATA 61,6E
00FE:  DATA 64,6F
0100:  DATA 20,63
0102:  DATA 65,72
0104:  DATA 6F,20
0106:  DATA 5A,20
0108:  DATA 4F,4B
010A:  DATA 00,00
010C:  DATA 41,6A
010E:  DATA 75,73
0110:  DATA 74,61
0112:  DATA 6E,64
0114:  DATA 6F,20
0116:  DATA 65,6A
0118:  DATA 65,73
011A:  DATA 20,58
011C:  DATA 2D,59
011E:  DATA 00,00
0120:  DATA 45,73
0122:  DATA 70,65
0124:  DATA 72,65
0126:  DATA 20,70
0128:  DATA 6F,72
012A:  DATA 20,66
012C:  DATA 61,76
012E:  DATA 6F,72
0130:  DATA 00,00
*
03FA:  DATA 0C,48
03FC:  DATA 41,47
03FE:  DATA 41,20
0400:  DATA 43,4C
0402:  DATA 49,43
0404:  DATA 4B,20
0406:  DATA 45,4E
0408:  DATA 00,00
040A:  DATA 02,43
040C:  DATA 41,4C
040E:  DATA 49,42
0410:  DATA 52,41
0412:  DATA 52,20
0414:  DATA 45,4E
0416:  DATA 20,4C
0418:  DATA 41,00
041A:  DATA 03,43
041C:  DATA 4F,4D
041E:  DATA 50,55
0420:  DATA 54,41
0422:  DATA 44,4F
0424:  DATA 52,41
0426:  DATA 20,59
0428:  DATA 20,45
042A:  DATA 53,50
042C:  DATA 45,52
042E:  DATA 45,00
0430:  DATA 04,55
0432:  DATA 4E,20
0434:  DATA 4D,4F
0436:  DATA 4D,45
0438:  DATA 4E,54
043A:  DATA 4F,2E
043C:  DATA 00,00
043E:  DATA 0C,01
0440:  DATA 43,6F
0442:  DATA 6C,6F
0444:  DATA 71,75
0446:  DATA 65,20
0448:  DATA 6D,65
044A:  DATA 63,68
044C:  DATA 61,20
044E:  DATA 25,30
0450:  DATA 31,2E
0452:  DATA 32,66
0454:  DATA 6D,6D
0456:  DATA 00,00
0458:  DATA 02,50
045A:  DATA 72,65
045C:  DATA 73,69
045E:  DATA 6F,6E
0460:  DATA 65,20
0462:  DATA 65,6E
0464:  DATA 74,65
0466:  DATA 72,20
0468:  DATA 70,61
046A:  DATA 72,61
046C:  DATA 00,00
046E:  DATA 03,63
0470:  DATA 6F,6D
0472:  DATA 65,6E
0474:  DATA 7A,61
0476:  DATA 72,20
0478:  DATA 65,6C
047A:  DATA 20,61
047C:  DATA 6A,75
047E:  DATA 73,74
0480:  DATA 65,00
0482:  DATA 04,64
0484:  DATA 65,20
0486:  DATA 6C,61
0488:  DATA 20,70
048A:  DATA 6C,61
048C:  DATA 63,61
048E:  DATA 2E,00
0490:  DATA 0C,01
0492:  DATA 47,69
0494:  DATA 72,65
0496:  DATA 20,70
0498:  DATA 61,72
049A:  DATA 61,20
049C:  DATA 73,75
049E:  DATA 62,69
04A0:  DATA 72,20
04A2:  DATA 6F,00
04A4:  DATA 02,62
04A6:  DATA 61,6A
04A8:  DATA 61,72
04AA:  DATA 20,6D
04AC:  DATA 65,63
04AE:  DATA 68,61
04B0:  DATA 2E,50
04B2:  DATA 72,65
04B4:  DATA 73,69
04B6:  DATA 6F,6E
04B8:  DATA 65,00
04BA:  DATA 03,65
04BC:  DATA 6E,74
04BE:  DATA 65,72
04C0:  DATA 20,6E
04C2:  DATA 75,65
04C4:  DATA 76,6F
04C6:  DATA 20,70
04C8:  DATA 75,6E
04CA:  DATA 74,6F
04CC:  DATA 2E,00
04CE:  DATA 04,42
04D0:  DATA 6F,74
04D2:  DATA 6F,6E
04D4:  DATA 20,72
04D6:  DATA 6F,6A
04D8:  DATA 6F,20
04DA:  DATA 73,61
04DC:  DATA 6C,69
04DE:  DATA 72,2E
04E0:  DATA 00,00
04E2:  DATA 0C,01
04E4:  DATA 50,6F
04E6:  DATA 72,20
04E8:  DATA 66,61
04EA:  DATA 76,6F
04EC:  DATA 72,20
04EE:  DATA 63,6F
04F0:  DATA 6C,6F
04F2:  DATA 71,75
04F4:  DATA 65,00
04F6:  DATA 02,6D
04F8:  DATA 65,63
04FA:  DATA 68,61
04FC:  DATA 20,64
04FE:  DATA 65,20
0500:  DATA 25,30
0502:  DATA 31,2E
0504:  DATA 32,66
0506:  DATA 6D,6D
0508:  DATA 20,79
050A:  DATA 00,00
050C:  DATA 03,70
050E:  DATA 72,65
0510:  DATA 73,69
0512:  DATA 6F,6E
0514:  DATA 65,20
0516:  DATA 65,6E
0518:  DATA 74,65
051A:  DATA 72,00
051C:  DATA 4F,4B
051E:  DATA 00,00
0520:  DATA 0C,01
0522:  DATA 50,65
0524:  DATA 72,66
0526:  DATA 6F,72
0528:  DATA 61,64
052A:  DATA 6F,72
052C:  DATA 61,20
052E:  DATA 4C,69
0530:  DATA 73,74
0532:  DATA 61,00
0534:  DATA 02,70
0536:  DATA 61,72
0538:  DATA 61,20
053A:  DATA 6F,70
053C:  DATA 65,72
053E:  DATA 61,72
0540:  DATA 20,68
0542:  DATA 61,67
0544:  DATA 61,20
0546:  DATA 63,6C
0548:  DATA 69,63
054A:  DATA 6B,00
054C:  DATA 03,65
054E:  DATA 6E,20
0550:  DATA 22,43
0552:  DATA 6F,6D
0554:  DATA 65,6E
0556:  DATA 7A,61
0558:  DATA 72,22
055A:  DATA 00,00
055C:  DATA 0C,01
055E:  DATA 50,45
0560:  DATA 52,46
0562:  DATA 4F,52
0564:  DATA 41,4E
0566:  DATA 44,4F
0568:  DATA 00,00
*
07BC:  TBLRD*+
07BE:  MOVF   FF5,F
07C0:  BZ    07DA
07C2:  MOVFF  FF6,79
07C6:  MOVFF  FF7,7A
07CA:  MOVFF  FF5,86
07CE:  RCALL  074E
07D0:  MOVFF  79,FF6
07D4:  MOVFF  7A,FF7
07D8:  BRA    07BC
07DA:  RETURN 0
*
08E4:  MOVLW  B6
08E6:  MOVWF  00
08E8:  CLRF   03
08EA:  CLRF   02
08EC:  CLRF   01
08EE:  BCF    x81.0
08F0:  BTFSS  x80.7
08F2:  BRA    090C
08F4:  BSF    x81.0
08F6:  COMF   x7D,F
08F8:  COMF   x7E,F
08FA:  COMF   x7F,F
08FC:  COMF   x80,F
08FE:  INCF   x7D,F
0900:  BNZ   090C
0902:  INCF   x7E,F
0904:  BNZ   090C
0906:  INCF   x7F,F
0908:  BTFSC  FD8.2
090A:  INCF   x80,F
090C:  MOVF   x7D,W
090E:  IORWF  x7E,W
0910:  IORWF  x7F,W
0912:  IORWF  x80,W
0914:  BNZ   091A
0916:  CLRF   00
0918:  BRA    0938
091A:  BCF    FD8.0
091C:  BTFSC  01.7
091E:  BRA    0932
0920:  RLCF   x7D,F
0922:  RLCF   x7E,F
0924:  RLCF   x7F,F
0926:  RLCF   x80,F
0928:  RLCF   03,F
092A:  RLCF   02,F
092C:  RLCF   01,F
092E:  DECFSZ 00,F
0930:  BRA    091A
0932:  BCF    01.7
0934:  BTFSC  x81.0
0936:  BSF    01.7
0938:  RETURN 0
093A:  MOVF   x8C,W
093C:  BTFSC  FD8.2
093E:  BRA    0A8A
0940:  MOVWF  x98
0942:  MOVF   x90,W
0944:  BTFSC  FD8.2
0946:  BRA    0A8A
0948:  SUBWF  x98,F
094A:  BNC   0956
094C:  MOVLW  7F
094E:  ADDWF  x98,F
0950:  BTFSC  FD8.0
0952:  BRA    0A8A
0954:  BRA    0962
0956:  MOVLW  81
0958:  SUBWF  x98,F
095A:  BTFSS  FD8.0
095C:  BRA    0A8A
095E:  BTFSC  FD8.2
0960:  BRA    0A8A
0962:  MOVFF  98,00
0966:  CLRF   01
0968:  CLRF   02
096A:  CLRF   03
096C:  CLRF   x97
096E:  MOVFF  8D,96
0972:  BSF    x96.7
0974:  MOVFF  8E,95
0978:  MOVFF  8F,94
097C:  MOVLW  19
097E:  MOVWF  x98
0980:  MOVF   x93,W
0982:  SUBWF  x94,F
0984:  BC    09A0
0986:  MOVLW  01
0988:  SUBWF  x95,F
098A:  BC    09A0
098C:  SUBWF  x96,F
098E:  BC    09A0
0990:  SUBWF  x97,F
0992:  BC    09A0
0994:  INCF   x97,F
0996:  INCF   x96,F
0998:  INCF   x95,F
099A:  MOVF   x93,W
099C:  ADDWF  x94,F
099E:  BRA    09F0
09A0:  MOVF   x92,W
09A2:  SUBWF  x95,F
09A4:  BC    09CA
09A6:  MOVLW  01
09A8:  SUBWF  x96,F
09AA:  BC    09CA
09AC:  SUBWF  x97,F
09AE:  BC    09CA
09B0:  INCF   x97,F
09B2:  INCF   x96,F
09B4:  MOVF   x92,W
09B6:  ADDWF  x95,F
09B8:  MOVF   x93,W
09BA:  ADDWF  x94,F
09BC:  BNC   09F0
09BE:  INCF   x95,F
09C0:  BNZ   09F0
09C2:  INCF   x96,F
09C4:  BNZ   09F0
09C6:  INCF   x97,F
09C8:  BRA    09F0
09CA:  MOVF   x91,W
09CC:  IORLW  80
09CE:  SUBWF  x96,F
09D0:  BC    09EE
09D2:  MOVLW  01
09D4:  SUBWF  x97,F
09D6:  BC    09EE
09D8:  INCF   x97,F
09DA:  MOVF   x91,W
09DC:  IORLW  80
09DE:  ADDWF  x96,F
09E0:  MOVF   x92,W
09E2:  ADDWF  x95,F
09E4:  BNC   09B8
09E6:  INCF   x96,F
09E8:  BNZ   09B8
09EA:  INCF   x97,F
09EC:  BRA    09B8
09EE:  BSF    03.0
09F0:  DECFSZ x98,F
09F2:  BRA    09F6
09F4:  BRA    0A0C
09F6:  BCF    FD8.0
09F8:  RLCF   x94,F
09FA:  RLCF   x95,F
09FC:  RLCF   x96,F
09FE:  RLCF   x97,F
0A00:  BCF    FD8.0
0A02:  RLCF   03,F
0A04:  RLCF   02,F
0A06:  RLCF   01,F
0A08:  RLCF   x99,F
0A0A:  BRA    0980
0A0C:  BTFSS  x99.0
0A0E:  BRA    0A1C
0A10:  BCF    FD8.0
0A12:  RRCF   01,F
0A14:  RRCF   02,F
0A16:  RRCF   03,F
0A18:  RRCF   x99,F
0A1A:  BRA    0A20
0A1C:  DECF   00,F
0A1E:  BZ    0A8A
0A20:  BTFSC  x99.7
0A22:  BRA    0A60
0A24:  BCF    FD8.0
0A26:  RLCF   x94,F
0A28:  RLCF   x95,F
0A2A:  RLCF   x96,F
0A2C:  RLCF   x97,F
0A2E:  MOVF   x93,W
0A30:  SUBWF  x94,F
0A32:  BC    0A42
0A34:  MOVLW  01
0A36:  SUBWF  x95,F
0A38:  BC    0A42
0A3A:  SUBWF  x96,F
0A3C:  BC    0A42
0A3E:  SUBWF  x97,F
0A40:  BNC   0A76
0A42:  MOVF   x92,W
0A44:  SUBWF  x95,F
0A46:  BC    0A52
0A48:  MOVLW  01
0A4A:  SUBWF  x96,F
0A4C:  BC    0A52
0A4E:  SUBWF  x97,F
0A50:  BNC   0A76
0A52:  MOVF   x91,W
0A54:  IORLW  80
0A56:  SUBWF  x96,F
0A58:  BC    0A60
0A5A:  MOVLW  01
0A5C:  SUBWF  x97,F
0A5E:  BNC   0A76
0A60:  INCF   03,F
0A62:  BNZ   0A76
0A64:  INCF   02,F
0A66:  BNZ   0A76
0A68:  INCF   01,F
0A6A:  BNZ   0A76
0A6C:  INCF   00,F
0A6E:  BZ    0A8A
0A70:  RRCF   01,F
0A72:  RRCF   02,F
0A74:  RRCF   03,F
0A76:  MOVFF  8D,98
0A7A:  MOVF   x91,W
0A7C:  XORWF  x98,F
0A7E:  BTFSS  x98.7
0A80:  BRA    0A86
0A82:  BSF    01.7
0A84:  BRA    0A92
0A86:  BCF    01.7
0A88:  BRA    0A92
0A8A:  CLRF   00
0A8C:  CLRF   01
0A8E:  CLRF   02
0A90:  CLRF   03
0A92:  RETURN 0
0A94:  MOVFF  7A,81
0A98:  MOVF   x7E,W
0A9A:  XORWF  x81,F
0A9C:  BTFSS  x81.7
0A9E:  BRA    0AAA
0AA0:  BCF    FD8.2
0AA2:  BCF    FD8.0
0AA4:  BTFSC  x7A.7
0AA6:  BSF    FD8.0
0AA8:  BRA    0B08
0AAA:  MOVFF  7A,81
0AAE:  MOVFF  7D,82
0AB2:  MOVF   x79,W
0AB4:  SUBWF  x82,F
0AB6:  BZ    0AC4
0AB8:  BTFSS  x81.7
0ABA:  BRA    0B08
0ABC:  MOVF   FD8,W
0ABE:  XORLW  01
0AC0:  MOVWF  FD8
0AC2:  BRA    0B08
0AC4:  MOVFF  7E,82
0AC8:  MOVF   x7A,W
0ACA:  SUBWF  x82,F
0ACC:  BZ    0ADA
0ACE:  BTFSS  x81.7
0AD0:  BRA    0B08
0AD2:  MOVF   FD8,W
0AD4:  XORLW  01
0AD6:  MOVWF  FD8
0AD8:  BRA    0B08
0ADA:  MOVFF  7F,82
0ADE:  MOVF   x7B,W
0AE0:  SUBWF  x82,F
0AE2:  BZ    0AF0
0AE4:  BTFSS  x81.7
0AE6:  BRA    0B08
0AE8:  MOVF   FD8,W
0AEA:  XORLW  01
0AEC:  MOVWF  FD8
0AEE:  BRA    0B08
0AF0:  MOVFF  80,82
0AF4:  MOVF   x7C,W
0AF6:  SUBWF  x82,F
0AF8:  BZ    0B06
0AFA:  BTFSS  x81.7
0AFC:  BRA    0B08
0AFE:  MOVF   FD8,W
0B00:  XORLW  01
0B02:  MOVWF  FD8
0B04:  BRA    0B08
0B06:  BCF    FD8.0
0B08:  RETURN 0
0B0A:  MOVLW  80
0B0C:  BTFSC  FD8.1
0B0E:  XORWF  x91,F
0B10:  CLRF   x96
0B12:  CLRF   x97
0B14:  MOVFF  8D,95
0B18:  MOVF   x91,W
0B1A:  XORWF  x95,F
0B1C:  MOVF   x8C,W
0B1E:  BTFSC  FD8.2
0B20:  BRA    0CDA
0B22:  MOVWF  x94
0B24:  MOVWF  00
0B26:  MOVF   x90,W
0B28:  BTFSC  FD8.2
0B2A:  BRA    0CEC
0B2C:  SUBWF  x94,F
0B2E:  BTFSC  FD8.2
0B30:  BRA    0C34
0B32:  BNC   0BAE
0B34:  MOVFF  91,9A
0B38:  BSF    x9A.7
0B3A:  MOVFF  92,99
0B3E:  MOVFF  93,98
0B42:  CLRF   x97
0B44:  BCF    FD8.0
0B46:  RRCF   x9A,F
0B48:  RRCF   x99,F
0B4A:  RRCF   x98,F
0B4C:  RRCF   x97,F
0B4E:  DECFSZ x94,F
0B50:  BRA    0B42
0B52:  BTFSS  x95.7
0B54:  BRA    0B5C
0B56:  BSF    x96.0
0B58:  BRA    0D14
0B5A:  BCF    x96.0
0B5C:  BCF    x94.0
0B5E:  BSF    x96.4
0B60:  CLRF   FEA
0B62:  MOVLW  8F
0B64:  MOVWF  FE9
0B66:  BRA    0D3A
0B68:  BCF    x96.4
0B6A:  BTFSC  x95.7
0B6C:  BRA    0B82
0B6E:  BTFSS  x94.0
0B70:  BRA    0B98
0B72:  RRCF   x9A,F
0B74:  RRCF   x99,F
0B76:  RRCF   x98,F
0B78:  RRCF   x97,F
0B7A:  INCF   00,F
0B7C:  BTFSC  FD8.2
0B7E:  BRA    0D0A
0B80:  BRA    0B98
0B82:  BTFSC  x9A.7
0B84:  BRA    0B9E
0B86:  BCF    FD8.0
0B88:  RLCF   x97,F
0B8A:  RLCF   x98,F
0B8C:  RLCF   x99,F
0B8E:  RLCF   x9A,F
0B90:  DECF   00,F
0B92:  BTFSC  FD8.2
0B94:  BRA    0D0A
0B96:  BRA    0B82
0B98:  BSF    x96.6
0B9A:  BRA    0C72
0B9C:  BCF    x96.6
0B9E:  MOVFF  8D,95
0BA2:  BTFSS  x8D.7
0BA4:  BRA    0BAA
0BA6:  BSF    x9A.7
0BA8:  BRA    0CFC
0BAA:  BCF    x9A.7
0BAC:  BRA    0CFC
0BAE:  MOVFF  90,94
0BB2:  MOVFF  90,00
0BB6:  MOVF   x8C,W
0BB8:  SUBWF  x94,F
0BBA:  MOVFF  8D,9A
0BBE:  BSF    x9A.7
0BC0:  MOVFF  8E,99
0BC4:  MOVFF  8F,98
0BC8:  CLRF   x97
0BCA:  BCF    FD8.0
0BCC:  RRCF   x9A,F
0BCE:  RRCF   x99,F
0BD0:  RRCF   x98,F
0BD2:  RRCF   x97,F
0BD4:  DECFSZ x94,F
0BD6:  BRA    0BC8
0BD8:  BTFSS  x95.7
0BDA:  BRA    0BE2
0BDC:  BSF    x96.1
0BDE:  BRA    0D14
0BE0:  BCF    x96.1
0BE2:  BCF    x94.0
0BE4:  BSF    x96.5
0BE6:  CLRF   FEA
0BE8:  MOVLW  93
0BEA:  MOVWF  FE9
0BEC:  BRA    0D3A
0BEE:  BCF    x96.5
0BF0:  BTFSC  x95.7
0BF2:  BRA    0C08
0BF4:  BTFSS  x94.0
0BF6:  BRA    0C1E
0BF8:  RRCF   x9A,F
0BFA:  RRCF   x99,F
0BFC:  RRCF   x98,F
0BFE:  RRCF   x97,F
0C00:  INCF   00,F
0C02:  BTFSC  FD8.2
0C04:  BRA    0D0A
0C06:  BRA    0C1E
0C08:  BTFSC  x9A.7
0C0A:  BRA    0C24
0C0C:  BCF    FD8.0
0C0E:  RLCF   x97,F
0C10:  RLCF   x98,F
0C12:  RLCF   x99,F
0C14:  RLCF   x9A,F
0C16:  DECF   00,F
0C18:  BTFSC  FD8.2
0C1A:  BRA    0D0A
0C1C:  BRA    0C08
0C1E:  BSF    x96.7
0C20:  BRA    0C72
0C22:  BCF    x96.7
0C24:  MOVFF  91,95
0C28:  BTFSS  x91.7
0C2A:  BRA    0C30
0C2C:  BSF    x9A.7
0C2E:  BRA    0CFC
0C30:  BCF    x9A.7
0C32:  BRA    0CFC
0C34:  MOVFF  91,9A
0C38:  BSF    x9A.7
0C3A:  MOVFF  92,99
0C3E:  MOVFF  93,98
0C42:  BTFSS  x95.7
0C44:  BRA    0C4E
0C46:  BCF    x9A.7
0C48:  BSF    x96.2
0C4A:  BRA    0D14
0C4C:  BCF    x96.2
0C4E:  CLRF   x97
0C50:  BCF    x94.0
0C52:  CLRF   FEA
0C54:  MOVLW  8F
0C56:  MOVWF  FE9
0C58:  BRA    0D3A
0C5A:  BTFSC  x95.7
0C5C:  BRA    0C96
0C5E:  MOVFF  8D,95
0C62:  BTFSS  x94.0
0C64:  BRA    0C72
0C66:  RRCF   x9A,F
0C68:  RRCF   x99,F
0C6A:  RRCF   x98,F
0C6C:  RRCF   x97,F
0C6E:  INCF   00,F
0C70:  BZ    0D0A
0C72:  BTFSS  x97.7
0C74:  BRA    0C8C
0C76:  INCF   x98,F
0C78:  BNZ   0C8C
0C7A:  INCF   x99,F
0C7C:  BNZ   0C8C
0C7E:  INCF   x9A,F
0C80:  BNZ   0C8C
0C82:  RRCF   x9A,F
0C84:  RRCF   x99,F
0C86:  RRCF   x98,F
0C88:  INCF   00,F
0C8A:  BZ    0D0A
0C8C:  BTFSC  x96.6
0C8E:  BRA    0B9C
0C90:  BTFSC  x96.7
0C92:  BRA    0C22
0C94:  BRA    0CCE
0C96:  MOVLW  80
0C98:  XORWF  x9A,F
0C9A:  BTFSS  x9A.7
0C9C:  BRA    0CA6
0C9E:  BRA    0D14
0CA0:  MOVFF  91,95
0CA4:  BRA    0CBA
0CA6:  MOVFF  8D,95
0CAA:  MOVF   x9A,F
0CAC:  BNZ   0CBA
0CAE:  MOVF   x99,F
0CB0:  BNZ   0CBA
0CB2:  MOVF   x98,F
0CB4:  BNZ   0CBA
0CB6:  CLRF   00
0CB8:  BRA    0CFC
0CBA:  BTFSC  x9A.7
0CBC:  BRA    0CCE
0CBE:  BCF    FD8.0
0CC0:  RLCF   x97,F
0CC2:  RLCF   x98,F
0CC4:  RLCF   x99,F
0CC6:  RLCF   x9A,F
0CC8:  DECFSZ 00,F
0CCA:  BRA    0CBA
0CCC:  BRA    0D0A
0CCE:  BTFSS  x95.7
0CD0:  BRA    0CD6
0CD2:  BSF    x9A.7
0CD4:  BRA    0CFC
0CD6:  BCF    x9A.7
0CD8:  BRA    0CFC
0CDA:  MOVFF  90,00
0CDE:  MOVFF  91,9A
0CE2:  MOVFF  92,99
0CE6:  MOVFF  93,98
0CEA:  BRA    0CFC
0CEC:  MOVFF  8C,00
0CF0:  MOVFF  8D,9A
0CF4:  MOVFF  8E,99
0CF8:  MOVFF  8F,98
0CFC:  MOVFF  9A,01
0D00:  MOVFF  99,02
0D04:  MOVFF  98,03
0D08:  BRA    0D72
0D0A:  CLRF   00
0D0C:  CLRF   01
0D0E:  CLRF   02
0D10:  CLRF   03
0D12:  BRA    0D72
0D14:  CLRF   x97
0D16:  COMF   x98,F
0D18:  COMF   x99,F
0D1A:  COMF   x9A,F
0D1C:  COMF   x97,F
0D1E:  INCF   x97,F
0D20:  BNZ   0D2C
0D22:  INCF   x98,F
0D24:  BNZ   0D2C
0D26:  INCF   x99,F
0D28:  BNZ   0D2C
0D2A:  INCF   x9A,F
0D2C:  BTFSC  x96.0
0D2E:  BRA    0B5A
0D30:  BTFSC  x96.1
0D32:  BRA    0BE0
0D34:  BTFSC  x96.2
0D36:  BRA    0C4C
0D38:  BRA    0CA0
0D3A:  MOVF   FEF,W
0D3C:  ADDWF  x98,F
0D3E:  BNC   0D4A
0D40:  INCF   x99,F
0D42:  BNZ   0D4A
0D44:  INCF   x9A,F
0D46:  BTFSC  FD8.2
0D48:  BSF    x94.0
0D4A:  MOVF   FED,F
0D4C:  MOVF   FEF,W
0D4E:  ADDWF  x99,F
0D50:  BNC   0D58
0D52:  INCF   x9A,F
0D54:  BTFSC  FD8.2
0D56:  BSF    x94.0
0D58:  MOVF   FED,F
0D5A:  MOVF   FEF,W
0D5C:  BTFSC  FEF.7
0D5E:  BRA    0D62
0D60:  XORLW  80
0D62:  ADDWF  x9A,F
0D64:  BTFSC  FD8.0
0D66:  BSF    x94.0
0D68:  BTFSC  x96.4
0D6A:  BRA    0B68
0D6C:  BTFSC  x96.5
0D6E:  BRA    0BEE
0D70:  BRA    0C5A
0D72:  RETURN 0
0D74:  MOVLW  8E
0D76:  MOVWF  00
0D78:  MOVF   x79,W
0D7A:  SUBWF  00,F
0D7C:  MOVFF  7A,02
0D80:  MOVFF  7B,01
0D84:  BSF    02.7
0D86:  MOVF   00,F
0D88:  BZ    0D9C
0D8A:  BCF    FD8.0
0D8C:  MOVF   02,F
0D8E:  BNZ   0D94
0D90:  MOVF   01,F
0D92:  BZ    0D9C
0D94:  RRCF   02,F
0D96:  RRCF   01,F
0D98:  DECFSZ 00,F
0D9A:  BRA    0D8A
0D9C:  BTFSS  x7A.7
0D9E:  BRA    0DAA
0DA0:  COMF   01,F
0DA2:  COMF   02,F
0DA4:  INCF   01,F
0DA6:  BTFSC  FD8.2
0DA8:  INCF   02,F
0DAA:  RETURN 0
0DAC:  CLRF   x81
0DAE:  CLRF   x82
0DB0:  MOVLW  01
0DB2:  MOVWF  x83
0DB4:  CLRF   FDA
0DB6:  CLRF   FD9
0DB8:  CLRF   x86
0DBA:  MOVLW  79
0DBC:  MOVWF  x85
0DBE:  CLRF   FEA
0DC0:  MOVLW  7D
0DC2:  MOVWF  FE9
0DC4:  MOVFF  86,FE2
0DC8:  MOVFF  85,FE1
0DCC:  MOVFF  83,84
0DD0:  BCF    FD8.0
0DD2:  MOVF   FE5,W
0DD4:  MULWF  FEE
0DD6:  MOVF   FF3,W
0DD8:  ADDWFC x81,F
0DDA:  MOVF   FF4,W
0DDC:  ADDWFC x82,F
0DDE:  DECFSZ x84,F
0DE0:  BRA    0DD0
0DE2:  MOVFF  81,FDE
0DE6:  MOVFF  82,81
0DEA:  CLRF   x82
0DEC:  BTFSC  FD8.0
0DEE:  INCF   x82,F
0DF0:  INCF   x85,F
0DF2:  BTFSC  FD8.2
0DF4:  INCF   x86,F
0DF6:  INCF   x83,F
0DF8:  MOVF   x83,W
0DFA:  SUBLW  05
0DFC:  BNZ   0DBE
0DFE:  RETURN 0
*
10FE:  MOVF   x88,W
1100:  BTFSC  FD8.2
1102:  BRA    11E6
1104:  MOVWF  00
1106:  MOVF   x8C,W
1108:  BTFSC  FD8.2
110A:  BRA    11E6
110C:  ADDWF  00,F
110E:  BNC   1118
1110:  MOVLW  81
1112:  ADDWF  00,F
1114:  BC    11E6
1116:  BRA    1120
1118:  MOVLW  7F
111A:  SUBWF  00,F
111C:  BNC   11E6
111E:  BZ    11E6
1120:  MOVFF  89,90
1124:  MOVF   x8D,W
1126:  XORWF  x90,F
1128:  BSF    x89.7
112A:  BSF    x8D.7
112C:  MOVF   x8B,W
112E:  MULWF  x8F
1130:  MOVFF  FF4,92
1134:  MOVF   x8A,W
1136:  MULWF  x8E
1138:  MOVFF  FF4,03
113C:  MOVFF  FF3,91
1140:  MULWF  x8F
1142:  MOVF   FF3,W
1144:  ADDWF  x92,F
1146:  MOVF   FF4,W
1148:  ADDWFC x91,F
114A:  MOVLW  00
114C:  ADDWFC 03,F
114E:  MOVF   x8B,W
1150:  MULWF  x8E
1152:  MOVF   FF3,W
1154:  ADDWF  x92,F
1156:  MOVF   FF4,W
1158:  ADDWFC x91,F
115A:  MOVLW  00
115C:  CLRF   02
115E:  ADDWFC 03,F
1160:  ADDWFC 02,F
1162:  MOVF   x89,W
1164:  MULWF  x8F
1166:  MOVF   FF3,W
1168:  ADDWF  x91,F
116A:  MOVF   FF4,W
116C:  ADDWFC 03,F
116E:  MOVLW  00
1170:  ADDWFC 02,F
1172:  MOVF   x89,W
1174:  MULWF  x8E
1176:  MOVF   FF3,W
1178:  ADDWF  03,F
117A:  MOVF   FF4,W
117C:  ADDWFC 02,F
117E:  MOVLW  00
1180:  CLRF   01
1182:  ADDWFC 01,F
1184:  MOVF   x8B,W
1186:  MULWF  x8D
1188:  MOVF   FF3,W
118A:  ADDWF  x91,F
118C:  MOVF   FF4,W
118E:  ADDWFC 03,F
1190:  MOVLW  00
1192:  ADDWFC 02,F
1194:  ADDWFC 01,F
1196:  MOVF   x8A,W
1198:  MULWF  x8D
119A:  MOVF   FF3,W
119C:  ADDWF  03,F
119E:  MOVF   FF4,W
11A0:  ADDWFC 02,F
11A2:  MOVLW  00
11A4:  ADDWFC 01,F
11A6:  MOVF   x89,W
11A8:  MULWF  x8D
11AA:  MOVF   FF3,W
11AC:  ADDWF  02,F
11AE:  MOVF   FF4,W
11B0:  ADDWFC 01,F
11B2:  INCF   00,F
11B4:  BTFSC  01.7
11B6:  BRA    11C2
11B8:  RLCF   x91,F
11BA:  RLCF   03,F
11BC:  RLCF   02,F
11BE:  RLCF   01,F
11C0:  DECF   00,F
11C2:  MOVLW  00
11C4:  BTFSS  x91.7
11C6:  BRA    11DC
11C8:  INCF   03,F
11CA:  ADDWFC 02,F
11CC:  ADDWFC 01,F
11CE:  MOVF   01,W
11D0:  BNZ   11DC
11D2:  MOVF   02,W
11D4:  BNZ   11DC
11D6:  MOVF   03,W
11D8:  BNZ   11DC
11DA:  INCF   00,F
11DC:  BTFSC  x90.7
11DE:  BSF    01.7
11E0:  BTFSS  x90.7
11E2:  BCF    01.7
11E4:  BRA    11EE
11E6:  CLRF   00
11E8:  CLRF   01
11EA:  CLRF   02
11EC:  CLRF   03
11EE:  RETURN 0
11F0:  MOVLW  8E
11F2:  MOVWF  00
11F4:  MOVFF  8D,01
11F8:  MOVFF  8C,02
11FC:  CLRF   03
11FE:  MOVF   01,F
1200:  BNZ   1214
1202:  MOVFF  02,01
1206:  CLRF   02
1208:  MOVLW  08
120A:  SUBWF  00,F
120C:  MOVF   01,F
120E:  BNZ   1214
1210:  CLRF   00
1212:  BRA    1224
1214:  BCF    FD8.0
1216:  BTFSC  01.7
1218:  BRA    1222
121A:  RLCF   02,F
121C:  RLCF   01,F
121E:  DECF   00,F
1220:  BRA    1214
1222:  BCF    01.7
1224:  RETURN 0
*
1486:  TBLRD*+
1488:  MOVFF  FF6,7A
148C:  MOVFF  FF7,7B
1490:  MOVFF  FF5,86
1494:  CALL   074E
1498:  MOVFF  7A,FF6
149C:  MOVFF  7B,FF7
14A0:  DECFSZ x79,F
14A2:  BRA    1486
14A4:  RETURN 0
14A6:  MOVF   x86,W
14A8:  SUBLW  B6
14AA:  MOVWF  x86
14AC:  CLRF   03
14AE:  MOVFF  87,8A
14B2:  BSF    x87.7
14B4:  BCF    FD8.0
14B6:  RRCF   x87,F
14B8:  RRCF   x88,F
14BA:  RRCF   x89,F
14BC:  RRCF   03,F
14BE:  RRCF   02,F
14C0:  RRCF   01,F
14C2:  RRCF   00,F
14C4:  DECFSZ x86,F
14C6:  BRA    14B4
14C8:  BTFSS  x8A.7
14CA:  BRA    14E2
14CC:  COMF   00,F
14CE:  COMF   01,F
14D0:  COMF   02,F
14D2:  COMF   03,F
14D4:  INCF   00,F
14D6:  BTFSC  FD8.2
14D8:  INCF   01,F
14DA:  BTFSC  FD8.2
14DC:  INCF   02,F
14DE:  BTFSC  FD8.2
14E0:  INCF   03,F
14E2:  RETURN 0
14E4:  BTFSC  FD8.1
14E6:  BRA    14EE
14E8:  CLRF   FEA
14EA:  MOVLW  8E
14EC:  MOVWF  FE9
14EE:  CLRF   00
14F0:  CLRF   01
14F2:  CLRF   02
14F4:  CLRF   03
14F6:  CLRF   x8E
14F8:  CLRF   x8F
14FA:  CLRF   x90
14FC:  CLRF   x91
14FE:  MOVF   x8D,W
1500:  IORWF  x8C,W
1502:  IORWF  x8B,W
1504:  IORWF  x8A,W
1506:  BZ    1560
1508:  MOVLW  20
150A:  MOVWF  x92
150C:  BCF    FD8.0
150E:  RLCF   x86,F
1510:  RLCF   x87,F
1512:  RLCF   x88,F
1514:  RLCF   x89,F
1516:  RLCF   x8E,F
1518:  RLCF   x8F,F
151A:  RLCF   x90,F
151C:  RLCF   x91,F
151E:  MOVF   x8D,W
1520:  SUBWF  x91,W
1522:  BNZ   1534
1524:  MOVF   x8C,W
1526:  SUBWF  x90,W
1528:  BNZ   1534
152A:  MOVF   x8B,W
152C:  SUBWF  x8F,W
152E:  BNZ   1534
1530:  MOVF   x8A,W
1532:  SUBWF  x8E,W
1534:  BNC   1554
1536:  MOVF   x8A,W
1538:  SUBWF  x8E,F
153A:  MOVF   x8B,W
153C:  BTFSS  FD8.0
153E:  INCFSZ x8B,W
1540:  SUBWF  x8F,F
1542:  MOVF   x8C,W
1544:  BTFSS  FD8.0
1546:  INCFSZ x8C,W
1548:  SUBWF  x90,F
154A:  MOVF   x8D,W
154C:  BTFSS  FD8.0
154E:  INCFSZ x8D,W
1550:  SUBWF  x91,F
1552:  BSF    FD8.0
1554:  RLCF   00,F
1556:  RLCF   01,F
1558:  RLCF   02,F
155A:  RLCF   03,F
155C:  DECFSZ x92,F
155E:  BRA    150C
1560:  MOVFF  8E,FEF
1564:  MOVFF  8F,FEC
1568:  MOVFF  90,FEC
156C:  MOVFF  91,FEC
1570:  RETURN 0
1572:  MOVF   FE9,W
1574:  MOVWF  x7E
1576:  MOVF   x7D,W
1578:  MOVWF  x80
157A:  BZ    15AE
157C:  MOVFF  7C,8B
1580:  MOVFF  7B,8A
1584:  MOVFF  7A,89
1588:  MOVFF  79,88
158C:  CLRF   x8F
158E:  CLRF   x8E
1590:  MOVLW  20
1592:  MOVWF  x8D
1594:  MOVLW  82
1596:  MOVWF  x8C
1598:  RCALL  10FE
159A:  MOVFF  03,7C
159E:  MOVFF  02,7B
15A2:  MOVFF  01,7A
15A6:  MOVFF  00,79
15AA:  DECFSZ x80,F
15AC:  BRA    157C
15AE:  MOVFF  7C,89
15B2:  MOVFF  7B,88
15B6:  MOVFF  7A,87
15BA:  MOVFF  79,86
15BE:  RCALL  14A6
15C0:  MOVFF  03,7C
15C4:  MOVFF  02,7B
15C8:  MOVFF  01,7A
15CC:  MOVFF  00,79
15D0:  BTFSS  x7C.7
15D2:  BRA    15EE
15D4:  DECF   x7E,F
15D6:  BSF    x7E.5
15D8:  COMF   x79,F
15DA:  COMF   x7A,F
15DC:  COMF   x7B,F
15DE:  COMF   x7C,F
15E0:  INCF   x79,F
15E2:  BTFSC  FD8.2
15E4:  INCF   x7A,F
15E6:  BTFSC  FD8.2
15E8:  INCF   x7B,F
15EA:  BTFSC  FD8.2
15EC:  INCF   x7C,F
15EE:  MOVLW  3B
15F0:  MOVWF  x85
15F2:  MOVLW  9A
15F4:  MOVWF  x84
15F6:  MOVLW  CA
15F8:  MOVWF  x83
15FA:  CLRF   x82
15FC:  MOVLW  0A
15FE:  MOVWF  x80
1600:  MOVF   x7D,W
1602:  BTFSC  FD8.2
1604:  INCF   x7E,F
1606:  BSF    FD8.1
1608:  CLRF   FEA
160A:  MOVLW  79
160C:  MOVWF  FE9
160E:  MOVFF  7C,89
1612:  MOVFF  7B,88
1616:  MOVFF  7A,87
161A:  MOVFF  79,86
161E:  MOVFF  85,8D
1622:  MOVFF  84,8C
1626:  MOVFF  83,8B
162A:  MOVFF  82,8A
162E:  RCALL  14E4
1630:  MOVF   01,W
1632:  MOVF   00,F
1634:  BNZ   1654
1636:  INCF   x7D,W
1638:  SUBWF  x80,W
163A:  BZ    1654
163C:  MOVF   x7E,W
163E:  BZ    1658
1640:  ANDLW  0F
1642:  SUBWF  x80,W
1644:  BZ    1648
1646:  BC    16BE
1648:  BTFSC  x7E.7
164A:  BRA    16BE
164C:  BTFSC  x7E.6
164E:  BRA    1658
1650:  MOVLW  20
1652:  BRA    16B4
1654:  MOVLW  20
1656:  ANDWF  x7E,F
1658:  BTFSS  x7E.5
165A:  BRA    1676
165C:  BCF    x7E.5
165E:  MOVF   x7D,W
1660:  BTFSS  FD8.2
1662:  DECF   x7E,F
1664:  MOVF   00,W
1666:  MOVWF  x7E
1668:  MOVLW  2D
166A:  MOVWF  x86
166C:  CALL   074E
1670:  MOVF   x7E,W
1672:  MOVWF  00
1674:  CLRF   x7E
1676:  MOVF   x7D,W
1678:  SUBWF  x80,W
167A:  BNZ   1692
167C:  MOVF   00,W
167E:  MOVWF  x7E
1680:  MOVLW  2E
1682:  MOVWF  x86
1684:  CALL   074E
1688:  MOVF   x7E,W
168A:  MOVWF  00
168C:  MOVLW  20
168E:  ANDWF  x7E,F
1690:  MOVLW  00
1692:  MOVLW  30
1694:  BTFSS  x7E.5
1696:  BRA    16B4
1698:  BCF    x7E.5
169A:  MOVF   x7D,W
169C:  BTFSS  FD8.2
169E:  DECF   x7E,F
16A0:  MOVF   00,W
16A2:  MOVWF  x7E
16A4:  MOVLW  2D
16A6:  MOVWF  x86
16A8:  CALL   074E
16AC:  MOVF   x7E,W
16AE:  MOVWF  00
16B0:  CLRF   x7E
16B2:  MOVLW  30
16B4:  ADDWF  00,F
16B6:  MOVFF  00,86
16BA:  CALL   074E
16BE:  BCF    FD8.1
16C0:  MOVFF  85,89
16C4:  MOVFF  84,88
16C8:  MOVFF  83,87
16CC:  MOVFF  82,86
16D0:  CLRF   x8D
16D2:  CLRF   x8C
16D4:  CLRF   x8B
16D6:  MOVLW  0A
16D8:  MOVWF  x8A
16DA:  RCALL  14E4
16DC:  MOVFF  03,85
16E0:  MOVFF  02,84
16E4:  MOVFF  01,83
16E8:  MOVFF  00,82
16EC:  DECFSZ x80,F
16EE:  BRA    1606
16F0:  RETURN 0
*
18E2:  TBLRD*+
18E4:  MOVF   FF5,F
18E6:  BZ    1902
18E8:  MOVFF  FF6,79
18EC:  MOVFF  FF7,7A
18F0:  MOVF   FF5,W
18F2:  BTFSS  F9E.4
18F4:  BRA    18F2
18F6:  MOVWF  FAD
18F8:  MOVFF  79,FF6
18FC:  MOVFF  7A,FF7
1900:  BRA    18E2
1902:  GOTO   1E20 (RETURN)
....................  
.................... #list 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
*
1226:  CLRF   x80
1228:  CLRF   x7F
122A:  CLRF   x7E
122C:  MOVLW  7F
122E:  MOVWF  x7D
1230:  CLRF   x84
1232:  CLRF   x83
1234:  CLRF   x82
1236:  CLRF   x81
1238:  BSF    x85.0
123A:  BCF    x85.1
123C:  BCF    x85.2
123E:  CLRF   x87
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
1240:  MOVF   x79,W
1242:  IORWF  x7A,W
1244:  BNZ   1250
....................       return 0; 
1246:  CLRF   00
1248:  CLRF   01
124A:  CLRF   02
124C:  CLRF   03
124E:  BRA    145C
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
1250:  MOVF   x87,W
1252:  INCF   x87,F
1254:  CLRF   03
1256:  ADDWF  x79,W
1258:  MOVWF  FE9
125A:  MOVF   x7A,W
125C:  ADDWFC 03,W
125E:  MOVWF  FEA
1260:  MOVFF  FEF,86
1264:  MOVF   x86,F
1266:  BTFSC  FD8.2
1268:  BRA    13E6
....................    { 
....................       if (skip && !isspace(c)) 
126A:  BTFSS  x85.0
126C:  BRA    128C
126E:  MOVF   x86,W
1270:  SUBLW  20
1272:  BZ    128C
....................       { 
....................          skip = 0; 
1274:  BCF    x85.0
....................          if (c == '+') 
1276:  MOVF   x86,W
1278:  SUBLW  2B
127A:  BNZ   1282
....................          { 
....................             sign = 0; 
127C:  BCF    x85.1
....................             continue; 
127E:  BRA    13D0
....................          }             
1280:  BRA    128C
....................          else if (c == '-') 
1282:  MOVF   x86,W
1284:  SUBLW  2D
1286:  BNZ   128C
....................          { 
....................             sign = 1; 
1288:  BSF    x85.1
....................             continue; 
128A:  BRA    13D0
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
128C:  BTFSC  x85.0
128E:  BRA    129E
1290:  MOVF   x86,W
1292:  SUBLW  2E
1294:  BNZ   129E
1296:  BTFSC  x85.2
1298:  BRA    129E
....................          point = 1; 
129A:  BSF    x85.2
129C:  BRA    13D0
....................       else if (!skip && isdigit(c)) 
129E:  BTFSC  x85.0
12A0:  BRA    13CA
12A2:  MOVF   x86,W
12A4:  SUBLW  2F
12A6:  BTFSC  FD8.0
12A8:  BRA    13CA
12AA:  MOVF   x86,W
12AC:  SUBLW  39
12AE:  BTFSS  FD8.0
12B0:  BRA    13CA
....................       { 
....................          c -= '0'; 
12B2:  MOVLW  30
12B4:  SUBWF  x86,F
....................          if (point) 
12B6:  BTFSS  x85.2
12B8:  BRA    135C
....................          { 
....................             pow10 = pow10 * 10.0; 
12BA:  MOVFF  80,8B
12BE:  MOVFF  7F,8A
12C2:  MOVFF  7E,89
12C6:  MOVFF  7D,88
12CA:  CLRF   x8F
12CC:  CLRF   x8E
12CE:  MOVLW  20
12D0:  MOVWF  x8D
12D2:  MOVLW  82
12D4:  MOVWF  x8C
12D6:  RCALL  10FE
12D8:  MOVFF  03,80
12DC:  MOVFF  02,7F
12E0:  MOVFF  01,7E
12E4:  MOVFF  00,7D
....................             result += (float)c / pow10;    
12E8:  CLRF   x8D
12EA:  MOVFF  86,8C
12EE:  RCALL  11F0
12F0:  MOVFF  03,8B
12F4:  MOVFF  02,8A
12F8:  MOVFF  01,89
12FC:  MOVFF  00,88
1300:  MOVFF  03,8F
1304:  MOVFF  02,8E
1308:  MOVFF  01,8D
130C:  MOVFF  00,8C
1310:  MOVFF  80,93
1314:  MOVFF  7F,92
1318:  MOVFF  7E,91
131C:  MOVFF  7D,90
1320:  CALL   093A
1324:  BCF    FD8.1
1326:  MOVFF  84,8F
132A:  MOVFF  83,8E
132E:  MOVFF  82,8D
1332:  MOVFF  81,8C
1336:  MOVFF  03,93
133A:  MOVFF  02,92
133E:  MOVFF  01,91
1342:  MOVFF  00,90
1346:  CALL   0B0A
134A:  MOVFF  03,84
134E:  MOVFF  02,83
1352:  MOVFF  01,82
1356:  MOVFF  00,81
....................          } 
135A:  BRA    13C8
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
135C:  CLRF   x8B
135E:  CLRF   x8A
1360:  MOVLW  20
1362:  MOVWF  x89
1364:  MOVLW  82
1366:  MOVWF  x88
1368:  MOVFF  84,8F
136C:  MOVFF  83,8E
1370:  MOVFF  82,8D
1374:  MOVFF  81,8C
1378:  RCALL  10FE
137A:  MOVFF  03,8B
137E:  MOVFF  02,8A
1382:  MOVFF  01,89
1386:  MOVFF  00,88
138A:  CLRF   x8D
138C:  MOVFF  86,8C
1390:  RCALL  11F0
1392:  BCF    FD8.1
1394:  MOVFF  8B,8F
1398:  MOVFF  8A,8E
139C:  MOVFF  89,8D
13A0:  MOVFF  88,8C
13A4:  MOVFF  03,93
13A8:  MOVFF  02,92
13AC:  MOVFF  01,91
13B0:  MOVFF  00,90
13B4:  CALL   0B0A
13B8:  MOVFF  03,84
13BC:  MOVFF  02,83
13C0:  MOVFF  01,82
13C4:  MOVFF  00,81
....................          } 
....................       } 
13C8:  BRA    13D0
....................       else if (!skip) 
13CA:  BTFSC  x85.0
13CC:  BRA    13D0
....................          break; 
13CE:  BRA    13E6
13D0:  MOVF   x87,W
13D2:  INCF   x87,F
13D4:  CLRF   03
13D6:  ADDWF  x79,W
13D8:  MOVWF  FE9
13DA:  MOVF   x7A,W
13DC:  ADDWFC 03,W
13DE:  MOVWF  FEA
13E0:  MOVFF  FEF,86
13E4:  BRA    1264
....................    } 
....................  
....................    if (sign) 
13E6:  BTFSS  x85.1
13E8:  BRA    1418
....................       result = -1*result; 
13EA:  CLRF   x8B
13EC:  CLRF   x8A
13EE:  MOVLW  80
13F0:  MOVWF  x89
13F2:  MOVLW  7F
13F4:  MOVWF  x88
13F6:  MOVFF  84,8F
13FA:  MOVFF  83,8E
13FE:  MOVFF  82,8D
1402:  MOVFF  81,8C
1406:  RCALL  10FE
1408:  MOVFF  03,84
140C:  MOVFF  02,83
1410:  MOVFF  01,82
1414:  MOVFF  00,81
....................        
....................    if(endptr) 
1418:  MOVF   x7B,W
141A:  IORWF  x7C,W
141C:  BZ    144C
....................    { 
....................       if (ptr) { 
141E:  MOVF   x87,F
1420:  BZ    143A
....................          ptr--; 
1422:  DECF   x87,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
1424:  MOVFF  7B,FE9
1428:  MOVFF  7C,FEA
142C:  MOVF   x87,W
142E:  ADDWF  x79,W
1430:  MOVWF  FEF
1432:  MOVLW  00
1434:  ADDWFC x7A,W
1436:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
1438:  BRA    144C
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
143A:  MOVFF  7B,FE9
143E:  MOVFF  7C,FEA
1442:  MOVFF  7A,FEC
1446:  MOVF   FED,F
1448:  MOVFF  79,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
144C:  MOVFF  81,00
1450:  MOVFF  82,01
1454:  MOVFF  83,02
1458:  MOVFF  84,03
145C:  RETURN 0
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,PLL5,CPUDIV1,VREGEN,MCLR,USBDIV,  // 48 MHz  para  el  USB y 48 MHz para  el resto del sistema 
.................... #use delay(clock=48000000) 
*
014A:  CLRF   FEA
014C:  MOVLW  9C
014E:  MOVWF  FE9
0150:  MOVF   FEF,W
0152:  BZ    0170
0154:  MOVLW  0F
0156:  MOVWF  01
0158:  CLRF   00
015A:  DECFSZ 00,F
015C:  BRA    015A
015E:  DECFSZ 01,F
0160:  BRA    0158
0162:  MOVLW  8F
0164:  MOVWF  00
0166:  DECFSZ 00,F
0168:  BRA    0166
016A:  NOP   
016C:  DECFSZ FEF,F
016E:  BRA    0154
0170:  RETURN 0
0172:  MOVLW  01
0174:  SUBWF  x9C,F
0176:  BNC   0190
0178:  CLRF   FEA
017A:  MOVLW  9C
017C:  MOVWF  FE9
017E:  MOVF   FEF,W
0180:  BZ    0190
0182:  MOVLW  02
0184:  MOVWF  00
0186:  DECFSZ 00,F
0188:  BRA    0186
018A:  BRA    018C
018C:  DECFSZ FEF,F
018E:  BRA    0182
0190:  RETURN 0
.................... #use rs232(baud=9600, xmit=pin_c6, rcv=pin_c7, bits=8, parity=N,stream=standard)  
*
0132:  BTFSS  F9E.4
0134:  BRA    0132
0136:  MOVWF  FAD
0138:  RETURN 0
.................... #use i2c(Master,sda=PIN_B4, scl=PIN_B5, force_sw,fast) 
*
056A:  MOVLW  08
056C:  MOVWF  01
056E:  MOVLW  02
0570:  MOVWF  00
0572:  DECFSZ 00,F
0574:  BRA    0572
0576:  BCF    F8A.5
0578:  BCF    F93.5
057A:  MOVLW  02
057C:  MOVWF  00
057E:  DECFSZ 00,F
0580:  BRA    057E
0582:  RLCF   x8C,F
0584:  BCF    F8A.4
0586:  BTFSC  FD8.0
0588:  BSF    F93.4
058A:  BTFSS  FD8.0
058C:  BCF    F93.4
058E:  BSF    F93.5
0590:  BTFSS  F81.5
0592:  BRA    0590
0594:  DECFSZ 01,F
0596:  BRA    056E
0598:  MOVLW  02
059A:  MOVWF  00
059C:  DECFSZ 00,F
059E:  BRA    059C
05A0:  BCF    F8A.5
05A2:  BCF    F93.5
05A4:  NOP   
05A6:  BSF    F93.4
05A8:  MOVLW  02
05AA:  MOVWF  00
05AC:  DECFSZ 00,F
05AE:  BRA    05AC
05B0:  MOVLW  02
05B2:  MOVWF  00
05B4:  DECFSZ 00,F
05B6:  BRA    05B4
05B8:  BSF    F93.5
05BA:  BTFSS  F81.5
05BC:  BRA    05BA
05BE:  CLRF   01
05C0:  MOVLW  02
05C2:  MOVWF  00
05C4:  DECFSZ 00,F
05C6:  BRA    05C4
05C8:  BTFSC  F81.4
05CA:  BSF    01.0
05CC:  BCF    F8A.5
05CE:  BCF    F93.5
05D0:  BCF    F8A.4
05D2:  BCF    F93.4
05D4:  RETURN 0
.................... #include <i2c_Flex_LCD.c>    
....................  
.................... //-----------------------------------------------------------------------------  
.................... // Title:         i2c_Flex_LCD  
.................... // Description:   Driver for common LCD with 1/2/3 or 4 row modules using PCF8574T interface board with I2C protocol.  
.................... // Date:          Nov-2013  
.................... // Ver.Rev.:      1.0  
.................... // Author:        Hugo Silva (sergio-hugo@bol.com.br) #Based on the routines of 20X4_LCD_I2C_DRIVER.h from Pumrin S.  
.................... //-----------------------------------------------------------------------------  
.................... //  
.................... // lcd_init() Must be called before any other function.  
.................... //  
.................... // lcd_putc(c) Will display c on the next position of the LCD.  
.................... //   
.................... //     \f Clear LCD dispay  
.................... //     \1 Set write position on LCD Line 1  
.................... //     \2 Set write position on LCD Line 2  
.................... //     \3 Set write position on LCD Line 3  
.................... //     \4 Set write position on LCD Line 4  
.................... //  
.................... //     lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)  
.................... //  
.................... //-----------------------------------------------------------------------------  
.................... // LCD pins D0-D3 are not used.  
.................... //-----------------------------------------------------------------------------  
.................... //  
.................... // Commment   : Control of a compatible LCD HITACHI from a bus I2C with  
.................... //              an EXPANDER of I/O with connection I2C. The tests of these  
.................... //              routines have been programmed using the IC PCF8574T of Phillips.  
.................... //              I used 4 bits mode programming. The 8 bits mode programming  
.................... //              is possible if you use 2 x PCF8574T.  
.................... //  
.................... // As defined in the following structure the pin connection is as follows:  
.................... //  
.................... //  PCF8574P     LCD  
.................... //  ========     ======  
.................... //     P0        RS  
.................... //     P1        RW  
.................... //     P2        Enable   
.................... //     P3        Led Backlight  
.................... //     P4        D4  
.................... //     P5        D5  
.................... //     P6        D6  
.................... //     P7        D7  
.................... //  
.................... //  The SCL and SDA pins should be pull-up resistor as shown below:  
.................... //  
.................... //             +5v  
.................... //               |  
.................... //               <  
.................... //               > 4.7K         
.................... //               <           
.................... //To PIC         |          To i2c slave  
.................... //pin xx ------------------ SDA pin   
.................... //(SDA)                       
.................... //              +5v  
.................... //               |  
.................... //               <  
.................... //               > 4.7K         
.................... //               <           
.................... //To PIC         |          To i2c slave  
.................... //pin xx ------------------ SCL pin   
.................... //(SCL)  
.................... //  
.................... //To PIC                    To i2c slave  
.................... //Vss pin ----------------- Vss or ground pin   
.................... //                |  
.................... //              -----  
.................... //               ---  Ground  
.................... //                -   
.................... //   
.................... // THIS DOCUMENT IS PROVIDED TO THE USER "AS IS"  
.................... //-----------------------------------------------------------------------------  
....................  
.................... #define LCD_ADDR       0x7E//0x4E //I2C slave address for LCD module  
....................  
.................... #define ON             1  
.................... #define OFF            0  
.................... #define RS             0b00000001  //P0 - PCF8574T Pin connected to RS  
.................... #define RW             0b00000010  //P1 - PCF8574T Pin connected to RW  
.................... #define EN             0b00000100  //P2 - PCF8574T Pin connected to EN  
.................... #define BACKLIGHT_LED  0b00001000  //P3 - PCF8574T Pin connected to BACKLIGHT LED  
....................  
.................... #define lcd_line_one   0x80   // LCD RAM address for line 1  
.................... #define lcd_line_two   0xC0   // LCD RAM address for line 2  
.................... #define lcd_line_three 0x94   // LCD RAM address for line 3  
.................... #define lcd_line_four  0xD4   // LCD RAM address for line 4  
....................    
.................... byte address;  
.................... int1 lcd_backlight=ON;  
....................  
.................... void i2c_send_nibble(unsigned char data)  
....................    {     
....................         i2c_start();  
05D6:  BSF    F93.4
05D8:  MOVLW  02
05DA:  MOVWF  00
05DC:  DECFSZ 00,F
05DE:  BRA    05DC
05E0:  BSF    F93.5
05E2:  MOVLW  02
05E4:  MOVWF  00
05E6:  DECFSZ 00,F
05E8:  BRA    05E6
05EA:  BCF    F8A.4
05EC:  BCF    F93.4
05EE:  MOVLW  02
05F0:  MOVWF  00
05F2:  DECFSZ 00,F
05F4:  BRA    05F2
05F6:  BCF    F8A.5
05F8:  BCF    F93.5
....................         delay_us(1);  
05FA:  MOVLW  03
05FC:  MOVWF  00
05FE:  DECFSZ 00,F
0600:  BRA    05FE
0602:  BRA    0604
....................         i2c_write(LCD_ADDR); //the slave addresse  
0604:  MOVLW  7E
0606:  MOVWF  x8C
0608:  RCALL  056A
....................         delay_us(1);  
060A:  MOVLW  03
060C:  MOVWF  00
060E:  DECFSZ 00,F
0610:  BRA    060E
0612:  BRA    0614
....................         i2c_write(data);  
0614:  MOVFF  8B,8C
0618:  RCALL  056A
....................         delay_us(1);  
061A:  MOVLW  03
061C:  MOVWF  00
061E:  DECFSZ 00,F
0620:  BRA    061E
0622:  BRA    0624
....................         i2c_stop();  
0624:  BCF    F93.4
0626:  NOP   
0628:  BSF    F93.5
062A:  BTFSS  F81.5
062C:  BRA    062A
062E:  MOVLW  02
0630:  MOVWF  00
0632:  DECFSZ 00,F
0634:  BRA    0632
0636:  BRA    0638
0638:  NOP   
063A:  BSF    F93.4
063C:  MOVLW  02
063E:  MOVWF  00
0640:  DECFSZ 00,F
0642:  BRA    0640
....................         delay_us(1);  
0644:  MOVLW  03
0646:  MOVWF  00
0648:  DECFSZ 00,F
064A:  BRA    0648
064C:  BRA    064E
064E:  RETURN 0
....................    }  
....................  
.................... void lcd_send_byte(unsigned char data)  
....................    {  
....................         if (lcd_backlight) data=data|EN|BACKLIGHT_LED; else data=data|EN; //set pin EN  
0650:  BTFSS  1E.0
0652:  BRA    065E
0654:  MOVF   x8A,W
0656:  IORLW  04
0658:  IORLW  08
065A:  MOVWF  x8A
065C:  BRA    0660
065E:  BSF    x8A.2
....................         i2c_send_nibble(data);  
0660:  MOVFF  8A,8B
0664:  RCALL  05D6
....................         data=data-4;       //toggle EN back to 0  
0666:  MOVLW  04
0668:  SUBWF  x8A,F
....................         i2c_send_nibble(data);  
066A:  MOVFF  8A,8B
066E:  RCALL  05D6
0670:  RETURN 0
....................    }  
....................      
.................... void lcd_clear()  
.................... {  
....................     lcd_send_byte(0x00);  
0672:  CLRF   x8A
0674:  RCALL  0650
....................     lcd_send_byte(0x10);  
0676:  MOVLW  10
0678:  MOVWF  x8A
067A:  RCALL  0650
067C:  CLRF   16
067E:  BTFSC  FF2.7
0680:  BSF    16.7
0682:  BCF    FF2.7
....................     delay_ms(2);  
0684:  MOVLW  02
0686:  MOVWF  x9C
0688:  RCALL  014A
068A:  BTFSC  16.7
068C:  BSF    FF2.7
068E:  RETURN 0
.................... }  
....................  
.................... void lcd_init()  
0690:  CLRF   16
0692:  BTFSC  FF2.7
0694:  BSF    16.7
0696:  BCF    FF2.7
.................... {  
....................     delay_ms(10); //LCD power up delay  
0698:  MOVLW  0A
069A:  MOVWF  x9C
069C:  RCALL  014A
069E:  BTFSC  16.7
06A0:  BSF    FF2.7
....................          
....................    //Request works on the command by set the RS = 0 R/W = 0 write  
....................         lcd_send_byte(0x00);  
06A2:  CLRF   x8A
06A4:  RCALL  0650
....................         lcd_send_byte(0x10);  
06A6:  MOVLW  10
06A8:  MOVWF  x8A
06AA:  RCALL  0650
....................         lcd_send_byte(0x00);  
06AC:  CLRF   x8A
06AE:  RCALL  0650
....................         lcd_send_byte(0x00);  
06B0:  CLRF   x8A
06B2:  RCALL  0650
....................         lcd_send_byte(0x10);  
06B4:  MOVLW  10
06B6:  MOVWF  x8A
06B8:  RCALL  0650
....................            //First state in 8 bit mode  
....................         lcd_send_byte(0x30);  
06BA:  MOVLW  30
06BC:  MOVWF  x8A
06BE:  RCALL  0650
....................         lcd_send_byte(0x30);  
06C0:  MOVLW  30
06C2:  MOVWF  x8A
06C4:  RCALL  0650
....................            //Then set to 4-bit mode  
....................         lcd_send_byte(0x30);  
06C6:  MOVLW  30
06C8:  MOVWF  x8A
06CA:  RCALL  0650
....................         lcd_send_byte(0x20);  
06CC:  MOVLW  20
06CE:  MOVWF  x8A
06D0:  RCALL  0650
....................            //mode 4 bits, 2 lines, characters 5 x 7 (28 h)  
....................         lcd_send_byte(0x20);  
06D2:  MOVLW  20
06D4:  MOVWF  x8A
06D6:  RCALL  0650
....................         lcd_send_byte(0x80);  
06D8:  MOVLW  80
06DA:  MOVWF  x8A
06DC:  RCALL  0650
....................            //no need cursor on (0Ch)  
....................         lcd_send_byte(0x00);  
06DE:  CLRF   x8A
06E0:  RCALL  0650
....................         lcd_send_byte(0xC0);  
06E2:  MOVLW  C0
06E4:  MOVWF  x8A
06E6:  RCALL  0650
....................            //the cursor moves to the left (06 h)  
....................         lcd_send_byte(0x00);  
06E8:  CLRF   x8A
06EA:  RCALL  0650
....................         lcd_send_byte(0x60);  
06EC:  MOVLW  60
06EE:  MOVWF  x8A
06F0:  RCALL  0650
....................            //clears the display  
....................         lcd_clear();  
06F2:  RCALL  0672
06F4:  GOTO   1A54 (RETURN)
.................... }  
....................  
.................... void lcd_gotoxy( byte x, byte y)  
.................... {       
.................... static char data;  
....................        
....................    switch(y)  
06F8:  MOVF   x89,W
06FA:  XORLW  01
06FC:  BZ    070C
06FE:  XORLW  03
0700:  BZ    0712
0702:  XORLW  01
0704:  BZ    0718
0706:  XORLW  07
0708:  BZ    071E
070A:  BRA    0724
....................    {  
....................       case 1:  address= lcd_line_one;     break;  
070C:  MOVLW  80
070E:  MOVWF  1D
0710:  BRA    0728
....................       case 2:  address= lcd_line_two;     break;  
0712:  MOVLW  C0
0714:  MOVWF  1D
0716:  BRA    0728
....................       case 3:  address= lcd_line_three;   break;  
0718:  MOVLW  94
071A:  MOVWF  1D
071C:  BRA    0728
....................       case 4:  address= lcd_line_four;    break;  
071E:  MOVLW  D4
0720:  MOVWF  1D
0722:  BRA    0728
....................       default: address= lcd_line_one;     break;   
0724:  MOVLW  80
0726:  MOVWF  1D
....................    }  
....................    
....................    address+=x-1;  
0728:  MOVLW  01
072A:  SUBWF  x88,W
072C:  ADDWF  1D,F
....................    data=address&0xF0;  
072E:  MOVF   1D,W
0730:  ANDLW  F0
0732:  MOVWF  1F
....................    lcd_send_byte(data);  
0734:  MOVFF  1F,8A
0738:  RCALL  0650
....................    data=address&0x0F;  
073A:  MOVF   1D,W
073C:  ANDLW  0F
073E:  MOVWF  1F
....................    data=data<<4;  
0740:  SWAPF  1F,F
0742:  MOVLW  F0
0744:  ANDWF  1F,F
....................    lcd_send_byte(data);  
0746:  MOVFF  1F,8A
074A:  RCALL  0650
074C:  RETURN 0
.................... }  
....................  
.................... //Display the character on LCD screen.  
.................... void LCD_PUTC(char in_data)  
.................... {  
....................  char data;       
....................   switch(in_data)  
074E:  MOVF   x86,W
0750:  XORLW  0C
0752:  BZ    0766
0754:  XORLW  0D
0756:  BZ    076A
0758:  XORLW  03
075A:  BZ    0774
075C:  XORLW  01
075E:  BZ    0780
0760:  XORLW  07
0762:  BZ    078C
0764:  BRA    0798
....................    {   
....................      case '\f': lcd_clear()    ;  break;                 
0766:  RCALL  0672
0768:  BRA    07BA
....................      case '\1': lcd_gotoxy(1,1);  break;  
076A:  MOVLW  01
076C:  MOVWF  x88
076E:  MOVWF  x89
0770:  RCALL  06F8
0772:  BRA    07BA
....................      case '\2': lcd_gotoxy(1,2);  break;  
0774:  MOVLW  01
0776:  MOVWF  x88
0778:  MOVLW  02
077A:  MOVWF  x89
077C:  RCALL  06F8
077E:  BRA    07BA
....................      case '\3': lcd_gotoxy(1,3);  break;  
0780:  MOVLW  01
0782:  MOVWF  x88
0784:  MOVLW  03
0786:  MOVWF  x89
0788:  RCALL  06F8
078A:  BRA    07BA
....................      case '\4': lcd_gotoxy(1,4);  break;  
078C:  MOVLW  01
078E:  MOVWF  x88
0790:  MOVLW  04
0792:  MOVWF  x89
0794:  RCALL  06F8
0796:  BRA    07BA
....................  
....................      default:  
....................         data=in_data&0xF0;  
0798:  MOVF   x86,W
079A:  ANDLW  F0
079C:  MOVWF  x87
....................         data=data|RS; //set RS pin to 1  
079E:  BSF    x87.0
....................         lcd_send_byte(data);  
07A0:  MOVFF  87,8A
07A4:  RCALL  0650
....................         data=in_data&0x0F;  
07A6:  MOVF   x86,W
07A8:  ANDLW  0F
07AA:  MOVWF  x87
....................         data=data<<4;  
07AC:  SWAPF  x87,F
07AE:  MOVLW  F0
07B0:  ANDWF  x87,F
....................         data=data|RS; //set RS pin to 1  
07B2:  BSF    x87.0
....................         lcd_send_byte(data);  
07B4:  MOVFF  87,8A
07B8:  RCALL  0650
....................      break;  
....................    }  
07BA:  RETURN 0
.................... }  
....................  
.................... //#include <LCD420-FLEX.c> 
....................  
.................... #define sentidox PIN_D0 
.................... #define sentidoy PIN_D1 
.................... #define sentidoz PIN_D2 
.................... #define motorx PIN_D3 
.................... #define motory PIN_D4 
.................... #define motorz PIN_D5 
.................... #define cerox PIN_D6 
.................... #define ceroy PIN_D7 
.................... #define ceroz PIN_C0 
.................... #define profunz PIN_C1 
.................... #define dremel PIN_E0 
.................... #define enter PIN_E1 
.................... #define habilx PIN_E2 
.................... #define habily PIN_A0 
.................... #define habilz PIN_A1 
.................... #define canalb PIN_A2 
.................... #define buzzer PIN_A3 
....................  
.................... char ch; 
.................... char mech[5]; 
.................... char datox[7]; 
.................... char datoy[7]; 
.................... int i, j, h, flagfin, salir; 
.................... int contador, contador1; 
.................... signed int32 x, y, xini, yini, pasosx, pasosy; 
.................... float broca, pasosxflot, pasosyflot; 
.................... int flagx, flagy, flagxy, flagcomienzo, flagmecha, flagboton; 
.................... short int flagpaquete, flagajuste; 
.................... signed int32 pasosz, zini, z, alturamecha, guarda; 
....................  
.................... void moverz(void)  
.................... { 
....................     output_low(habilz); 
*
17C6:  BCF    F92.1
17C8:  BCF    F89.1
....................     pasosz = z - zini; 
17CA:  MOVF   x69,W
17CC:  SUBWF  x6D,W
17CE:  MOVWF  x65
17D0:  MOVF   x6A,W
17D2:  SUBWFB x6E,W
17D4:  MOVWF  x66
17D6:  MOVF   x6B,W
17D8:  SUBWFB x6F,W
17DA:  MOVWF  x67
17DC:  MOVF   x6C,W
17DE:  SUBWFB x70,W
17E0:  MOVWF  x68
....................      
....................     while (pasosz > 0)  
17E2:  BTFSC  x68.7
17E4:  BRA    1862
17E6:  MOVF   x68,F
17E8:  BNZ   17F8
17EA:  MOVF   x67,F
17EC:  BNZ   17F8
17EE:  MOVF   x66,F
17F0:  BNZ   17F8
17F2:  MOVF   x65,W
17F4:  SUBLW  00
17F6:  BC    1862
....................     { 
....................         output_high(sentidoz); //para abajo 
17F8:  BCF    F95.2
17FA:  BSF    F8C.2
....................         output_high(motorz); 
17FC:  BCF    F95.5
17FE:  BSF    F8C.5
....................         delay_us(1200); 
1800:  CLRF   16
1802:  BTFSC  FF2.7
1804:  BSF    16.7
1806:  BCF    FF2.7
1808:  MOVLW  01
180A:  MOVWF  x9C
180C:  CALL   014A
1810:  BTFSC  16.7
1812:  BSF    FF2.7
1814:  CLRF   16
1816:  BTFSC  FF2.7
1818:  BSF    16.7
181A:  BCF    FF2.7
181C:  MOVLW  C8
181E:  MOVWF  x9C
1820:  CALL   0172
1824:  BTFSC  16.7
1826:  BSF    FF2.7
....................         output_low(motorz); 
1828:  BCF    F95.5
182A:  BCF    F8C.5
....................         delay_us(1200); 
182C:  CLRF   16
182E:  BTFSC  FF2.7
1830:  BSF    16.7
1832:  BCF    FF2.7
1834:  MOVLW  01
1836:  MOVWF  x9C
1838:  CALL   014A
183C:  BTFSC  16.7
183E:  BSF    FF2.7
1840:  CLRF   16
1842:  BTFSC  FF2.7
1844:  BSF    16.7
1846:  BCF    FF2.7
1848:  MOVLW  C8
184A:  MOVWF  x9C
184C:  CALL   0172
1850:  BTFSC  16.7
1852:  BSF    FF2.7
....................         pasosz = pasosz - 1; 
1854:  MOVLW  01
1856:  SUBWF  x65,F
1858:  MOVLW  00
185A:  SUBWFB x66,F
185C:  SUBWFB x67,F
185E:  SUBWFB x68,F
1860:  BRA    17E2
....................     } 
....................     while (pasosz < 0)  
1862:  BTFSS  x68.7
1864:  BRA    18D0
....................     { 
....................         output_low(sentidoz); //para arriba 
1866:  BCF    F95.2
1868:  BCF    F8C.2
....................         output_high(motorz); 
186A:  BCF    F95.5
186C:  BSF    F8C.5
....................         delay_us(1200); 
186E:  CLRF   16
1870:  BTFSC  FF2.7
1872:  BSF    16.7
1874:  BCF    FF2.7
1876:  MOVLW  01
1878:  MOVWF  x9C
187A:  CALL   014A
187E:  BTFSC  16.7
1880:  BSF    FF2.7
1882:  CLRF   16
1884:  BTFSC  FF2.7
1886:  BSF    16.7
1888:  BCF    FF2.7
188A:  MOVLW  C8
188C:  MOVWF  x9C
188E:  CALL   0172
1892:  BTFSC  16.7
1894:  BSF    FF2.7
....................         output_low(motorz); 
1896:  BCF    F95.5
1898:  BCF    F8C.5
....................         delay_us(1200); 
189A:  CLRF   16
189C:  BTFSC  FF2.7
189E:  BSF    16.7
18A0:  BCF    FF2.7
18A2:  MOVLW  01
18A4:  MOVWF  x9C
18A6:  CALL   014A
18AA:  BTFSC  16.7
18AC:  BSF    FF2.7
18AE:  CLRF   16
18B0:  BTFSC  FF2.7
18B2:  BSF    16.7
18B4:  BCF    FF2.7
18B6:  MOVLW  C8
18B8:  MOVWF  x9C
18BA:  CALL   0172
18BE:  BTFSC  16.7
18C0:  BSF    FF2.7
....................         pasosz = pasosz + 1; 
18C2:  MOVLW  01
18C4:  ADDWF  x65,F
18C6:  MOVLW  00
18C8:  ADDWFC x66,F
18CA:  ADDWFC x67,F
18CC:  ADDWFC x68,F
18CE:  BRA    1862
....................     } 
....................     zini = z; 
18D0:  MOVFF  70,6C
18D4:  MOVFF  6F,6B
18D8:  MOVFF  6E,6A
18DC:  MOVFF  6D,69
18E0:  RETURN 0
.................... } 
....................  
.................... void bajarz(void)  
.................... { 
....................     while (pasosz > 0) //rutina que baja el cabezal 
....................     {  
....................         output_low(habilz); 
....................         pasosz = pasosz - 1; 
....................         output_high(sentidoz); 
....................         output_toggle(motorz); 
....................         delay_us(1200); 
....................     } 
.................... } 
....................  
.................... void subirz(void)  
.................... { 
....................     while (pasosz > 0) //rutina que sube el cabezal 
....................     {  
....................         output_low(sentidoz); 
....................         pasosz = pasosz - 1; 
....................         output_toggle(motorz); 
....................         delay_us(1200); 
....................     } 
.................... } 
....................  
.................... void conversionpasos(void)  
.................... { 
....................     pasosxflot = (x - xini) / 200.0; 
*
0E00:  MOVF   43,W
0E02:  SUBWF  3B,W
0E04:  MOVWF  x79
0E06:  MOVF   44,W
0E08:  SUBWFB 3C,W
0E0A:  MOVWF  x7A
0E0C:  MOVF   45,W
0E0E:  SUBWFB 3D,W
0E10:  MOVWF  x7B
0E12:  MOVF   46,W
0E14:  SUBWFB 3E,W
0E16:  MOVWF  x7C
0E18:  MOVWF  x80
0E1A:  MOVFF  7B,7F
0E1E:  MOVFF  7A,7E
0E22:  MOVFF  79,7D
0E26:  RCALL  08E4
0E28:  MOVFF  03,8F
0E2C:  MOVFF  02,8E
0E30:  MOVFF  01,8D
0E34:  MOVFF  00,8C
0E38:  CLRF   x93
0E3A:  CLRF   x92
0E3C:  MOVLW  48
0E3E:  MOVWF  x91
0E40:  MOVLW  86
0E42:  MOVWF  x90
0E44:  RCALL  093A
0E46:  MOVFF  03,5A
0E4A:  MOVFF  02,59
0E4E:  MOVFF  01,58
0E52:  MOVFF  00,57
....................     pasosyflot = (y - yini) / 200.0; 
0E56:  MOVF   47,W
0E58:  SUBWF  3F,W
0E5A:  MOVWF  x79
0E5C:  MOVF   48,W
0E5E:  SUBWFB 40,W
0E60:  MOVWF  x7A
0E62:  MOVF   49,W
0E64:  SUBWFB 41,W
0E66:  MOVWF  x7B
0E68:  MOVF   4A,W
0E6A:  SUBWFB 42,W
0E6C:  MOVWF  x7C
0E6E:  MOVWF  x80
0E70:  MOVFF  7B,7F
0E74:  MOVFF  7A,7E
0E78:  MOVFF  79,7D
0E7C:  RCALL  08E4
0E7E:  MOVFF  03,8F
0E82:  MOVFF  02,8E
0E86:  MOVFF  01,8D
0E8A:  MOVFF  00,8C
0E8E:  CLRF   x93
0E90:  CLRF   x92
0E92:  MOVLW  48
0E94:  MOVWF  x91
0E96:  MOVLW  86
0E98:  MOVWF  x90
0E9A:  RCALL  093A
0E9C:  MOVFF  03,5E
0EA0:  MOVFF  02,5D
0EA4:  MOVFF  01,5C
0EA8:  MOVFF  00,5B
....................     if (pasosxflot >= 0) 
0EAC:  CLRF   x7C
0EAE:  CLRF   x7B
0EB0:  CLRF   x7A
0EB2:  CLRF   x79
0EB4:  MOVFF  5A,80
0EB8:  MOVFF  59,7F
0EBC:  MOVFF  58,7E
0EC0:  MOVFF  57,7D
0EC4:  RCALL  0A94
0EC6:  BC    0ECA
0EC8:  BNZ   0F20
....................         pasosx = (signed long int) (pasosxflot + 0.5); 
0ECA:  BCF    FD8.1
0ECC:  MOVFF  5A,8F
0ED0:  MOVFF  59,8E
0ED4:  MOVFF  58,8D
0ED8:  MOVFF  57,8C
0EDC:  CLRF   x93
0EDE:  CLRF   x92
0EE0:  CLRF   x91
0EE2:  MOVLW  7E
0EE4:  MOVWF  x90
0EE6:  RCALL  0B0A
0EE8:  MOVFF  03,7C
0EEC:  MOVFF  02,7B
0EF0:  MOVFF  01,7A
0EF4:  MOVFF  00,79
0EF8:  RCALL  0D74
0EFA:  MOVFF  01,00
0EFE:  MOVFF  02,01
0F02:  CLRF   02
0F04:  CLRF   03
0F06:  BTFSS  01.7
0F08:  BRA    0F0E
0F0A:  DECF   02,F
0F0C:  DECF   03,F
0F0E:  MOVFF  03,4E
0F12:  MOVFF  02,4D
0F16:  MOVFF  01,4C
0F1A:  MOVFF  00,4B
0F1E:  BRA    0F74
....................     else 
....................         pasosx = (signed long int) (pasosxflot - 0.5); 
0F20:  BSF    FD8.1
0F22:  MOVFF  5A,8F
0F26:  MOVFF  59,8E
0F2A:  MOVFF  58,8D
0F2E:  MOVFF  57,8C
0F32:  CLRF   x93
0F34:  CLRF   x92
0F36:  CLRF   x91
0F38:  MOVLW  7E
0F3A:  MOVWF  x90
0F3C:  RCALL  0B0A
0F3E:  MOVFF  03,7C
0F42:  MOVFF  02,7B
0F46:  MOVFF  01,7A
0F4A:  MOVFF  00,79
0F4E:  RCALL  0D74
0F50:  MOVFF  01,00
0F54:  MOVFF  02,01
0F58:  CLRF   02
0F5A:  CLRF   03
0F5C:  BTFSS  01.7
0F5E:  BRA    0F64
0F60:  DECF   02,F
0F62:  DECF   03,F
0F64:  MOVFF  03,4E
0F68:  MOVFF  02,4D
0F6C:  MOVFF  01,4C
0F70:  MOVFF  00,4B
....................  
....................     if (pasosyflot >= 0) 
0F74:  CLRF   x7C
0F76:  CLRF   x7B
0F78:  CLRF   x7A
0F7A:  CLRF   x79
0F7C:  MOVFF  5E,80
0F80:  MOVFF  5D,7F
0F84:  MOVFF  5C,7E
0F88:  MOVFF  5B,7D
0F8C:  RCALL  0A94
0F8E:  BC    0F92
0F90:  BNZ   0FE8
....................         pasosy = (signed long int) (pasosyflot + 0.5); 
0F92:  BCF    FD8.1
0F94:  MOVFF  5E,8F
0F98:  MOVFF  5D,8E
0F9C:  MOVFF  5C,8D
0FA0:  MOVFF  5B,8C
0FA4:  CLRF   x93
0FA6:  CLRF   x92
0FA8:  CLRF   x91
0FAA:  MOVLW  7E
0FAC:  MOVWF  x90
0FAE:  RCALL  0B0A
0FB0:  MOVFF  03,7C
0FB4:  MOVFF  02,7B
0FB8:  MOVFF  01,7A
0FBC:  MOVFF  00,79
0FC0:  RCALL  0D74
0FC2:  MOVFF  01,00
0FC6:  MOVFF  02,01
0FCA:  CLRF   02
0FCC:  CLRF   03
0FCE:  BTFSS  01.7
0FD0:  BRA    0FD6
0FD2:  DECF   02,F
0FD4:  DECF   03,F
0FD6:  MOVFF  03,52
0FDA:  MOVFF  02,51
0FDE:  MOVFF  01,50
0FE2:  MOVFF  00,4F
0FE6:  BRA    103C
....................     else 
....................         pasosy = (signed long int) (pasosyflot - 0.5); 
0FE8:  BSF    FD8.1
0FEA:  MOVFF  5E,8F
0FEE:  MOVFF  5D,8E
0FF2:  MOVFF  5C,8D
0FF6:  MOVFF  5B,8C
0FFA:  CLRF   x93
0FFC:  CLRF   x92
0FFE:  CLRF   x91
1000:  MOVLW  7E
1002:  MOVWF  x90
1004:  RCALL  0B0A
1006:  MOVFF  03,7C
100A:  MOVFF  02,7B
100E:  MOVFF  01,7A
1012:  MOVFF  00,79
1016:  RCALL  0D74
1018:  MOVFF  01,00
101C:  MOVFF  02,01
1020:  CLRF   02
1022:  CLRF   03
1024:  BTFSS  01.7
1026:  BRA    102C
1028:  DECF   02,F
102A:  DECF   03,F
102C:  MOVFF  03,52
1030:  MOVFF  02,51
1034:  MOVFF  01,50
1038:  MOVFF  00,4F
....................  
....................     pasosx = pasosx * 2; 
103C:  MOVFF  4E,7C
1040:  MOVFF  4D,7B
1044:  MOVFF  4C,7A
1048:  MOVFF  4B,79
104C:  CLRF   x80
104E:  CLRF   x7F
1050:  CLRF   x7E
1052:  MOVLW  02
1054:  MOVWF  x7D
1056:  RCALL  0DAC
1058:  MOVFF  03,4E
105C:  MOVFF  02,4D
1060:  MOVFF  01,4C
1064:  MOVFF  00,4B
....................     pasosy = pasosy * 2; 
1068:  MOVFF  52,7C
106C:  MOVFF  51,7B
1070:  MOVFF  50,7A
1074:  MOVFF  4F,79
1078:  CLRF   x80
107A:  CLRF   x7F
107C:  CLRF   x7E
107E:  MOVLW  02
1080:  MOVWF  x7D
1082:  RCALL  0DAC
1084:  MOVFF  03,52
1088:  MOVFF  02,51
108C:  MOVFF  01,50
1090:  MOVFF  00,4F
1094:  RETURN 0
.................... } 
....................  
.................... void perforacion(void)  
.................... { 
....................     output_high(dremel); 
*
1906:  BCF    F96.0
1908:  BSF    F8D.0
....................     while (flagpaquete == 0); 
190A:  BTFSS  1E.1
190C:  BRA    190A
....................     while (flagpaquete == 1)  
190E:  BTFSS  1E.1
1910:  BRA    19EE
....................     { 
....................         while (flagxy == 0); 
1912:  MOVF   x61,F
1914:  BZ    1912
....................         while (flagxy == 1)  
1916:  DECFSZ x61,W
1918:  BRA    19EC
....................         { 
....................             x = (signed long long int) atof(datox); 
191A:  CLRF   x7A
191C:  MOVLW  26
191E:  MOVWF  x79
1920:  CLRF   x7C
1922:  CLRF   x7B
1924:  RCALL  1226
1926:  MOVFF  03,89
192A:  MOVFF  02,88
192E:  MOVFF  01,87
1932:  MOVFF  00,86
1936:  RCALL  14A6
1938:  MOVFF  03,3E
193C:  MOVFF  02,3D
1940:  MOVFF  01,3C
1944:  MOVFF  00,3B
....................             y = (signed long long int) atof(datoy); 
1948:  CLRF   x7A
194A:  MOVLW  2D
194C:  MOVWF  x79
194E:  CLRF   x7C
1950:  CLRF   x7B
1952:  RCALL  1226
1954:  MOVFF  03,89
1958:  MOVFF  02,88
195C:  MOVFF  01,87
1960:  MOVFF  00,86
1964:  RCALL  14A6
1966:  MOVFF  03,42
196A:  MOVFF  02,41
196E:  MOVFF  01,40
1972:  MOVFF  00,3F
....................             conversionpasos(); 
1976:  CALL   0E00
....................             xini = x; 
197A:  MOVFF  3E,46
197E:  MOVFF  3D,45
1982:  MOVFF  3C,44
1986:  MOVFF  3B,43
....................             yini = y; 
198A:  MOVFF  42,4A
198E:  MOVFF  41,49
1992:  MOVFF  40,48
1996:  MOVFF  3F,47
....................             clear_interrupt(INT_TIMER0); 
199A:  BCF    FF2.2
....................             set_timer0(230); 
199C:  CLRF   FD7
199E:  MOVLW  E6
19A0:  MOVWF  FD6
....................             enable_interrupts(INT_TIMER0); //Habilita interrupcin timer0 
19A2:  BSF    FF2.5
....................             flagx = 1; 
19A4:  MOVLW  01
19A6:  MOVWF  5F
....................             flagy = 1; 
19A8:  MOVWF  x60
....................             while (flagxy == 1); 
19AA:  DECFSZ x61,W
19AC:  BRA    19B0
19AE:  BRA    19AA
....................             z = zini + 400; // Baja 4 mm 
19B0:  MOVLW  90
19B2:  ADDWF  x69,W
19B4:  MOVWF  x6D
19B6:  MOVLW  01
19B8:  ADDWFC x6A,W
19BA:  MOVWF  x6E
19BC:  MOVLW  00
19BE:  ADDWFC x6B,W
19C0:  MOVWF  x6F
19C2:  MOVLW  00
19C4:  ADDWFC x6C,W
19C6:  MOVWF  x70
....................             moverz(); 
19C8:  RCALL  17C6
....................             z = zini - 400; //sube 4mm 
19CA:  MOVLW  90
19CC:  SUBWF  x69,W
19CE:  MOVWF  x6D
19D0:  MOVLW  01
19D2:  SUBWFB x6A,W
19D4:  MOVWF  x6E
19D6:  MOVLW  00
19D8:  SUBWFB x6B,W
19DA:  MOVWF  x6F
19DC:  MOVLW  00
19DE:  SUBWFB x6C,W
19E0:  MOVWF  x70
....................             moverz(); 
19E2:  RCALL  17C6
....................             putc('*'); 
19E4:  MOVLW  2A
19E6:  CALL   0132
19EA:  BRA    1916
....................         } 
19EC:  BRA    190E
....................     } 
....................     output_low(dremel); 
19EE:  BCF    F96.0
19F0:  BCF    F8D.0
19F2:  GOTO   1E70 (RETURN)
.................... } 
....................  
.................... void moverxy(void)  
.................... { 
....................     clear_interrupt(INT_TIMER0); 
*
1096:  BCF    FF2.2
....................     set_timer0(230); 
1098:  CLRF   FD7
109A:  MOVLW  E6
109C:  MOVWF  FD6
....................     enable_interrupts(INT_TIMER0); //Habilita interrupcin timer0 
109E:  BSF    FF2.5
....................     flagx = 1; 
10A0:  MOVLW  01
10A2:  MOVWF  5F
....................     flagy = 1; 
10A4:  MOVWF  x60
....................     flagxy = 1; 
10A6:  MOVWF  x61
....................     while (flagxy == 1); 
10A8:  DECFSZ x61,W
10AA:  BRA    10AE
10AC:  BRA    10A8
10AE:  GOTO   10F6 (RETURN)
.................... } 
....................  
.................... void posicionmecha(void)  
.................... { 
....................     x = +175000; 
10B2:  CLRF   3E
10B4:  MOVLW  02
10B6:  MOVWF  3D
10B8:  MOVLW  AB
10BA:  MOVWF  3C
10BC:  MOVLW  98
10BE:  MOVWF  3B
....................     y = +205000; 
10C0:  CLRF   42
10C2:  MOVLW  03
10C4:  MOVWF  41
10C6:  MOVLW  20
10C8:  MOVWF  40
10CA:  MOVLW  C8
10CC:  MOVWF  3F
....................     conversionpasos(); 
10CE:  RCALL  0E00
....................     xini = x; 
10D0:  MOVFF  3E,46
10D4:  MOVFF  3D,45
10D8:  MOVFF  3C,44
10DC:  MOVFF  3B,43
....................     yini = y; 
10E0:  MOVFF  42,4A
10E4:  MOVFF  41,49
10E8:  MOVFF  40,48
10EC:  MOVFF  3F,47
....................     // pasosx=+1500;     //pasos para ir a punto de prueba 
....................     //pasosy=+1000;     //pasos para ir a puto de prueba 
....................     contador = 2; 
10F0:  MOVLW  02
10F2:  MOVWF  39
....................     moverxy(); 
10F4:  BRA    1096
....................     putc('M'); 
10F6:  MOVLW  4D
10F8:  CALL   0132
10FC:  RETURN 0
.................... } 
....................  
.................... void profundidadmecha(void)  
.................... { 
....................     printf(LCD_PUTC, "\f\1%s", "Ajustando Z"); 
*
1704:  MOVLW  0C
1706:  MOVWF  x86
1708:  CALL   074E
170C:  MOVLW  01
170E:  MOVWF  x86
1710:  CALL   074E
1714:  MOVLW  C6
1716:  MOVWF  FF6
1718:  MOVLW  00
171A:  MOVWF  FF7
171C:  CALL   07BC
....................     printf(LCD_PUTC, "\2%s", "Profundidad de mecha"); 
1720:  MOVLW  02
1722:  MOVWF  x86
1724:  CALL   074E
1728:  MOVLW  D2
172A:  MOVWF  FF6
172C:  MOVLW  00
172E:  MOVWF  FF7
1730:  CALL   07BC
....................     output_low(habilz); 
1734:  BCF    F92.1
1736:  BCF    F89.1
....................     output_low(habilx); 
1738:  BCF    F96.2
173A:  BCF    F8D.2
....................     output_low(habily); 
173C:  BCF    F92.0
173E:  BCF    F89.0
....................     output_low(motorz); 
1740:  BCF    F95.5
1742:  BCF    F8C.5
....................     while (input(profunz) == 1) { 
1744:  BSF    F94.1
1746:  BTFSS  F82.1
1748:  BRA    17B4
....................         output_high(sentidoz); 
174A:  BCF    F95.2
174C:  BSF    F8C.2
....................         output_high(motorz); 
174E:  BCF    F95.5
1750:  BSF    F8C.5
....................         delay_us(1200); 
1752:  CLRF   16
1754:  BTFSC  FF2.7
1756:  BSF    16.7
1758:  BCF    FF2.7
175A:  MOVLW  01
175C:  MOVWF  x9C
175E:  CALL   014A
1762:  BTFSC  16.7
1764:  BSF    FF2.7
1766:  CLRF   16
1768:  BTFSC  FF2.7
176A:  BSF    16.7
176C:  BCF    FF2.7
176E:  MOVLW  C8
1770:  MOVWF  x9C
1772:  CALL   0172
1776:  BTFSC  16.7
1778:  BSF    FF2.7
....................         output_low(motorz); 
177A:  BCF    F95.5
177C:  BCF    F8C.5
....................         delay_us(1200); 
177E:  CLRF   16
1780:  BTFSC  FF2.7
1782:  BSF    16.7
1784:  BCF    FF2.7
1786:  MOVLW  01
1788:  MOVWF  x9C
178A:  CALL   014A
178E:  BTFSC  16.7
1790:  BSF    FF2.7
1792:  CLRF   16
1794:  BTFSC  FF2.7
1796:  BSF    16.7
1798:  BCF    FF2.7
179A:  MOVLW  C8
179C:  MOVWF  x9C
179E:  CALL   0172
17A2:  BTFSC  16.7
17A4:  BSF    FF2.7
....................         alturamecha = alturamecha + 1; 
17A6:  MOVLW  01
17A8:  ADDWF  x71,F
17AA:  MOVLW  00
17AC:  ADDWFC x72,F
17AE:  ADDWFC x73,F
17B0:  ADDWFC x74,F
17B2:  BRA    1744
....................     } 
....................     // alturamecha=alturamecha-500; //le resta el espesor de la base + 1mm total 4,5 mm 
....................     zini = alturamecha; 
17B4:  MOVFF  74,6C
17B8:  MOVFF  73,6B
17BC:  MOVFF  72,6A
17C0:  MOVFF  71,69
17C4:  RETURN 0
.................... } 
....................  
.................... void ajusteceroz(void)  
.................... { 
....................     //printf(LCD_PUTC, "\f\1%s", "Ajustando eje Z"); 
....................     //printf(LCD_PUTC, "\2%s", "Espere por favor"); 
....................     output_low(habilz); 
*
07DC:  BCF    F92.1
07DE:  BCF    F89.1
....................     printf(LCD_PUTC, "\f\1%s", "Buscando cero Z"); 
07E0:  MOVLW  0C
07E2:  MOVWF  x86
07E4:  RCALL  074E
07E6:  MOVLW  01
07E8:  MOVWF  x86
07EA:  RCALL  074E
07EC:  MOVLW  E8
07EE:  MOVWF  FF6
07F0:  MOVLW  00
07F2:  MOVWF  FF7
07F4:  RCALL  07BC
....................     while ((input(ceroz)) == 0) { 
07F6:  BSF    F94.0
07F8:  BTFSC  F82.0
07FA:  BRA    082A
....................         output_low(sentidoz); 
07FC:  BCF    F95.2
07FE:  BCF    F8C.2
....................         output_toggle(motorz); 
0800:  BCF    F95.5
0802:  BTG    F8C.5
....................         delay_us(1200); 
0804:  CLRF   16
0806:  BTFSC  FF2.7
0808:  BSF    16.7
080A:  BCF    FF2.7
080C:  MOVLW  01
080E:  MOVWF  x9C
0810:  RCALL  014A
0812:  BTFSC  16.7
0814:  BSF    FF2.7
0816:  CLRF   16
0818:  BTFSC  FF2.7
081A:  BSF    16.7
081C:  BCF    FF2.7
081E:  MOVLW  C8
0820:  MOVWF  x9C
0822:  RCALL  0172
0824:  BTFSC  16.7
0826:  BSF    FF2.7
0828:  BRA    07F6
....................     } 
....................     printf(LCD_PUTC, "\f\1%s", "Buscando cero Z OK"); 
082A:  MOVLW  0C
082C:  MOVWF  x86
082E:  RCALL  074E
0830:  MOVLW  01
0832:  MOVWF  x86
0834:  RCALL  074E
0836:  MOVLW  F8
0838:  MOVWF  FF6
083A:  MOVLW  00
083C:  MOVWF  FF7
083E:  RCALL  07BC
....................     zini = 0; 
0840:  CLRF   x6C
0842:  CLRF   x6B
0844:  CLRF   x6A
0846:  CLRF   x69
0848:  RETURN 0
.................... } 
....................  
.................... void ajusteceroxy(void)  
.................... { 
....................     printf(LCD_PUTC, "\f\1%s", "Ajustando ejes X-Y"); 
084A:  MOVLW  0C
084C:  MOVWF  x86
084E:  RCALL  074E
0850:  MOVLW  01
0852:  MOVWF  x86
0854:  RCALL  074E
0856:  MOVLW  0C
0858:  MOVWF  FF6
085A:  MOVLW  01
085C:  MOVWF  FF7
085E:  RCALL  07BC
....................     printf(LCD_PUTC, "\2%s", "Espere por favor"); 
0860:  MOVLW  02
0862:  MOVWF  x86
0864:  RCALL  074E
0866:  MOVLW  20
0868:  MOVWF  FF6
086A:  MOVLW  01
086C:  MOVWF  FF7
086E:  RCALL  07BC
....................     //ajusteceroz(); 
....................     output_low(habilx); 
0870:  BCF    F96.2
0872:  BCF    F8D.2
....................     output_low(habily); 
0874:  BCF    F92.0
0876:  BCF    F89.0
....................     while ((input(cerox) == 0) || (input(ceroy)) == 0)  
0878:  BSF    F95.6
087A:  BTFSS  F83.6
087C:  BRA    0884
087E:  BSF    F95.7
0880:  BTFSC  F83.7
0882:  BRA    08C6
....................     { 
....................         if (input(cerox) == 0)  
0884:  BSF    F95.6
0886:  BTFSC  F83.6
0888:  BRA    0892
....................         { 
....................             output_high(sentidox); 
088A:  BCF    F95.0
088C:  BSF    F8C.0
....................             output_toggle(motorx); 
088E:  BCF    F95.3
0890:  BTG    F8C.3
....................         } 
....................         if (input(ceroy) == 0)  
0892:  BSF    F95.7
0894:  BTFSC  F83.7
0896:  BRA    08A0
....................         { 
....................             output_low(sentidoy); 
0898:  BCF    F95.1
089A:  BCF    F8C.1
....................             output_toggle(motory); 
089C:  BCF    F95.4
089E:  BTG    F8C.4
....................         } 
....................         delay_us(1200); 
08A0:  CLRF   16
08A2:  BTFSC  FF2.7
08A4:  BSF    16.7
08A6:  BCF    FF2.7
08A8:  MOVLW  01
08AA:  MOVWF  x9C
08AC:  RCALL  014A
08AE:  BTFSC  16.7
08B0:  BSF    FF2.7
08B2:  CLRF   16
08B4:  BTFSC  FF2.7
08B6:  BSF    16.7
08B8:  BCF    FF2.7
08BA:  MOVLW  C8
08BC:  MOVWF  x9C
08BE:  RCALL  0172
08C0:  BTFSC  16.7
08C2:  BSF    FF2.7
08C4:  BRA    0878
....................     } 
....................     output_low(motorx); 
08C6:  BCF    F95.3
08C8:  BCF    F8C.3
....................     output_low(motory); 
08CA:  BCF    F95.4
08CC:  BCF    F8C.4
....................     output_low(motorz); 
08CE:  BCF    F95.5
08D0:  BCF    F8C.5
....................     xini = 0; 
08D2:  CLRF   46
08D4:  CLRF   45
08D6:  CLRF   44
08D8:  CLRF   43
....................     yini = 0; 
08DA:  CLRF   4A
08DC:  CLRF   49
08DE:  CLRF   48
08E0:  CLRF   47
08E2:  RETURN 0
.................... } 
....................  
.................... void mecha(void)  
.................... { 
....................     while (flagmecha == 0); 
*
145E:  MOVF   x63,F
1460:  BZ    145E
....................     while (flagmecha == 1); 
1462:  DECFSZ x63,W
1464:  BRA    1468
1466:  BRA    1462
....................     broca = atof(mech); 
1468:  CLRF   x7A
146A:  MOVLW  21
146C:  MOVWF  x79
146E:  CLRF   x7C
1470:  CLRF   x7B
1472:  RCALL  1226
1474:  MOVFF  03,56
1478:  MOVFF  02,55
147C:  MOVFF  01,54
1480:  MOVFF  00,53
1484:  RETURN 0
.................... } 
....................  
.................... void bip(void)  
.................... { 
....................     output_high(buzzer); 
*
16F2:  BCF    F92.3
16F4:  BSF    F89.3
....................     contador1 = 5; // 1/48*4*65586*8*23=218453useg aprox 
16F6:  MOVLW  05
16F8:  MOVWF  3A
....................     clear_interrupt(INT_TIMER1); //limpio la bandera 
16FA:  BCF    F9E.0
....................     set_timer1(0); 
16FC:  CLRF   FCF
16FE:  CLRF   FCE
....................     enable_interrupts(INT_TIMER1); 
1700:  BSF    F9D.0
1702:  RETURN 0
.................... } 
....................  
.................... #INT_EXT2         //Atencin a interrupcin por cambio en RB2 
....................  
.................... ext_isr1() //Funcin de interrupcin 
.................... {  
....................     putc('F'); 
*
013A:  MOVLW  46
013C:  RCALL  0132
....................     flagajuste = 0; 
013E:  BCF    1E.2
....................     salir = 1; 
0140:  MOVLW  01
0142:  MOVWF  38
....................     // disable_interrupts(int_ext2_L2H); 
.................... } 
....................  
0144:  BCF    FF0.1
0146:  GOTO   0084
.................... #INT_EXT         //Atencin a interrupcin por cambio en RB0 
....................  
.................... void INTEXT_isr(void) //Funcin de interrupcin 
.................... {  
....................     output_low(motorz); 
*
0192:  BCF    F95.5
0194:  BCF    F8C.5
....................     if (input(canalb) == 0)  
0196:  BSF    F92.2
0198:  BTFSC  F80.2
019A:  BRA    01D0
....................     { 
....................         output_low(habilz); 
019C:  BCF    F92.1
019E:  BCF    F89.1
....................         output_low(sentidoz); //mecha para arriba 
01A0:  BCF    F95.2
01A2:  BCF    F8C.2
....................         z = z - 1; 
01A4:  MOVLW  01
01A6:  SUBWF  x6D,F
01A8:  MOVLW  00
01AA:  SUBWFB x6E,F
01AC:  SUBWFB x6F,F
01AE:  SUBWFB x70,F
....................         output_high(motorz); 
01B0:  BCF    F95.5
01B2:  BSF    F8C.5
....................         delay_us(1200); 
01B4:  MOVLW  01
01B6:  MOVWF  x9C
01B8:  RCALL  014A
01BA:  MOVLW  C8
01BC:  MOVWF  x9C
01BE:  RCALL  0172
....................         output_low(motorz); 
01C0:  BCF    F95.5
01C2:  BCF    F8C.5
....................         delay_us(1200); 
01C4:  MOVLW  01
01C6:  MOVWF  x9C
01C8:  RCALL  014A
01CA:  MOVLW  C8
01CC:  MOVWF  x9C
01CE:  RCALL  0172
....................     } 
....................     if (input(canalb) == 1)  
01D0:  BSF    F92.2
01D2:  BTFSS  F80.2
01D4:  BRA    020A
....................     { 
....................         output_low(habilz); 
01D6:  BCF    F92.1
01D8:  BCF    F89.1
....................         output_high(sentidoz); //mecha para abajo 
01DA:  BCF    F95.2
01DC:  BSF    F8C.2
....................         z = z + 1; 
01DE:  MOVLW  01
01E0:  ADDWF  x6D,F
01E2:  MOVLW  00
01E4:  ADDWFC x6E,F
01E6:  ADDWFC x6F,F
01E8:  ADDWFC x70,F
....................         output_high(motorz); 
01EA:  BCF    F95.5
01EC:  BSF    F8C.5
....................         delay_us(1200); 
01EE:  MOVLW  01
01F0:  MOVWF  x9C
01F2:  RCALL  014A
01F4:  MOVLW  C8
01F6:  MOVWF  x9C
01F8:  RCALL  0172
....................         output_low(motorz); 
01FA:  BCF    F95.5
01FC:  BCF    F8C.5
....................         delay_us(1200); 
01FE:  MOVLW  01
0200:  MOVWF  x9C
0202:  RCALL  014A
0204:  MOVLW  C8
0206:  MOVWF  x9C
0208:  RCALL  0172
....................     } 
.................... } 
020A:  BCF    FF2.1
020C:  GOTO   0084
.................... #int_TIMER0 
....................  
.................... void TIMER0_isr(void)  
.................... { 
....................     contador = contador - 1; 
0210:  MOVLW  01
0212:  SUBWF  39,F
....................  
....................     if (contador == 0)  
0214:  MOVF   39,F
0216:  BTFSS  FD8.2
0218:  BRA    02D2
....................     { 
....................         contador = 2; 
021A:  MOVLW  02
021C:  MOVWF  39
....................         if (pasosx == 0)  
021E:  MOVF   4B,F
0220:  BNZ   0230
0222:  MOVF   4C,F
0224:  BNZ   0230
0226:  MOVF   4D,F
0228:  BNZ   0230
022A:  MOVF   4E,F
022C:  BNZ   0230
....................         { 
....................             flagx = 0; 
022E:  CLRF   5F
....................         } 
....................         if (pasosx > 0)  
0230:  BTFSC  4E.7
0232:  BRA    025A
0234:  MOVF   4E,F
0236:  BNZ   0246
0238:  MOVF   4D,F
023A:  BNZ   0246
023C:  MOVF   4C,F
023E:  BNZ   0246
0240:  MOVF   4B,W
0242:  SUBLW  00
0244:  BC    025A
....................         { 
....................             output_low(sentidox); 
0246:  BCF    F95.0
0248:  BCF    F8C.0
....................             output_toggle(motorx); 
024A:  BCF    F95.3
024C:  BTG    F8C.3
....................             pasosx = pasosx - 1; 
024E:  MOVLW  01
0250:  SUBWF  4B,F
0252:  MOVLW  00
0254:  SUBWFB 4C,F
0256:  SUBWFB 4D,F
0258:  SUBWFB 4E,F
....................         } 
....................         if (pasosx < 0)  
025A:  BTFSS  4E.7
025C:  BRA    0272
....................         { 
....................             output_high(sentidox); 
025E:  BCF    F95.0
0260:  BSF    F8C.0
....................             output_toggle(motorx); 
0262:  BCF    F95.3
0264:  BTG    F8C.3
....................             pasosx = pasosx + 1; 
0266:  MOVLW  01
0268:  ADDWF  4B,F
026A:  MOVLW  00
026C:  ADDWFC 4C,F
026E:  ADDWFC 4D,F
0270:  ADDWFC 4E,F
....................         } 
....................  
....................         if (pasosy == 0)  
0272:  MOVF   4F,F
0274:  BNZ   0284
0276:  MOVF   50,F
0278:  BNZ   0284
027A:  MOVF   51,F
027C:  BNZ   0284
027E:  MOVF   52,F
0280:  BNZ   0284
....................         { 
....................             flagy = 0; 
0282:  CLRF   x60
....................         } 
....................         if (pasosy > 0)  
0284:  BTFSC  52.7
0286:  BRA    02AE
0288:  MOVF   52,F
028A:  BNZ   029A
028C:  MOVF   51,F
028E:  BNZ   029A
0290:  MOVF   50,F
0292:  BNZ   029A
0294:  MOVF   4F,W
0296:  SUBLW  00
0298:  BC    02AE
....................         { 
....................             output_high(sentidoy); 
029A:  BCF    F95.1
029C:  BSF    F8C.1
....................             output_toggle(motory); 
029E:  BCF    F95.4
02A0:  BTG    F8C.4
....................             pasosy = pasosy - 1; 
02A2:  MOVLW  01
02A4:  SUBWF  4F,F
02A6:  MOVLW  00
02A8:  SUBWFB 50,F
02AA:  SUBWFB 51,F
02AC:  SUBWFB 52,F
....................         } 
....................         if (pasosy < 0)  
02AE:  BTFSS  52.7
02B0:  BRA    02C6
....................         { 
....................             output_low(sentidoy); 
02B2:  BCF    F95.1
02B4:  BCF    F8C.1
....................             output_toggle(motory); 
02B6:  BCF    F95.4
02B8:  BTG    F8C.4
....................             pasosy = pasosy + 1; 
02BA:  MOVLW  01
02BC:  ADDWF  4F,F
02BE:  MOVLW  00
02C0:  ADDWFC 50,F
02C2:  ADDWFC 51,F
02C4:  ADDWFC 52,F
....................         } 
....................  
....................         if (flagx == 0 && flagy == 0)  
02C6:  MOVF   5F,F
02C8:  BNZ   02D2
02CA:  MOVF   x60,F
02CC:  BNZ   02D2
....................         { 
....................             flagxy = 0; 
02CE:  CLRF   x61
....................             disable_interrupts(INT_TIMER0); //deshabilita interrupcin timer0 
02D0:  BCF    FF2.5
....................         } 
....................  
....................     } 
....................     set_timer0(230); //Se recarga el timer0 
02D2:  CLRF   FD7
02D4:  MOVLW  E6
02D6:  MOVWF  FD6
.................... } 
....................  
02D8:  BCF    FF2.2
02DA:  GOTO   0084
.................... #int_TIMER1 
....................  
.................... void TIMER1_isr(void) // Timer para buzzer 
.................... { 
....................     contador1 = contador1 - 1; 
02DE:  MOVLW  01
02E0:  SUBWF  3A,F
....................  
....................     if (contador1 == 0)  
02E2:  MOVF   3A,F
02E4:  BNZ   02EC
....................     { 
....................         output_low(buzzer); 
02E6:  BCF    F92.3
02E8:  BCF    F89.3
....................         disable_interrupts(INT_TIMER1); 
02EA:  BCF    F9D.0
....................     } 
....................     set_timer1(0); 
02EC:  CLRF   FCF
02EE:  CLRF   FCE
.................... } 
02F0:  BCF    F9E.0
02F2:  GOTO   0084
.................... #int_rda 
....................  
.................... void serial_isr()  
.................... { 
....................     ch = getchar(); 
02F6:  BTFSS  F9E.5
02F8:  BRA    02F6
02FA:  MOVFF  FAE,20
....................     if (ch == 'F' && flagpaquete == 1) //Ciclo terminado 
02FE:  MOVF   20,W
0300:  SUBLW  46
0302:  BNZ   031A
0304:  BTFSS  1E.1
0306:  BRA    031A
....................     { 
....................         flagpaquete = flagpaquete + 1; 
0308:  MOVLW  00
030A:  BTFSC  1E.1
030C:  MOVLW  01
030E:  ADDLW  01
0310:  BCF    1E.1
0312:  BTFSC  FE8.0
0314:  BSF    1E.1
....................         flagfin = 1; 
0316:  MOVLW  01
0318:  MOVWF  37
....................     } 
....................     if (ch == 'A') //Inicio Ajuste 
031A:  MOVF   20,W
031C:  SUBLW  41
031E:  BNZ   032E
....................     { 
....................         flagajuste = flagajuste + 1; 
0320:  MOVLW  00
0322:  BTFSC  1E.2
0324:  MOVLW  01
0326:  ADDLW  01
0328:  BCF    1E.2
032A:  BTFSC  FE8.0
032C:  BSF    1E.2
....................     } 
....................     if (ch == 'P') //Dato de perforacion entrante 
032E:  MOVF   20,W
0330:  SUBLW  50
0332:  BNZ   0342
....................     { 
....................         flagpaquete = flagpaquete + 1; 
0334:  MOVLW  00
0336:  BTFSC  1E.1
0338:  MOVLW  01
033A:  ADDLW  01
033C:  BCF    1E.1
033E:  BTFSC  FE8.0
0340:  BSF    1E.1
....................     } 
....................     if (ch == 'S')  
0342:  MOVF   20,W
0344:  SUBLW  53
0346:  BNZ   034C
....................     { 
....................         flagcomienzo = 1; 
0348:  MOVLW  01
034A:  MOVWF  x62
....................     } 
....................     if (ch == 'M') //Mecha entrante 
034C:  MOVF   20,W
034E:  SUBLW  4D
0350:  BNZ   0358
....................     { 
....................         flagmecha = 1; 
0352:  MOVLW  01
0354:  MOVWF  x63
....................         h = 0; 
0356:  CLRF   36
....................     } 
....................     if ((flagmecha) == 1 && (ch != 'M')) //Dato mecha 
0358:  DECFSZ x63,W
035A:  BRA    0380
035C:  MOVF   20,W
035E:  SUBLW  4D
0360:  BZ    0380
....................     { 
....................         mech[h] = ch; 
0362:  CLRF   03
0364:  MOVF   36,W
0366:  ADDLW  21
0368:  MOVWF  FE9
036A:  MOVLW  00
036C:  ADDWFC 03,W
036E:  MOVWF  FEA
0370:  MOVFF  20,FEF
....................         h = h + 1; 
0374:  MOVLW  01
0376:  ADDWF  36,F
....................         if (h == 5)  
0378:  MOVF   36,W
037A:  SUBLW  05
037C:  BNZ   0380
....................         { 
....................             flagmecha = 0; 
037E:  CLRF   x63
....................         } 
....................     } 
....................     if (ch == 'X') //Valor X entrante 
0380:  MOVF   20,W
0382:  SUBLW  58
0384:  BNZ   038C
....................     { 
....................         flagx = 1; 
0386:  MOVLW  01
0388:  MOVWF  5F
....................         i = 0; 
038A:  CLRF   34
....................     } 
....................     if (ch == 'Y') //Valor Y entrante 
038C:  MOVF   20,W
038E:  SUBLW  59
0390:  BNZ   0398
....................     { 
....................         flagy = 1; 
0392:  MOVLW  01
0394:  MOVWF  x60
....................         j = 0; 
0396:  CLRF   35
....................     } 
....................     if ((flagx) == 1 && (ch != 'X')) //Dato X 
0398:  DECFSZ 5F,W
039A:  BRA    03C4
039C:  MOVF   20,W
039E:  SUBLW  58
03A0:  BZ    03C4
....................     { 
....................         datox[i] = ch; 
03A2:  CLRF   03
03A4:  MOVF   34,W
03A6:  ADDLW  26
03A8:  MOVWF  FE9
03AA:  MOVLW  00
03AC:  ADDWFC 03,W
03AE:  MOVWF  FEA
03B0:  MOVFF  20,FEF
....................         i = i + 1; 
03B4:  MOVLW  01
03B6:  ADDWF  34,F
....................         if (i == 7)  
03B8:  MOVF   34,W
03BA:  SUBLW  07
03BC:  BNZ   03C4
....................         { 
....................             flagx = 0; 
03BE:  CLRF   5F
....................             putc('*'); 
03C0:  MOVLW  2A
03C2:  RCALL  0132
....................         } 
....................     } 
....................     if ((flagy) == 1 && (ch != 'Y')) //Dato Y 
03C4:  DECFSZ x60,W
03C6:  BRA    03F4
03C8:  MOVF   20,W
03CA:  SUBLW  59
03CC:  BZ    03F4
....................     { 
....................         datoy[j] = ch; 
03CE:  CLRF   03
03D0:  MOVF   35,W
03D2:  ADDLW  2D
03D4:  MOVWF  FE9
03D6:  MOVLW  00
03D8:  ADDWFC 03,W
03DA:  MOVWF  FEA
03DC:  MOVFF  20,FEF
....................         j = j + 1; 
03E0:  MOVLW  01
03E2:  ADDWF  35,F
....................         if (j == 7) { 
03E4:  MOVF   35,W
03E6:  SUBLW  07
03E8:  BNZ   03F4
....................             flagy = 0; 
03EA:  CLRF   x60
....................             flagxy = 1; 
03EC:  MOVLW  01
03EE:  MOVWF  x61
....................             putc('*'); 
03F0:  MOVLW  2A
03F2:  RCALL  0132
....................         } 
....................     } 
03F4:  BCF    F9E.5
03F6:  GOTO   0084
.................... } 
....................  
.................... void main()  
*
19F6:  CLRF   FF8
19F8:  BCF    FD0.7
19FA:  BSF    07.7
19FC:  BSF    FB8.3
19FE:  MOVLW  E1
1A00:  MOVWF  FAF
1A02:  MOVLW  04
1A04:  MOVWF  FB0
1A06:  MOVLW  A6
1A08:  MOVWF  FAC
1A0A:  MOVLW  90
1A0C:  MOVWF  FAB
1A0E:  BSF    1E.0
1A10:  MOVF   FC1,W
1A12:  ANDLW  C0
1A14:  IORLW  0F
1A16:  MOVWF  FC1
1A18:  MOVLW  07
1A1A:  MOVWF  FB4
1A1C:  CLRF   17
1A1E:  CLRF   18
1A20:  CLRF   1F
.................... { 
....................     delay_ms(1000); 
1A22:  MOVLW  04
1A24:  MOVWF  x79
1A26:  CLRF   16
1A28:  BTFSC  FF2.7
1A2A:  BSF    16.7
1A2C:  BCF    FF2.7
1A2E:  MOVLW  FA
1A30:  MOVWF  x9C
1A32:  CALL   014A
1A36:  BTFSC  16.7
1A38:  BSF    FF2.7
1A3A:  DECFSZ x79,F
1A3C:  BRA    1A26
....................     enable_interrupts(INT_RDA); 
1A3E:  BSF    F9D.5
....................     setup_timer_0(RTCC_8_BIT | RTCC_DIV_256); //Configuracin timer0 
1A40:  MOVLW  C7
1A42:  MOVWF  FD5
....................     setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); //Configuracin timer1 
1A44:  MOVLW  B5
1A46:  MOVWF  FCD
....................  
....................     enable_interrupts(INT_EXT2_L2H); //Habilita int. RB2? 
1A48:  BSF    FF0.4
1A4A:  BSF    FF1.4
....................     //ext_int_edge(L_TO_H);              //por flanco de subida 
....................     enable_interrupts(GLOBAL); //Habilita interrupcin general 
1A4C:  MOVLW  C0
1A4E:  IORWF  FF2,F
....................     lcd_init(); 
1A50:  GOTO   0690
....................  
....................     while (1) { 
....................         flagfin = 0; 
1A54:  CLRF   37
....................         flagmecha = 0; 
1A56:  CLRF   x63
....................         flagcomienzo = 0; 
1A58:  CLRF   x62
....................         xini = 0; 
1A5A:  CLRF   46
1A5C:  CLRF   45
1A5E:  CLRF   44
1A60:  CLRF   43
....................         yini = 0; 
1A62:  CLRF   4A
1A64:  CLRF   49
1A66:  CLRF   48
1A68:  CLRF   47
....................         zini = 0; 
1A6A:  CLRF   x6C
1A6C:  CLRF   x6B
1A6E:  CLRF   x6A
1A70:  CLRF   x69
....................         flagajuste = 0; 
1A72:  BCF    1E.2
....................         flagpaquete = 0; 
1A74:  BCF    1E.1
....................         pasosx = 0; 
1A76:  CLRF   4E
1A78:  CLRF   4D
1A7A:  CLRF   4C
1A7C:  CLRF   4B
....................         pasosz = 0; 
1A7E:  CLRF   x68
1A80:  CLRF   x67
1A82:  CLRF   x66
1A84:  CLRF   x65
....................         pasosy = 0; 
1A86:  CLRF   52
1A88:  CLRF   51
1A8A:  CLRF   50
1A8C:  CLRF   4F
....................         alturamecha = 0; 
1A8E:  CLRF   x74
1A90:  CLRF   x73
1A92:  CLRF   x72
1A94:  CLRF   x71
....................         x = 0; 
1A96:  CLRF   3E
1A98:  CLRF   3D
1A9A:  CLRF   3C
1A9C:  CLRF   3B
....................         y = 0; 
1A9E:  CLRF   42
1AA0:  CLRF   41
1AA2:  CLRF   40
1AA4:  CLRF   3F
....................         z = 0; 
1AA6:  CLRF   x70
1AA8:  CLRF   x6F
1AAA:  CLRF   x6E
1AAC:  CLRF   x6D
....................         flagboton = 0; 
1AAE:  CLRF   x64
....................         flagxy = 0; 
1AB0:  CLRF   x61
....................         flagx = 0; 
1AB2:  CLRF   5F
....................         flagy = 0; 
1AB4:  CLRF   x60
....................         broca = 0; 
1AB6:  CLRF   56
1AB8:  CLRF   55
1ABA:  CLRF   54
1ABC:  CLRF   53
....................         pasosxflot = 0; 
1ABE:  CLRF   5A
1AC0:  CLRF   59
1AC2:  CLRF   58
1AC4:  CLRF   57
....................         pasosyflot = 0; 
1AC6:  CLRF   5E
1AC8:  CLRF   5D
1ACA:  CLRF   5C
1ACC:  CLRF   5B
....................         salir = 0; 
1ACE:  CLRF   38
....................         i = 0; 
1AD0:  CLRF   34
....................         j = 0; 
1AD2:  CLRF   35
....................         h = 0; 
1AD4:  CLRF   36
....................         output_high(habilx); //motores sin energa 
1AD6:  BCF    F96.2
1AD8:  BSF    F8D.2
....................         output_high(habily); 
1ADA:  BCF    F92.0
1ADC:  BSF    F89.0
....................         output_high(habilz); 
1ADE:  BCF    F92.1
1AE0:  BSF    F89.1
....................         output_low(dremel); //apago el dremel 
1AE2:  BCF    F96.0
1AE4:  BCF    F8D.0
....................         output_low(buzzer); // apago buzzer 
1AE6:  BCF    F92.3
1AE8:  BCF    F89.3
....................         lcd_putc("\fHAGA CLICK EN"); 
1AEA:  MOVLW  FA
1AEC:  MOVWF  FF6
1AEE:  MOVLW  03
1AF0:  MOVWF  FF7
1AF2:  CALL   07BC
....................         lcd_putc("\2CALIBRAR EN LA"); 
1AF6:  MOVLW  0A
1AF8:  MOVWF  FF6
1AFA:  MOVLW  04
1AFC:  MOVWF  FF7
1AFE:  CALL   07BC
....................         lcd_putc("\3COMPUTADORA Y ESPERE"); 
1B02:  MOVLW  1A
1B04:  MOVWF  FF6
1B06:  MOVLW  04
1B08:  MOVWF  FF7
1B0A:  CALL   07BC
....................         lcd_putc("\4UN MOMENTO."); 
1B0E:  MOVLW  30
1B10:  MOVWF  FF6
1B12:  MOVLW  04
1B14:  MOVWF  FF7
1B16:  CALL   07BC
....................         while (flagcomienzo == 0); 
1B1A:  MOVF   x62,F
1B1C:  BZ    1B1A
....................         flagcomienzo = 0; 
1B1E:  CLRF   x62
....................         ajusteceroz(); 
1B20:  CALL   07DC
....................         ajusteceroxy(); 
1B24:  CALL   084A
....................         posicionmecha(); 
1B28:  CALL   10B2
....................         mecha(); 
1B2C:  RCALL  145E
....................         printf(lcd_putc"\f\1Coloque mecha %01.2fmm", broca); 
1B2E:  MOVLW  3E
1B30:  MOVWF  FF6
1B32:  MOVLW  04
1B34:  MOVWF  FF7
1B36:  MOVLW  10
1B38:  MOVWF  x79
1B3A:  RCALL  1486
1B3C:  MOVLW  C9
1B3E:  MOVWF  FE9
1B40:  MOVFF  56,7C
1B44:  MOVFF  55,7B
1B48:  MOVFF  54,7A
1B4C:  MOVFF  53,79
1B50:  MOVLW  02
1B52:  MOVWF  x7D
1B54:  RCALL  1572
1B56:  MOVLW  6D
1B58:  MOVWF  x86
1B5A:  CALL   074E
1B5E:  MOVLW  6D
1B60:  MOVWF  x86
1B62:  CALL   074E
....................         lcd_putc("\2Presione enter para"); 
1B66:  MOVLW  58
1B68:  MOVWF  FF6
1B6A:  MOVLW  04
1B6C:  MOVWF  FF7
1B6E:  CALL   07BC
....................         lcd_putc("\3comenzar el ajuste"); 
1B72:  MOVLW  6E
1B74:  MOVWF  FF6
1B76:  MOVLW  04
1B78:  MOVWF  FF7
1B7A:  CALL   07BC
....................         lcd_putc("\4de la placa."); 
1B7E:  MOVLW  82
1B80:  MOVWF  FF6
1B82:  MOVLW  04
1B84:  MOVWF  FF7
1B86:  CALL   07BC
....................         while (input(enter) == 0)  
1B8A:  BSF    F96.1
1B8C:  BTFSC  F84.1
1B8E:  BRA    1B92
....................         { 
1B90:  BRA    1B8A
1B92:  CLRF   16
1B94:  BTFSC  FF2.7
1B96:  BSF    16.7
1B98:  BCF    FF2.7
....................         } 
....................         delay_ms(10); 
1B9A:  MOVLW  0A
1B9C:  MOVWF  x9C
1B9E:  CALL   014A
1BA2:  BTFSC  16.7
1BA4:  BSF    FF2.7
....................         bip(); 
1BA6:  RCALL  16F2
....................         while (input(enter) == 1)  
1BA8:  BSF    F96.1
1BAA:  BTFSS  F84.1
1BAC:  BRA    1BB0
....................         { 
1BAE:  BRA    1BA8
....................         } 
....................         alturamecha = 0; 
1BB0:  CLRF   x74
1BB2:  CLRF   x73
1BB4:  CLRF   x72
1BB6:  CLRF   x71
....................         profundidadmecha(); 
1BB8:  RCALL  1704
....................         zini = alturamecha; 
1BBA:  MOVFF  74,6C
1BBE:  MOVFF  73,6B
1BC2:  MOVFF  72,6A
1BC6:  MOVFF  71,69
....................         z = alturamecha - 500;  
1BCA:  MOVLW  F4
1BCC:  SUBWF  x71,W
1BCE:  MOVWF  x6D
1BD0:  MOVLW  01
1BD2:  SUBWFB x72,W
1BD4:  MOVWF  x6E
1BD6:  MOVLW  00
1BD8:  SUBWFB x73,W
1BDA:  MOVWF  x6F
1BDC:  MOVLW  00
1BDE:  SUBWFB x74,W
1BE0:  MOVWF  x70
....................         moverz(); 
1BE2:  RCALL  17C6
....................         ajusteceroxy(); 
1BE4:  CALL   084A
....................         putc('A'); 
1BE8:  MOVLW  41
1BEA:  CALL   0132
....................         while (flagajuste == 0 && salir == 0); 
1BEE:  BTFSC  1E.2
1BF0:  BRA    1BF6
1BF2:  MOVF   38,F
1BF4:  BZ    1BEE
....................  
....................         while (flagajuste == 1)  
1BF6:  BTFSS  1E.2
1BF8:  BRA    1D46
....................         { 
....................             while (flagxy == 0); 
1BFA:  MOVF   x61,F
1BFC:  BZ    1BFA
....................             while (flagxy == 1)  
1BFE:  DECFSZ x61,W
1C00:  BRA    1D44
....................             { 
....................                 x = (signed long long int) atof(datox); 
1C02:  CLRF   x7A
1C04:  MOVLW  26
1C06:  MOVWF  x79
1C08:  CLRF   x7C
1C0A:  CLRF   x7B
1C0C:  CALL   1226
1C10:  MOVFF  03,89
1C14:  MOVFF  02,88
1C18:  MOVFF  01,87
1C1C:  MOVFF  00,86
1C20:  RCALL  14A6
1C22:  MOVFF  03,3E
1C26:  MOVFF  02,3D
1C2A:  MOVFF  01,3C
1C2E:  MOVFF  00,3B
....................                 y = (signed long long int) atof(datoy); 
1C32:  CLRF   x7A
1C34:  MOVLW  2D
1C36:  MOVWF  x79
1C38:  CLRF   x7C
1C3A:  CLRF   x7B
1C3C:  CALL   1226
1C40:  MOVFF  03,89
1C44:  MOVFF  02,88
1C48:  MOVFF  01,87
1C4C:  MOVFF  00,86
1C50:  RCALL  14A6
1C52:  MOVFF  03,42
1C56:  MOVFF  02,41
1C5A:  MOVFF  01,40
1C5E:  MOVFF  00,3F
....................                 conversionpasos(); 
1C62:  CALL   0E00
....................                 xini = x; 
1C66:  MOVFF  3E,46
1C6A:  MOVFF  3D,45
1C6E:  MOVFF  3C,44
1C72:  MOVFF  3B,43
....................                 yini = y; 
1C76:  MOVFF  42,4A
1C7A:  MOVFF  41,49
1C7E:  MOVFF  40,48
1C82:  MOVFF  3F,47
....................                 clear_interrupt(INT_TIMER0); 
1C86:  BCF    FF2.2
....................                 set_timer0(230); 
1C88:  CLRF   FD7
1C8A:  MOVLW  E6
1C8C:  MOVWF  FD6
....................                 enable_interrupts(INT_TIMER0); //Habilita interrupcin timer0 
1C8E:  BSF    FF2.5
....................                 flagx = 1; 
1C90:  MOVLW  01
1C92:  MOVWF  5F
....................                 flagy = 1; 
1C94:  MOVWF  x60
....................                 while (flagxy == 1); 
1C96:  DECFSZ x61,W
1C98:  BRA    1C9C
1C9A:  BRA    1C96
....................                 lcd_putc("\f\1Gire para subir o");  
1C9C:  MOVLW  90
1C9E:  MOVWF  FF6
1CA0:  MOVLW  04
1CA2:  MOVWF  FF7
1CA4:  CALL   07BC
....................                 lcd_putc("\2bajar mecha.Presione"); 
1CA8:  MOVLW  A4
1CAA:  MOVWF  FF6
1CAC:  MOVLW  04
1CAE:  MOVWF  FF7
1CB0:  CALL   07BC
....................                 lcd_putc("\3enter nuevo punto."); 
1CB4:  MOVLW  BA
1CB6:  MOVWF  FF6
1CB8:  MOVLW  04
1CBA:  MOVWF  FF7
1CBC:  CALL   07BC
....................                 lcd_putc("\4Boton rojo salir."); 
1CC0:  MOVLW  CE
1CC2:  MOVWF  FF6
1CC4:  MOVLW  04
1CC6:  MOVWF  FF7
1CC8:  CALL   07BC
....................                 clear_interrupt(INT_EXT_L2H); 
1CCC:  BCF    FF2.1
....................                 enable_interrupts(INT_EXT_L2H); 
1CCE:  BSF    FF2.4
1CD0:  BSF    FF1.6
....................                 while (input(enter) == 0 && salir == 0)  
1CD2:  BSF    F96.1
1CD4:  BTFSC  F84.1
1CD6:  BRA    1CDE
1CD8:  MOVF   38,F
1CDA:  BNZ   1CDE
....................                 { 
1CDC:  BRA    1CD2
1CDE:  CLRF   16
1CE0:  BTFSC  FF2.7
1CE2:  BSF    16.7
1CE4:  BCF    FF2.7
....................                 } 
....................                 delay_ms(10); 
1CE6:  MOVLW  0A
1CE8:  MOVWF  x9C
1CEA:  CALL   014A
1CEE:  BTFSC  16.7
1CF0:  BSF    FF2.7
....................                 bip(); 
1CF2:  RCALL  16F2
....................                 while (input(enter) == 1 && salir == 0)  
1CF4:  BSF    F96.1
1CF6:  BTFSS  F84.1
1CF8:  BRA    1D00
1CFA:  MOVF   38,F
1CFC:  BNZ   1D00
....................                 { 
1CFE:  BRA    1CF4
....................                 } 
....................                 if (input(enter) == 0 && salir == 0)  
1D00:  BSF    F96.1
1D02:  BTFSC  F84.1
1D04:  BRA    1D42
1D06:  MOVF   38,F
1D08:  BNZ   1D42
....................                 { 
....................                     guarda = zini; 
1D0A:  MOVFF  6C,78
1D0E:  MOVFF  6B,77
1D12:  MOVFF  6A,76
1D16:  MOVFF  69,75
....................                     zini = z; 
1D1A:  MOVFF  70,6C
1D1E:  MOVFF  6F,6B
1D22:  MOVFF  6E,6A
1D26:  MOVFF  6D,69
....................                     z = guarda; 
1D2A:  MOVFF  78,70
1D2E:  MOVFF  77,6F
1D32:  MOVFF  76,6E
1D36:  MOVFF  75,6D
....................                     moverz(); 
1D3A:  RCALL  17C6
....................                     putc('A'); 
1D3C:  MOVLW  41
1D3E:  CALL   0132
....................                 } 
1D42:  BRA    1BFE
....................             } 
1D44:  BRA    1BF6
....................         } 
....................         bip(); 
1D46:  RCALL  16F2
....................         disable_interrupts(INT_EXT_L2H); 
1D48:  BCF    FF2.4
....................         //salir=0; 
....................         while (flagfin == 0) { 
1D4A:  MOVF   37,F
1D4C:  BTFSS  FD8.2
1D4E:  BRA    1E74
....................  
....................             if (salir == 0) { 
1D50:  MOVF   38,F
1D52:  BNZ   1E30
....................                 ajusteceroz(); 
1D54:  CALL   07DC
....................                 ajusteceroxy(); 
1D58:  CALL   084A
....................                 posicionmecha(); 
1D5C:  CALL   10B2
....................                 mecha(); 
1D60:  CALL   145E
....................                 lcd_putc("\f\1Por favor coloque"); 
1D64:  MOVLW  E2
1D66:  MOVWF  FF6
1D68:  MOVLW  04
1D6A:  MOVWF  FF7
1D6C:  CALL   07BC
....................                 printf(lcd_putc"\2mecha de %01.2fmm y", broca); 
1D70:  MOVLW  F6
1D72:  MOVWF  FF6
1D74:  MOVLW  04
1D76:  MOVWF  FF7
1D78:  MOVLW  0A
1D7A:  MOVWF  x79
1D7C:  CALL   1486
1D80:  MOVLW  C9
1D82:  MOVWF  FE9
1D84:  MOVFF  56,7C
1D88:  MOVFF  55,7B
1D8C:  MOVFF  54,7A
1D90:  MOVFF  53,79
1D94:  MOVLW  02
1D96:  MOVWF  x7D
1D98:  CALL   1572
1D9C:  MOVLW  06
1D9E:  MOVWF  FF6
1DA0:  MOVLW  05
1DA2:  MOVWF  FF7
1DA4:  MOVLW  04
1DA6:  MOVWF  x79
1DA8:  CALL   1486
....................                 lcd_putc("\3presione enter"); 
1DAC:  MOVLW  0C
1DAE:  MOVWF  FF6
1DB0:  MOVLW  05
1DB2:  MOVWF  FF7
1DB4:  CALL   07BC
....................  
....................  
....................                 while (input(enter) == 0)  
1DB8:  BSF    F96.1
1DBA:  BTFSC  F84.1
1DBC:  BRA    1DC0
....................                 { 
1DBE:  BRA    1DB8
1DC0:  CLRF   16
1DC2:  BTFSC  FF2.7
1DC4:  BSF    16.7
1DC6:  BCF    FF2.7
....................                 } 
....................                 delay_ms(10); 
1DC8:  MOVLW  0A
1DCA:  MOVWF  x9C
1DCC:  CALL   014A
1DD0:  BTFSC  16.7
1DD2:  BSF    FF2.7
....................                 bip(); 
1DD4:  RCALL  16F2
....................                 while (input(enter) == 1)  
1DD6:  BSF    F96.1
1DD8:  BTFSS  F84.1
1DDA:  BRA    1DDE
....................                 { 
1DDC:  BRA    1DD6
....................                 } 
....................                 alturamecha = 0; 
1DDE:  CLRF   x74
1DE0:  CLRF   x73
1DE2:  CLRF   x72
1DE4:  CLRF   x71
....................                 profundidadmecha(); 
1DE6:  RCALL  1704
....................                 zini = alturamecha; 
1DE8:  MOVFF  74,6C
1DEC:  MOVFF  73,6B
1DF0:  MOVFF  72,6A
1DF4:  MOVFF  71,69
....................                 z = alturamecha - 500; 
1DF8:  MOVLW  F4
1DFA:  SUBWF  x71,W
1DFC:  MOVWF  x6D
1DFE:  MOVLW  01
1E00:  SUBWFB x72,W
1E02:  MOVWF  x6E
1E04:  MOVLW  00
1E06:  SUBWFB x73,W
1E08:  MOVWF  x6F
1E0A:  MOVLW  00
1E0C:  SUBWFB x74,W
1E0E:  MOVWF  x70
....................                 moverz(); 
1E10:  RCALL  17C6
....................                 ajusteceroxy(); 
1E12:  CALL   084A
....................                 puts("OK"); 
1E16:  MOVLW  1C
1E18:  MOVWF  FF6
1E1A:  MOVLW  05
1E1C:  MOVWF  FF7
1E1E:  BRA    18E2
1E20:  MOVLW  0D
1E22:  BTFSS  F9E.4
1E24:  BRA    1E22
1E26:  MOVWF  FAD
1E28:  MOVLW  0A
1E2A:  BTFSS  F9E.4
1E2C:  BRA    1E2A
1E2E:  MOVWF  FAD
....................             } 
....................             ajusteceroxy(); 
1E30:  CALL   084A
....................             contador = 2; 
1E34:  MOVLW  02
1E36:  MOVWF  39
....................             lcd_putc("\f\1Perforadora Lista"); 
1E38:  MOVLW  20
1E3A:  MOVWF  FF6
1E3C:  MOVLW  05
1E3E:  MOVWF  FF7
1E40:  CALL   07BC
....................             lcd_putc("\2para operar haga click"); 
1E44:  MOVLW  34
1E46:  MOVWF  FF6
1E48:  MOVLW  05
1E4A:  MOVWF  FF7
1E4C:  CALL   07BC
....................             lcd_putc("\3en \"Comenzar\""); 
1E50:  MOVLW  4C
1E52:  MOVWF  FF6
1E54:  MOVLW  05
1E56:  MOVWF  FF7
1E58:  CALL   07BC
....................             while (flagcomienzo == 0); 
1E5C:  MOVF   x62,F
1E5E:  BZ    1E5C
....................              
....................             lcd_putc("\f\1PERFORANDO"); 
1E60:  MOVLW  5C
1E62:  MOVWF  FF6
1E64:  MOVLW  05
1E66:  MOVWF  FF7
1E68:  CALL   07BC
....................             flagcomienzo = 0; 
1E6C:  CLRF   x62
....................             perforacion(); 
1E6E:  BRA    1906
....................             salir = 0; 
1E70:  CLRF   38
1E72:  BRA    1D4A
....................         } 
1E74:  BRA    1A54
....................     } 
.................... } 
1E76:  SLEEP 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
